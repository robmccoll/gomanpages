.\"    Automatically generated by mango(1)
.TH "sql" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
sql \- Package sql provides a generic interface around SQL (or SQL-like)
databases.
.SH "SYNOPSIS"
.B import \*(lqsql\(rq
.sp
.B Variables
.sp 0
.RB "func " Register
.sp 0
.RB "type " DB
.sp 0
.RS
.RB "func " Open
.sp 0
.RB "func (*DB) " Begin
.sp 0
.RB "func (*DB) " Close
.sp 0
.RB "func (*DB) " Driver
.sp 0
.RB "func (*DB) " Exec
.sp 0
.RB "func (*DB) " Ping
.sp 0
.RB "func (*DB) " Prepare
.sp 0
.RB "func (*DB) " Query
.sp 0
.RB "func (*DB) " QueryRow
.sp 0
.RB "func (*DB) " SetMaxIdleConns
.sp 0
.RB "func (*DB) " SetMaxOpenConns
.sp 0
.RE
.RB "type " NullBool
.sp 0
.RS
.RB "func (*NullBool) " Scan
.sp 0
.RB "func (NullBool) " Value
.sp 0
.RE
.RB "type " NullFloat64
.sp 0
.RS
.RB "func (*NullFloat64) " Scan
.sp 0
.RB "func (NullFloat64) " Value
.sp 0
.RE
.RB "type " NullInt64
.sp 0
.RS
.RB "func (*NullInt64) " Scan
.sp 0
.RB "func (NullInt64) " Value
.sp 0
.RE
.RB "type " NullString
.sp 0
.RS
.RB "func (*NullString) " Scan
.sp 0
.RB "func (NullString) " Value
.sp 0
.RE
.RB "type " RawBytes
.sp 0
.RB "type " Result
.sp 0
.RS
.RE
.RB "type " Row
.sp 0
.RS
.RB "func (*Row) " Scan
.sp 0
.RE
.RB "type " Rows
.sp 0
.RS
.RB "func (*Rows) " Close
.sp 0
.RB "func (*Rows) " Columns
.sp 0
.RB "func (*Rows) " Err
.sp 0
.RB "func (*Rows) " Next
.sp 0
.RB "func (*Rows) " Scan
.sp 0
.RE
.RB "type " Scanner
.sp 0
.RB "type " Stmt
.sp 0
.RS
.RB "func (*Stmt) " Close
.sp 0
.RB "func (*Stmt) " Exec
.sp 0
.RB "func (*Stmt) " Query
.sp 0
.RB "func (*Stmt) " QueryRow
.sp 0
.RE
.RB "type " Tx
.sp 0
.RS
.RB "func (*Tx) " Commit
.sp 0
.RB "func (*Tx) " Exec
.sp 0
.RB "func (*Tx) " Prepare
.sp 0
.RB "func (*Tx) " Query
.sp 0
.RB "func (*Tx) " QueryRow
.sp 0
.RB "func (*Tx) " Rollback
.sp 0
.RB "func (*Tx) " Stmt
.sp 0
.RE
.RB "type " driverConn
.sp 0
.RS
.RB "func (*driverConn) " Close
.sp 0
.RE
.RB "type " driverResult
.sp 0
.RS
.RB "func (driverResult) " LastInsertId
.sp 0
.RB "func (driverResult) " RowsAffected
.sp 0
.RE
.RB "type " driverStmt
.sp 0
.RS
.RB "func (*driverStmt) " Close
.sp 0
.RE
.SH "DESCRIPTION"
The sql package must be used in conjunction with a database driver. 
See http://golang.org/s/sqldrivers for a list of drivers. 
.PP
For more usage examples, see the wiki page at http://golang.org/s/sqlwiki. 
.SH "VARIABLES"
ErrNoRows is returned by Scan when QueryRow doesn't return a row. 
In such a case, QueryRow returns a placeholder *Row value that defers this error until a Scan. 
.PP
.B var 
.B ErrNoRows 
.sp 0

.sp 0
.PP
.B var 
.B ErrTxDone 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func Register(" "name" " string, " "driver" " driver.Driver)"
.PP
Register makes a database driver available by the provided name. 
If Register is called twice with the same name or if driver is nil, it panics. 
.SH "TYPES"
.SS "DB"
.B type DB struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
DB is a database handle representing a pool of zero or more underlying connections. 
It's safe for concurrent use by multiple goroutines. 
.PP
The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. 
If the database has a concept of per\-connection state, such state can only be reliably observed within a transaction. 
Once DB.Begin is called, the returned Tx is bound to a single connection. 
Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. 
The pool size can be controlled with SetMaxIdleConns. 
.PP
.BR "func Open(" "driverName" ", " "dataSourceName" " string) (*DB, error)"
.PP
Open opens a database specified by its database driver name and a driver\-specific data source name, usually consisting of at least a database name and connection information. 
.PP
Most users will open a database via a driver\-specific connection helper function that returns a *DB. 
No database drivers are included in the Go standard library. 
See http://golang.org/s/sqldrivers for a list of third\-party drivers. 
.PP
Open may just validate its arguments without creating a connection to the database. 
To verify that the data source name is valid, call Ping. 
.PP
The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. 
Thus, the Open function should be called just once. 
It is rarely necessary to close a DB. 
.PP
.BR "func (*DB) Begin() (*Tx, error)"
.PP
Begin starts a transaction. 
The isolation level is dependent on the driver. 
.PP
.BR "func (*DB) Close() error"
.PP
Close closes the database, releasing any open resources. 
.PP
It is rare to Close a DB, as the DB handle is meant to be long\-lived and shared between many goroutines. 
.PP
.BR "func (*DB) Driver() driver.Driver"
.PP
Driver returns the database's underlying driver. 
.PP
.BR "func (*DB) Exec(" "query" " string, " "args" " ...interface{}) (Result, error)"
.PP
Exec executes a query without returning any rows. 
The args are for any placeholder parameters in the query. 
.PP
.BR "func (*DB) Ping() error"
.PP
Ping verifies a connection to the database is still alive, establishing a connection if necessary. 
.PP
.BR "func (*DB) Prepare(" "query" " string) (*Stmt, error)"
.PP
Prepare creates a prepared statement for later queries or executions. 
Multiple queries or executions may be run concurrently from the returned statement. 
.PP
.BR "func (*DB) Query(" "query" " string, " "args" " ...interface{}) (*Rows, error)"
.PP
Query executes a query that returns rows, typically a SELECT. 
The args are for any placeholder parameters in the query. 
.PP
.BR "func (*DB) QueryRow(" "query" " string, " "args" " ...interface{}) *Row"
.PP
QueryRow executes a query that is expected to return at most one row. 
QueryRow always return a non\-nil value. 
Errors are deferred until Row's Scan method is called. 
.PP
.BR "func (*DB) SetMaxIdleConns(" "n" " int)"
.PP
SetMaxIdleConns sets the maximum number of connections in the idle connection pool. 
.PP
If MaxOpenConns is greater than 0 but less than the new MaxIdleConns then the new MaxIdleConns will be reduced to match the MaxOpenConns limit 
.PP
If n <= 0, no idle connections are retained. 
.PP
.BR "func (*DB) SetMaxOpenConns(" "n" " int)"
.PP
SetMaxOpenConns sets the maximum number of open connections to the database. 
.PP
If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit 
.PP
If n <= 0, then there is no limit on the number of open connections. 
The default is 0 (unlimited). 
.SS "NullBool"
.B type NullBool struct {
.RS
.B Bool bool
.sp 0
.B Valid bool
.RE
.B }
.PP
NullBool represents a bool that may be null. 
NullBool implements the Scanner interface so it can be used as a scan destination, similar to NullString. 
.PP
.BR "func (*NullBool) Scan(" "value" " interface{}) error"
.PP
Scan implements the Scanner interface. 
.PP
.BR "func (NullBool) Value() (driver.Value, error)"
.PP
Value implements the driver Valuer interface. 
.SS "NullFloat64"
.B type NullFloat64 struct {
.RS
.B Float64 float64
.sp 0
.B Valid bool
.RE
.B }
.PP
NullFloat64 represents a float64 that may be null. 
NullFloat64 implements the Scanner interface so it can be used as a scan destination, similar to NullString. 
.PP
.BR "func (*NullFloat64) Scan(" "value" " interface{}) error"
.PP
Scan implements the Scanner interface. 
.PP
.BR "func (NullFloat64) Value() (driver.Value, error)"
.PP
Value implements the driver Valuer interface. 
.SS "NullInt64"
.B type NullInt64 struct {
.RS
.B Int64 int64
.sp 0
.B Valid bool
.RE
.B }
.PP
NullInt64 represents an int64 that may be null. 
NullInt64 implements the Scanner interface so it can be used as a scan destination, similar to NullString. 
.PP
.BR "func (*NullInt64) Scan(" "value" " interface{}) error"
.PP
Scan implements the Scanner interface. 
.PP
.BR "func (NullInt64) Value() (driver.Value, error)"
.PP
Value implements the driver Valuer interface. 
.SS "NullString"
.B type NullString struct {
.RS
.B String string
.sp 0
.B Valid bool
.RE
.B }
.PP
NullString represents a string that may be null. 
NullString implements the Scanner interface so it can be used as a scan destination: 
.PP
var s NullString err := db.QueryRow("SELECT name FROM foo WHERE id=?", id).Scan(&s) \&... 
if s.Valid { 
.PP
.RS
// use s.String
.RE
.PP
} else {    
.PP
.RS
// NULL value
.RE
.PP
}    
.PP
.BR "func (*NullString) Scan(" "value" " interface{}) error"
.PP
Scan implements the Scanner interface. 
.PP
.BR "func (NullString) Value() (driver.Value, error)"
.PP
Value implements the driver Valuer interface. 
.SS "RawBytes"
.B type RawBytes []byte
.PP
RawBytes is a byte slice that holds a reference to memory owned by the database itself. 
After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close. 
.SS "Result"
.B type Result interface {
.RS
.B LastInsertId() (int64, error)
.sp 0
.B RowsAffected() (int64, error)
.sp 0
.RE
.B }
.PP
A Result summarizes an executed SQL command. 
.SS "Row"
.B type Row struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Row is the result of calling QueryRow to select a single row. 
.PP
.BR "func (*Row) Scan(" "dest" " ...interface{}) error"
.PP
Scan copies the columns from the matched row into the values pointed at by dest. 
If more than one row matches the query, Scan uses the first row and discards the rest. 
If no row matches the query, Scan returns ErrNoRows. 
.SS "Rows"
.B type Rows struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Rows is the result of a query. 
Its cursor starts before the first row of the result set. 
Use Next to advance through the rows: 
.PP
.RS
rows, err := db.Query("SELECT \&...")
.sp 0
\&...
.sp 0
defer rows.Close()
.sp 0
for rows.Next() {
.sp 0
.RS
var id int
.sp 0
var name string
.sp 0
err = rows.Scan(&id, &name)
.sp 0
\&...
.sp 0
.RE
}
.sp 0
err = rows.Err() // get any error encountered during iteration
.sp 0
\&...
.RE
.PP
.BR "func (*Rows) Close() error"
.PP
Close closes the Rows, preventing further enumeration. 
If Next returns false, the Rows are closed automatically and it will suffice to check the result of Err. 
Close is idempotent and does not affect the result of Err. 
.PP
.BR "func (*Rows) Columns() ([]string, error)"
.PP
Columns returns the column names. 
Columns returns an error if the rows are closed, or if the rows are from QueryRow and there was a deferred error. 
.PP
.BR "func (*Rows) Err() error"
.PP
Err returns the error, if any, that was encountered during iteration. 
Err may be called after an explicit or implicit Close. 
.PP
.BR "func (*Rows) Next() bool"
.PP
Next prepares the next result row for reading with the Scan method. 
It returns true on success, or false if there is no next result row or an error happened while preparing it. 
Err should be consulted to distinguish between the two cases. 
.PP
Every call to Scan, even the first one, must be preceded by a call to Next. 
.PP
.BR "func (*Rows) Scan(" "dest" " ...interface{}) error"
.PP
Scan copies the columns in the current row into the values pointed at by dest. 
.PP
If an argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. 
The copy is owned by the caller and can be modified and held indefinitely. 
The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use. 
.PP
If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. 
If the value is of type []byte, a copy is made and the caller owns the result. 
.SS "Scanner"
.B type Scanner interface {
.RS
.B Scan(src interface{}) error
.sp 0
.RE
.B }
.PP
Scanner is an interface used by Scan. 
.SS "Stmt"
.B type Stmt struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Stmt is a prepared statement. 
Stmt is safe for concurrent use by multiple goroutines. 
.PP
.BR "func (*Stmt) Close() error"
.PP
Close closes the statement. 
.PP
.BR "func (*Stmt) Exec(" "args" " ...interface{}) (Result, error)"
.PP
Exec executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement. 
.PP
.BR "func (*Stmt) Query(" "args" " ...interface{}) (*Rows, error)"
.PP
Query executes a prepared query statement with the given arguments and returns the query results as a *Rows. 
.PP
.BR "func (*Stmt) QueryRow(" "args" " ...interface{}) *Row"
.PP
QueryRow executes a prepared query statement with the given arguments. 
If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non\-nil. 
If the query selects no rows, the *Row's Scan will return ErrNoRows. 
Otherwise, the *Row's Scan scans the first selected row and discards the rest. 
.PP
Example usage: 
.PP
var name string err := nameByUseridStmt.QueryRow(id).Scan(&name) 
.SS "Tx"
.B type Tx struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Tx is an in\-progress database transaction. 
.PP
A transaction must end with a call to Commit or Rollback. 
.PP
After a call to Commit or Rollback, all operations on the transaction fail with ErrTxDone. 
.PP
.BR "func (*Tx) Commit() error"
.PP
Commit commits the transaction. 
.PP
.BR "func (*Tx) Exec(" "query" " string, " "args" " ...interface{}) (Result, error)"
.PP
Exec executes a query that doesn't return rows. 
For example: an INSERT and UPDATE. 
.PP
.BR "func (*Tx) Prepare(" "query" " string) (*Stmt, error)"
.PP
Prepare creates a prepared statement for use within a transaction. 
.PP
The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back. 
.PP
To use an existing prepared statement on this transaction, see Tx.Stmt. 
.PP
.BR "func (*Tx) Query(" "query" " string, " "args" " ...interface{}) (*Rows, error)"
.PP
Query executes a query that returns rows, typically a SELECT. 
.PP
.BR "func (*Tx) QueryRow(" "query" " string, " "args" " ...interface{}) *Row"
.PP
QueryRow executes a query that is expected to return at most one row. 
QueryRow always return a non\-nil value. 
Errors are deferred until Row's Scan method is called. 
.PP
.BR "func (*Tx) Rollback() error"
.PP
Rollback aborts the transaction. 
.PP
.BR "func (*Tx) Stmt(" "stmt" " *Stmt) *Stmt"
.PP
Stmt returns a transaction\-specific prepared statement from an existing statement. 
.PP
Example: updateMoney, err := db.Prepare("UPDATE balance SET money=money+? 
WHERE id=?") \&... 
tx, err := db.Begin() \&... 
res, err := tx.Stmt(updateMoney).Exec(123.45, 98293203) 
.SS "driverConn"
.B type driverConn struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
driverConn wraps a driver.Conn with a mutex, to be held during all calls into the Conn. 
(including any calls onto interfaces returned via that Conn, such as calls on Tx, Stmt, Result, Rows) 
.PP
.BR "func (*driverConn) Close() error"
.SS "driverResult"
.B type driverResult struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (driverResult) LastInsertId() (int64, error)"
.PP
.BR "func (driverResult) RowsAffected() (int64, error)"
.SS "driverStmt"
.B type driverStmt struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
driverStmt associates a driver.Stmt with the *driverConn from which it came, so the driverConn's lock can be held during calls. 
.PP
.BR "func (*driverStmt) Close() error"
