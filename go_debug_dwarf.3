.\"    Automatically generated by mango(1)
.TH "dwarf" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
dwarf \- Package dwarf provides access to DWARF debugging information loaded from
executable files, as defined in the DWARF 2.0 Standard at
http://dwarfstd.org/doc/dwarf-2.0.0.pdf
.SH "SYNOPSIS"
.B import \*(lqdwarf\(rq
.sp
.RB "type " AddrType
.sp 0
.RS
.RB "func (*AddrType) " Basic
.sp 0
.RB "func (*AddrType) " Common
.sp 0
.RB "func (*AddrType) " Size
.sp 0
.RB "func (*AddrType) " String
.sp 0
.RE
.RB "type " ArrayType
.sp 0
.RS
.RB "func (*ArrayType) " Common
.sp 0
.RB "func (*ArrayType) " Size
.sp 0
.RB "func (*ArrayType) " String
.sp 0
.RE
.RB "type " Attr
.sp 0
.RS
.RB "func (Attr) " GoString
.sp 0
.RB "func (Attr) " String
.sp 0
.RE
.RB "type " BasicType
.sp 0
.RS
.RB "func (*BasicType) " Basic
.sp 0
.RB "func (*BasicType) " Common
.sp 0
.RB "func (*BasicType) " Size
.sp 0
.RB "func (*BasicType) " String
.sp 0
.RE
.RB "type " BoolType
.sp 0
.RS
.RB "func (*BoolType) " Basic
.sp 0
.RB "func (*BoolType) " Common
.sp 0
.RB "func (*BoolType) " Size
.sp 0
.RB "func (*BoolType) " String
.sp 0
.RE
.RB "type " CharType
.sp 0
.RS
.RB "func (*CharType) " Basic
.sp 0
.RB "func (*CharType) " Common
.sp 0
.RB "func (*CharType) " Size
.sp 0
.RB "func (*CharType) " String
.sp 0
.RE
.RB "type " CommonType
.sp 0
.RS
.RB "func (*CommonType) " Common
.sp 0
.RB "func (*CommonType) " Size
.sp 0
.RE
.RB "type " ComplexType
.sp 0
.RS
.RB "func (*ComplexType) " Basic
.sp 0
.RB "func (*ComplexType) " Common
.sp 0
.RB "func (*ComplexType) " Size
.sp 0
.RB "func (*ComplexType) " String
.sp 0
.RE
.RB "type " Data
.sp 0
.RS
.RB "func " New
.sp 0
.RB "func (*Data) " AddTypes
.sp 0
.RB "func (*Data) " Reader
.sp 0
.RB "func (*Data) " Type
.sp 0
.RE
.RB "type " DecodeError
.sp 0
.RS
.RB "func (DecodeError) " Error
.sp 0
.RE
.RB "type " DotDotDotType
.sp 0
.RS
.RB "func (*DotDotDotType) " Common
.sp 0
.RB "func (*DotDotDotType) " Size
.sp 0
.RB "func (*DotDotDotType) " String
.sp 0
.RE
.RB "type " Entry
.sp 0
.RS
.RB "func (*Entry) " Val
.sp 0
.RE
.RB "type " EnumType
.sp 0
.RS
.RB "func (*EnumType) " Common
.sp 0
.RB "func (*EnumType) " Size
.sp 0
.RB "func (*EnumType) " String
.sp 0
.RE
.RB "type " EnumValue
.sp 0
.RB "type " Field
.sp 0
.RB "type " FloatType
.sp 0
.RS
.RB "func (*FloatType) " Basic
.sp 0
.RB "func (*FloatType) " Common
.sp 0
.RB "func (*FloatType) " Size
.sp 0
.RB "func (*FloatType) " String
.sp 0
.RE
.RB "type " FuncType
.sp 0
.RS
.RB "func (*FuncType) " Common
.sp 0
.RB "func (*FuncType) " Size
.sp 0
.RB "func (*FuncType) " String
.sp 0
.RE
.RB "type " IntType
.sp 0
.RS
.RB "func (*IntType) " Basic
.sp 0
.RB "func (*IntType) " Common
.sp 0
.RB "func (*IntType) " Size
.sp 0
.RB "func (*IntType) " String
.sp 0
.RE
.RB "type " Offset
.sp 0
.RB "type " PtrType
.sp 0
.RS
.RB "func (*PtrType) " Common
.sp 0
.RB "func (*PtrType) " Size
.sp 0
.RB "func (*PtrType) " String
.sp 0
.RE
.RB "type " QualType
.sp 0
.RS
.RB "func (*QualType) " Common
.sp 0
.RB "func (*QualType) " Size
.sp 0
.RB "func (*QualType) " String
.sp 0
.RE
.RB "type " Reader
.sp 0
.RS
.RB "func (*Reader) " Next
.sp 0
.RB "func (*Reader) " Seek
.sp 0
.RB "func (*Reader) " SkipChildren
.sp 0
.RE
.RB "type " StructField
.sp 0
.RB "type " StructType
.sp 0
.RS
.RB "func (*StructType) " Common
.sp 0
.RB "func (*StructType) " Defn
.sp 0
.RB "func (*StructType) " Size
.sp 0
.RB "func (*StructType) " String
.sp 0
.RE
.RB "type " Tag
.sp 0
.RS
.RB "func (Tag) " GoString
.sp 0
.RB "func (Tag) " String
.sp 0
.RE
.RB "type " Type
.sp 0
.RB "type " TypedefType
.sp 0
.RS
.RB "func (*TypedefType) " Common
.sp 0
.RB "func (*TypedefType) " Size
.sp 0
.RB "func (*TypedefType) " String
.sp 0
.RE
.RB "type " UcharType
.sp 0
.RS
.RB "func (*UcharType) " Basic
.sp 0
.RB "func (*UcharType) " Common
.sp 0
.RB "func (*UcharType) " Size
.sp 0
.RB "func (*UcharType) " String
.sp 0
.RE
.RB "type " UintType
.sp 0
.RS
.RB "func (*UintType) " Basic
.sp 0
.RB "func (*UintType) " Common
.sp 0
.RB "func (*UintType) " Size
.sp 0
.RB "func (*UintType) " String
.sp 0
.RE
.RB "type " VoidType
.sp 0
.RS
.RB "func (*VoidType) " Common
.sp 0
.RB "func (*VoidType) " Size
.sp 0
.RB "func (*VoidType) " String
.sp 0
.RE
.RB "type " typeReader
.sp 0
.RB "type " typeUnitReader
.sp 0
.RS
.RB "func (*typeUnitReader) " Next
.sp 0
.RB "func (*typeUnitReader) " Seek
.sp 0
.RE
.SH "TYPES"
.SS "AddrType"
.B type AddrType struct {
.RS
.B BasicType
.RE
.B }
.PP
An AddrType represents a machine address type. 
.PP
.BR "func (*AddrType) Basic() *BasicType"
.PP
.BR "func (*AddrType) Common() *CommonType"
.PP
.BR "func (*AddrType) Size() int64"
.PP
.BR "func (*AddrType) String() string"
.SS "ArrayType"
.B type ArrayType struct {
.RS
.B CommonType
.sp 0
.B Type Type
.sp 0
.B StrideBitSize int64
.sp 0
.B Count int64
.RE
.B }
.PP
An ArrayType represents a fixed size array type. 
.PP
.BR "func (*ArrayType) Common() *CommonType"
.PP
.BR "func (*ArrayType) Size() int64"
.PP
.BR "func (*ArrayType) String() string"
.SS "Attr"
.B type Attr uint32
.PP
An Attr identifies the attribute type in a DWARF Entry's Field. 
.PP
.B const (
.RS
.B AttrSibling 
.sp 0
.B AttrLocation 
.sp 0
.B AttrName 
.sp 0
.B AttrOrdering 
.sp 0
.B AttrByteSize 
.sp 0
.B AttrBitOffset 
.sp 0
.B AttrBitSize 
.sp 0
.B AttrStmtList 
.sp 0
.B AttrLowpc 
.sp 0
.B AttrHighpc 
.sp 0
.B AttrLanguage 
.sp 0
.B AttrDiscr 
.sp 0
.B AttrDiscrValue 
.sp 0
.B AttrVisibility 
.sp 0
.B AttrImport 
.sp 0
.B AttrStringLength 
.sp 0
.B AttrCommonRef 
.sp 0
.B AttrCompDir 
.sp 0
.B AttrConstValue 
.sp 0
.B AttrContainingType 
.sp 0
.B AttrDefaultValue 
.sp 0
.B AttrInline 
.sp 0
.B AttrIsOptional 
.sp 0
.B AttrLowerBound 
.sp 0
.B AttrProducer 
.sp 0
.B AttrPrototyped 
.sp 0
.B AttrReturnAddr 
.sp 0
.B AttrStartScope 
.sp 0
.B AttrStrideSize 
.sp 0
.B AttrUpperBound 
.sp 0
.B AttrAbstractOrigin 
.sp 0
.B AttrAccessibility 
.sp 0
.B AttrAddrClass 
.sp 0
.B AttrArtificial 
.sp 0
.B AttrBaseTypes 
.sp 0
.B AttrCalling 
.sp 0
.B AttrCount 
.sp 0
.B AttrDataMemberLoc 
.sp 0
.B AttrDeclColumn 
.sp 0
.B AttrDeclFile 
.sp 0
.B AttrDeclLine 
.sp 0
.B AttrDeclaration 
.sp 0
.B AttrDiscrList 
.sp 0
.B AttrEncoding 
.sp 0
.B AttrExternal 
.sp 0
.B AttrFrameBase 
.sp 0
.B AttrFriend 
.sp 0
.B AttrIdentifierCase 
.sp 0
.B AttrMacroInfo 
.sp 0
.B AttrNamelistItem 
.sp 0
.B AttrPriority 
.sp 0
.B AttrSegment 
.sp 0
.B AttrSpecification 
.sp 0
.B AttrStaticLink 
.sp 0
.B AttrType 
.sp 0
.B AttrUseLocation 
.sp 0
.B AttrVarParam 
.sp 0
.B AttrVirtuality 
.sp 0
.B AttrVtableElemLoc 
.sp 0
.B AttrAllocated 
.sp 0
.B AttrAssociated 
.sp 0
.B AttrDataLocation 
.sp 0
.B AttrStride 
.sp 0
.B AttrEntrypc 
.sp 0
.B AttrUseUTF8 
.sp 0
.B AttrExtension 
.sp 0
.B AttrRanges 
.sp 0
.B AttrTrampoline 
.sp 0
.B AttrCallColumn 
.sp 0
.B AttrCallFile 
.sp 0
.B AttrCallLine 
.sp 0
.B AttrDescription 
.sp 0
.RE
.B )
.PP
.BR "func (Attr) GoString() string"
.PP
.BR "func (Attr) String() string"
.SS "BasicType"
.B type BasicType struct {
.RS
.B CommonType
.sp 0
.B BitSize int64
.sp 0
.B BitOffset int64
.RE
.B }
.PP
A BasicType holds fields common to all basic types. 
.PP
.BR "func (*BasicType) Basic() *BasicType"
.PP
.BR "func (*BasicType) Common() *CommonType"
.PP
.BR "func (*BasicType) Size() int64"
.PP
.BR "func (*BasicType) String() string"
.SS "BoolType"
.B type BoolType struct {
.RS
.B BasicType
.RE
.B }
.PP
A BoolType represents a boolean type. 
.PP
.BR "func (*BoolType) Basic() *BasicType"
.PP
.BR "func (*BoolType) Common() *CommonType"
.PP
.BR "func (*BoolType) Size() int64"
.PP
.BR "func (*BoolType) String() string"
.SS "CharType"
.B type CharType struct {
.RS
.B BasicType
.RE
.B }
.PP
A CharType represents a signed character type. 
.PP
.BR "func (*CharType) Basic() *BasicType"
.PP
.BR "func (*CharType) Common() *CommonType"
.PP
.BR "func (*CharType) Size() int64"
.PP
.BR "func (*CharType) String() string"
.SS "CommonType"
.B type CommonType struct {
.RS
.B ByteSize int64
.sp 0
.B Name string
.RE
.B }
.PP
A CommonType holds fields common to multiple types. 
If a field is not known or not applicable for a given type, the zero value is used. 
.PP
.BR "func (*CommonType) Common() *CommonType"
.PP
.BR "func (*CommonType) Size() int64"
.SS "ComplexType"
.B type ComplexType struct {
.RS
.B BasicType
.RE
.B }
.PP
A ComplexType represents a complex floating point type. 
.PP
.BR "func (*ComplexType) Basic() *BasicType"
.PP
.BR "func (*ComplexType) Common() *CommonType"
.PP
.BR "func (*ComplexType) Size() int64"
.PP
.BR "func (*ComplexType) String() string"
.SS "Data"
.B type Data struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Data represents the DWARF debugging information loaded from an executable file (for example, an ELF or Mach\-O executable). 
.PP
.BR "func New(" "abbrev" ", " "aranges" ", " "frame" ", " "info" ", " "line" ", " "pubnames" ", " "ranges" ", " "str" " []byte) (*Data, error)"
.PP
New returns a new Data object initialized from the given parameters. 
Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package debug/elf, debug/macho, or debug/pe. 
.PP
The []byte arguments are the data from the corresponding debug section in the object file; for example, for an ELF object, abbrev is the contents of the ".debug_abbrev" section. 
.PP
.BR "func (*Data) AddTypes(" "name" " string, " "types" " []byte) error"
.PP
AddTypes will add one \&.debug_types section to the DWARF data. 
A typical object with DWARF version 4 debug info will have multiple \&.debug_types sections. 
The name is used for error reporting only, and serves to distinguish one \&.debug_types section from another. 
.PP
.BR "func (*Data) Reader() *Reader"
.PP
Reader returns a new Reader for Data. 
The reader is positioned at byte offset 0 in the DWARF ``info'' section. 
.PP
.BR "func (*Data) Type(" "off" " Offset) (Type, error)"
.PP
Type reads the type at off in the DWARF ``info'' section. 
.SS "DecodeError"
.B type DecodeError struct {
.RS
.B Name string
.sp 0
.B Offset Offset
.sp 0
.B Err string
.RE
.B }
.PP
.PP
.BR "func (DecodeError) Error() string"
.SS "DotDotDotType"
.B type DotDotDotType struct {
.RS
.B CommonType
.RE
.B }
.PP
A DotDotDotType represents the variadic \&... 
function parameter. 
.PP
.BR "func (*DotDotDotType) Common() *CommonType"
.PP
.BR "func (*DotDotDotType) Size() int64"
.PP
.BR "func (*DotDotDotType) String() string"
.SS "Entry"
.B type Entry struct {
.RS
.B Offset Offset
.sp 0
.B Tag Tag
.sp 0
.B Children bool
.sp 0
.B Field []Field
.RE
.B }
.PP
An entry is a sequence of attribute/value pairs. 
.PP
.BR "func (*Entry) Val(" "a" " Attr) interface{}"
.PP
Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute. 
.PP
A common idiom is to merge the check for nil return with the check that the value has the expected dynamic type, as in: 
.PP
.RS
v, ok := e.Val(AttrSibling).(int64);
.RE
.SS "EnumType"
.B type EnumType struct {
.RS
.B CommonType
.sp 0
.B EnumName string
.sp 0
.B Val []*EnumValue
.RE
.B }
.PP
An EnumType represents an enumerated type. 
The only indication of its native integer type is its ByteSize (inside CommonType). 
.PP
.BR "func (*EnumType) Common() *CommonType"
.PP
.BR "func (*EnumType) Size() int64"
.PP
.BR "func (*EnumType) String() string"
.SS "EnumValue"
.B type EnumValue struct {
.RS
.B Name string
.sp 0
.B Val int64
.RE
.B }
.PP
An EnumValue represents a single enumeration value. 
.SS "Field"
.B type Field struct {
.RS
.B Attr Attr
.sp 0
.B Val interface{}
.RE
.B }
.PP
A Field is a single attribute/value pair in an Entry. 
.SS "FloatType"
.B type FloatType struct {
.RS
.B BasicType
.RE
.B }
.PP
A FloatType represents a floating point type. 
.PP
.BR "func (*FloatType) Basic() *BasicType"
.PP
.BR "func (*FloatType) Common() *CommonType"
.PP
.BR "func (*FloatType) Size() int64"
.PP
.BR "func (*FloatType) String() string"
.SS "FuncType"
.B type FuncType struct {
.RS
.B CommonType
.sp 0
.B ReturnType Type
.sp 0
.B ParamType []Type
.RE
.B }
.PP
A FuncType represents a function type. 
.PP
.BR "func (*FuncType) Common() *CommonType"
.PP
.BR "func (*FuncType) Size() int64"
.PP
.BR "func (*FuncType) String() string"
.SS "IntType"
.B type IntType struct {
.RS
.B BasicType
.RE
.B }
.PP
An IntType represents a signed integer type. 
.PP
.BR "func (*IntType) Basic() *BasicType"
.PP
.BR "func (*IntType) Common() *CommonType"
.PP
.BR "func (*IntType) Size() int64"
.PP
.BR "func (*IntType) String() string"
.SS "Offset"
.B type Offset uint32
.PP
An Offset represents the location of an Entry within the DWARF info. 
(See Reader.Seek.) 
.SS "PtrType"
.B type PtrType struct {
.RS
.B CommonType
.sp 0
.B Type Type
.RE
.B }
.PP
A PtrType represents a pointer type. 
.PP
.BR "func (*PtrType) Common() *CommonType"
.PP
.BR "func (*PtrType) Size() int64"
.PP
.BR "func (*PtrType) String() string"
.SS "QualType"
.B type QualType struct {
.RS
.B CommonType
.sp 0
.B Qual string
.sp 0
.B Type Type
.RE
.B }
.PP
A QualType represents a type that has the C/C++ "const", "restrict", or "volatile" qualifier. 
.PP
.BR "func (*QualType) Common() *CommonType"
.PP
.BR "func (*QualType) Size() int64"
.PP
.BR "func (*QualType) String() string"
.SS "Reader"
.B type Reader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Reader allows reading Entry structures from a DWARF ``info'' section. 
The Entry structures are arranged in a tree. 
The Reader's Next function return successive entries from a pre\-order traversal of the tree. 
If an entry has children, its Children field will be true, and the children follow, terminated by an Entry with Tag 0. 
.PP
.BR "func (*Reader) Next() (*Entry, error)"
.PP
Next reads the next entry from the encoded entry stream. 
It returns nil, nil when it reaches the end of the section. 
It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid Entry. 
.PP
.BR "func (*Reader) Seek(" "off" " Offset)"
.PP
Seek positions the Reader at offset off in the encoded entry stream. 
Offset 0 can be used to denote the first entry. 
.PP
.BR "func (*Reader) SkipChildren()"
.PP
SkipChildren skips over the child entries associated with the last Entry returned by Next. 
If that Entry did not have children or Next has not been called, SkipChildren is a no\-op. 
.SS "StructField"
.B type StructField struct {
.RS
.B Name string
.sp 0
.B Type Type
.sp 0
.B ByteOffset int64
.sp 0
.B ByteSize int64
.sp 0
.B BitOffset int64
.sp 0
.B BitSize int64
.RE
.B }
.PP
A StructField represents a field in a struct, union, or C++ class type. 
.SS "StructType"
.B type StructType struct {
.RS
.B CommonType
.sp 0
.B StructName string
.sp 0
.B Kind string
.sp 0
.B Field []*StructField
.sp 0
.B Incomplete bool
.RE
.B }
.PP
A StructType represents a struct, union, or C++ class type. 
.PP
.BR "func (*StructType) Common() *CommonType"
.PP
.BR "func (*StructType) Defn() string"
.PP
.BR "func (*StructType) Size() int64"
.PP
.BR "func (*StructType) String() string"
.SS "Tag"
.B type Tag uint32
.PP
A Tag is the classification (the type) of an Entry. 
.PP
.B const (
.RS
.B TagArrayType 
.sp 0
.B TagClassType 
.sp 0
.B TagEntryPoint 
.sp 0
.B TagEnumerationType 
.sp 0
.B TagFormalParameter 
.sp 0
.B TagImportedDeclaration 
.sp 0
.B TagLabel 
.sp 0
.B TagLexDwarfBlock 
.sp 0
.B TagMember 
.sp 0
.B TagPointerType 
.sp 0
.B TagReferenceType 
.sp 0
.B TagCompileUnit 
.sp 0
.B TagStringType 
.sp 0
.B TagStructType 
.sp 0
.B TagSubroutineType 
.sp 0
.B TagTypedef 
.sp 0
.B TagUnionType 
.sp 0
.B TagUnspecifiedParameters 
.sp 0
.B TagVariant 
.sp 0
.B TagCommonDwarfBlock 
.sp 0
.B TagCommonInclusion 
.sp 0
.B TagInheritance 
.sp 0
.B TagInlinedSubroutine 
.sp 0
.B TagModule 
.sp 0
.B TagPtrToMemberType 
.sp 0
.B TagSetType 
.sp 0
.B TagSubrangeType 
.sp 0
.B TagWithStmt 
.sp 0
.B TagAccessDeclaration 
.sp 0
.B TagBaseType 
.sp 0
.B TagCatchDwarfBlock 
.sp 0
.B TagConstType 
.sp 0
.B TagConstant 
.sp 0
.B TagEnumerator 
.sp 0
.B TagFileType 
.sp 0
.B TagFriend 
.sp 0
.B TagNamelist 
.sp 0
.B TagNamelistItem 
.sp 0
.B TagPackedType 
.sp 0
.B TagSubprogram 
.sp 0
.B TagTemplateTypeParameter 
.sp 0
.B TagTemplateValueParameter 
.sp 0
.B TagThrownType 
.sp 0
.B TagTryDwarfBlock 
.sp 0
.B TagVariantPart 
.sp 0
.B TagVariable 
.sp 0
.B TagVolatileType 
.sp 0
.B TagDwarfProcedure 
.sp 0
.B TagRestrictType 
.sp 0
.B TagInterfaceType 
.sp 0
.B TagNamespace 
.sp 0
.B TagImportedModule 
.sp 0
.B TagUnspecifiedType 
.sp 0
.B TagPartialUnit 
.sp 0
.B TagImportedUnit 
.sp 0
.B TagMutableType 
.sp 0
.B TagCondition 
.sp 0
.B TagSharedType 
.sp 0
.B TagTypeUnit 
.sp 0
.B TagRvalueReferenceType 
.sp 0
.B TagTemplateAlias 
.sp 0
.RE
.B )
.PP
.BR "func (Tag) GoString() string"
.PP
.BR "func (Tag) String() string"
.SS "Type"
.B type Type interface {
.RS
.B Common() *CommonType
.sp 0
.B String() string
.sp 0
.B Size() int64
.sp 0
.RE
.B }
.PP
A Type conventionally represents a pointer to any of the specific Type structures (CharType, StructType, etc.). 
.SS "TypedefType"
.B type TypedefType struct {
.RS
.B CommonType
.sp 0
.B Type Type
.RE
.B }
.PP
A TypedefType represents a named type. 
.PP
.BR "func (*TypedefType) Common() *CommonType"
.PP
.BR "func (*TypedefType) Size() int64"
.PP
.BR "func (*TypedefType) String() string"
.SS "UcharType"
.B type UcharType struct {
.RS
.B BasicType
.RE
.B }
.PP
A UcharType represents an unsigned character type. 
.PP
.BR "func (*UcharType) Basic() *BasicType"
.PP
.BR "func (*UcharType) Common() *CommonType"
.PP
.BR "func (*UcharType) Size() int64"
.PP
.BR "func (*UcharType) String() string"
.SS "UintType"
.B type UintType struct {
.RS
.B BasicType
.RE
.B }
.PP
A UintType represents an unsigned integer type. 
.PP
.BR "func (*UintType) Basic() *BasicType"
.PP
.BR "func (*UintType) Common() *CommonType"
.PP
.BR "func (*UintType) Size() int64"
.PP
.BR "func (*UintType) String() string"
.SS "VoidType"
.B type VoidType struct {
.RS
.B CommonType
.RE
.B }
.PP
A VoidType represents the C void type. 
.PP
.BR "func (*VoidType) Common() *CommonType"
.PP
.BR "func (*VoidType) Size() int64"
.PP
.BR "func (*VoidType) String() string"
.SS "typeReader"
.B type typeReader interface {
.RS
.B Seek(Offset)
.sp 0
.B Next() (*Entry, error)
.sp 0
.B 
.sp 0
.B 
.sp 0
.sp 0
.B //contains unexported methods.
.RE
.B }
.PP
typeReader is used to read from either the info section or the types section. 
.SS "typeUnitReader"
.B type typeUnitReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
typeUnitReader is a typeReader for a tagTypeUnit. 
.PP
.BR "func (*typeUnitReader) Next() (*Entry, error)"
.PP
Next reads the next Entry from the type unit. 
.PP
.BR "func (*typeUnitReader) Seek(" "off" " Offset)"
.PP
Seek to a new position in the type unit. 
