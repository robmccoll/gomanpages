.\"    Automatically generated by mango(1)
.TH "macho" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
macho \- Package macho implements access to Mach-O object files.
.SH "SYNOPSIS"
.B import \*(lqmacho\(rq
.sp
.B Constants
.sp 0
.B Variables
.sp 0
.RB "type " Cpu
.sp 0
.RS
.RB "func (Cpu) " GoString
.sp 0
.RB "func (Cpu) " String
.sp 0
.RE
.RB "type " Dylib
.sp 0
.RS
.RB "func (Dylib) " Raw
.sp 0
.RE
.RB "type " DylibCmd
.sp 0
.RB "type " Dysymtab
.sp 0
.RS
.RB "func (Dysymtab) " Raw
.sp 0
.RE
.RB "type " DysymtabCmd
.sp 0
.RB "type " FatArch
.sp 0
.RS
.RB "func (FatArch) " Close
.sp 0
.RB "func (FatArch) " DWARF
.sp 0
.RB "func (FatArch) " ImportedLibraries
.sp 0
.RB "func (FatArch) " ImportedSymbols
.sp 0
.RB "func (FatArch) " Section
.sp 0
.RB "func (FatArch) " Segment
.sp 0
.RE
.RB "type " FatArchHeader
.sp 0
.RB "type " FatFile
.sp 0
.RS
.RB "func " NewFatFile
.sp 0
.RB "func " OpenFat
.sp 0
.RB "func (*FatFile) " Close
.sp 0
.RE
.RB "type " File
.sp 0
.RS
.RB "func " NewFile
.sp 0
.RB "func " Open
.sp 0
.RB "func (*File) " Close
.sp 0
.RB "func (*File) " DWARF
.sp 0
.RB "func (*File) " ImportedLibraries
.sp 0
.RB "func (*File) " ImportedSymbols
.sp 0
.RB "func (*File) " Section
.sp 0
.RB "func (*File) " Segment
.sp 0
.RE
.RB "type " FileHeader
.sp 0
.RB "type " FormatError
.sp 0
.RS
.RB "func (*FormatError) " Error
.sp 0
.RE
.RB "type " Load
.sp 0
.RB "type " LoadBytes
.sp 0
.RS
.RB "func (LoadBytes) " Raw
.sp 0
.RE
.RB "type " LoadCmd
.sp 0
.RS
.RB "func (LoadCmd) " GoString
.sp 0
.RB "func (LoadCmd) " String
.sp 0
.RE
.RB "type " Nlist32
.sp 0
.RB "type " Nlist64
.sp 0
.RB "type " Regs386
.sp 0
.RB "type " RegsAMD64
.sp 0
.RB "type " Section
.sp 0
.RS
.RB "func (*Section) " Data
.sp 0
.RB "func (*Section) " Open
.sp 0
.RE
.RB "type " Section32
.sp 0
.RB "type " Section64
.sp 0
.RB "type " SectionHeader
.sp 0
.RB "type " Segment
.sp 0
.RS
.RB "func (*Segment) " Data
.sp 0
.RB "func (*Segment) " Open
.sp 0
.RB "func (Segment) " Raw
.sp 0
.RE
.RB "type " Segment32
.sp 0
.RB "type " Segment64
.sp 0
.RB "type " SegmentHeader
.sp 0
.RB "type " Symbol
.sp 0
.RB "type " Symtab
.sp 0
.RS
.RB "func (Symtab) " Raw
.sp 0
.RE
.RB "type " SymtabCmd
.sp 0
.RB "type " Thread
.sp 0
.RB "type " Type
.sp 0
.SH "CONSTANTS"
.PP
.B const (
.RS
.B Magic32 
.sp 0
.B Magic64 
.sp 0
.B MagicFat 
.sp 0
.RE
.B )
.SH "VARIABLES"
ErrNotFat is returned from NewFatFile or OpenFat when the file is not a universal binary but may be a thin binary, based on its magic number. 
.PP
.B var 
.B ErrNotFat 
.sp 0
.SH "TYPES"
.SS "Cpu"
.B type Cpu uint32
.PP
A Cpu is a Mach\-O cpu type. 
.PP
.B const (
.RS
.B Cpu386 
.sp 0
.B CpuAmd64 
.sp 0
.B CpuArm 
.sp 0
.B CpuPpc 
.sp 0
.B CpuPpc64 
.sp 0
.RE
.B )
.PP
.BR "func (Cpu) GoString() string"
.PP
.BR "func (Cpu) String() string"
.SS "Dylib"
.B type Dylib struct {
.RS
.B LoadBytes
.sp 0
.B Name string
.sp 0
.B Time uint32
.sp 0
.B CurrentVersion uint32
.sp 0
.B CompatVersion uint32
.RE
.B }
.PP
A Dylib represents a Mach\-O load dynamic library command. 
.PP
.BR "func (Dylib) Raw() []byte"
.SS "DylibCmd"
.B type DylibCmd struct {
.RS
.B Cmd LoadCmd
.sp 0
.B Len uint32
.sp 0
.B Name uint32
.sp 0
.B Time uint32
.sp 0
.B CurrentVersion uint32
.sp 0
.B CompatVersion uint32
.RE
.B }
.PP
A DylibCmd is a Mach\-O load dynamic library command. 
.SS "Dysymtab"
.B type Dysymtab struct {
.RS
.B LoadBytes
.sp 0
.B DysymtabCmd
.sp 0
.B IndirectSyms []uint32
.RE
.B }
.PP
A Dysymtab represents a Mach\-O dynamic symbol table command. 
.PP
.BR "func (Dysymtab) Raw() []byte"
.SS "DysymtabCmd"
.B type DysymtabCmd struct {
.RS
.B Cmd LoadCmd
.sp 0
.B Len uint32
.sp 0
.B Ilocalsym uint32
.sp 0
.B Nlocalsym uint32
.sp 0
.B Iextdefsym uint32
.sp 0
.B Nextdefsym uint32
.sp 0
.B Iundefsym uint32
.sp 0
.B Nundefsym uint32
.sp 0
.B Tocoffset uint32
.sp 0
.B Ntoc uint32
.sp 0
.B Modtaboff uint32
.sp 0
.B Nmodtab uint32
.sp 0
.B Extrefsymoff uint32
.sp 0
.B Nextrefsyms uint32
.sp 0
.B Indirectsymoff uint32
.sp 0
.B Nindirectsyms uint32
.sp 0
.B Extreloff uint32
.sp 0
.B Nextrel uint32
.sp 0
.B Locreloff uint32
.sp 0
.B Nlocrel uint32
.RE
.B }
.PP
A DysymtabCmd is a Mach\-O dynamic symbol table command. 
.SS "FatArch"
.B type FatArch struct {
.RS
.B FatArchHeader
.sp 0
.B *File
.RE
.B }
.PP
A FatArch is a Mach\-O File inside a FatFile. 
.PP
.BR "func (FatArch) Close() error"
.PP
Close closes the File. 
If the File was created using NewFile directly instead of Open, Close has no effect. 
.PP
.BR "func (FatArch) DWARF() (*dwarf.Data, error)"
.PP
DWARF returns the DWARF debug information for the Mach\-O file. 
.PP
.BR "func (FatArch) ImportedLibraries() ([]string, error)"
.PP
ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. 
.PP
.BR "func (FatArch) ImportedSymbols() ([]string, error)"
.PP
ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. 
.PP
.BR "func (FatArch) Section(" "name" " string) *Section"
.PP
Section returns the first section with the given name, or nil if no such section exists. 
.PP
.BR "func (FatArch) Segment(" "name" " string) *Segment"
.PP
Segment returns the first Segment with the given name, or nil if no such segment exists. 
.SS "FatArchHeader"
.B type FatArchHeader struct {
.RS
.B Cpu Cpu
.sp 0
.B SubCpu uint32
.sp 0
.B Offset uint32
.sp 0
.B Size uint32
.sp 0
.B Align uint32
.RE
.B }
.PP
A FatArchHeader represents a fat header for a specific image architecture. 
.SS "FatFile"
.B type FatFile struct {
.RS
.B Magic uint32
.sp 0
.B Arches []FatArch
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A FatFile is a Mach\-O universal binary that contains at least one architecture. 
.PP
.BR "func NewFatFile(" "r" " io.ReaderAt) (*FatFile, error)"
.PP
NewFatFile creates a new FatFile for accessing all the Mach\-O images in a universal binary. 
The Mach\-O binary is expected to start at position 0 in the ReaderAt. 
.PP
.BR "func OpenFat(" "name" " string) (" "ff" " *FatFile, " "err" " error)"
.PP
OpenFat opens the named file using os.Open and prepares it for use as a Mach\-O universal binary. 
.PP
.BR "func (*FatFile) Close() error"
.SS "File"
.B type File struct {
.RS
.B FileHeader
.sp 0
.B ByteOrder binary.ByteOrder
.sp 0
.B Loads []Load
.sp 0
.B Sections []*Section
.sp 0
.B Symtab *Symtab
.sp 0
.B Dysymtab *Dysymtab
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A File represents an open Mach\-O file. 
.PP
.BR "func NewFile(" "r" " io.ReaderAt) (*File, error)"
.PP
NewFile creates a new File for accessing a Mach\-O binary in an underlying reader. 
The Mach\-O binary is expected to start at position 0 in the ReaderAt. 
.PP
.BR "func Open(" "name" " string) (*File, error)"
.PP
Open opens the named file using os.Open and prepares it for use as a Mach\-O binary. 
.PP
.BR "func (*File) Close() error"
.PP
Close closes the File. 
If the File was created using NewFile directly instead of Open, Close has no effect. 
.PP
.BR "func (*File) DWARF() (*dwarf.Data, error)"
.PP
DWARF returns the DWARF debug information for the Mach\-O file. 
.PP
.BR "func (*File) ImportedLibraries() ([]string, error)"
.PP
ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. 
.PP
.BR "func (*File) ImportedSymbols() ([]string, error)"
.PP
ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. 
.PP
.BR "func (*File) Section(" "name" " string) *Section"
.PP
Section returns the first section with the given name, or nil if no such section exists. 
.PP
.BR "func (*File) Segment(" "name" " string) *Segment"
.PP
Segment returns the first Segment with the given name, or nil if no such segment exists. 
.SS "FileHeader"
.B type FileHeader struct {
.RS
.B Magic uint32
.sp 0
.B Cpu Cpu
.sp 0
.B SubCpu uint32
.sp 0
.B Type Type
.sp 0
.B Ncmd uint32
.sp 0
.B Cmdsz uint32
.sp 0
.B Flags uint32
.RE
.B }
.PP
A FileHeader represents a Mach\-O file header. 
.SS "FormatError"
.B type FormatError struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
FormatError is returned by some operations if the data does not have the correct format for an object file. 
.PP
.BR "func (*FormatError) Error() string"
.SS "Load"
.B type Load interface {
.RS
.B Raw() []byte
.sp 0
.RE
.B }
.PP
A Load represents any Mach\-O load command. 
.SS "LoadBytes"
.B type LoadBytes []byte
.PP
A LoadBytes is the uninterpreted bytes of a Mach\-O load command. 
.PP
.BR "func (LoadBytes) Raw() []byte"
.SS "LoadCmd"
.B type LoadCmd uint32
.PP
A LoadCmd is a Mach\-O load command. 
.PP
.B const (
.RS
.B LoadCmdSegment 
.sp 0
.B LoadCmdSymtab 
.sp 0
.B LoadCmdThread 
.sp 0
.B LoadCmdUnixThread 
.sp 0
.B LoadCmdDysymtab 
.sp 0
.B LoadCmdDylib 
.sp 0
.B LoadCmdDylinker 
.sp 0
.B LoadCmdSegment64 
.sp 0
.RE
.B )
.PP
.BR "func (LoadCmd) GoString() string"
.PP
.BR "func (LoadCmd) String() string"
.SS "Nlist32"
.B type Nlist32 struct {
.RS
.B Name uint32
.sp 0
.B Type uint8
.sp 0
.B Sect uint8
.sp 0
.B Desc uint16
.sp 0
.B Value uint32
.RE
.B }
.PP
An Nlist32 is a Mach\-O 32\-bit symbol table entry. 
.SS "Nlist64"
.B type Nlist64 struct {
.RS
.B Name uint32
.sp 0
.B Type uint8
.sp 0
.B Sect uint8
.sp 0
.B Desc uint16
.sp 0
.B Value uint64
.RE
.B }
.PP
An Nlist64 is a Mach\-O 64\-bit symbol table entry. 
.SS "Regs386"
.B type Regs386 struct {
.RS
.B AX uint32
.sp 0
.B BX uint32
.sp 0
.B CX uint32
.sp 0
.B DX uint32
.sp 0
.B DI uint32
.sp 0
.B SI uint32
.sp 0
.B BP uint32
.sp 0
.B SP uint32
.sp 0
.B SS uint32
.sp 0
.B FLAGS uint32
.sp 0
.B IP uint32
.sp 0
.B CS uint32
.sp 0
.B DS uint32
.sp 0
.B ES uint32
.sp 0
.B FS uint32
.sp 0
.B GS uint32
.RE
.B }
.PP
Regs386 is the Mach\-O 386 register structure. 
.SS "RegsAMD64"
.B type RegsAMD64 struct {
.RS
.B AX uint64
.sp 0
.B BX uint64
.sp 0
.B CX uint64
.sp 0
.B DX uint64
.sp 0
.B DI uint64
.sp 0
.B SI uint64
.sp 0
.B BP uint64
.sp 0
.B SP uint64
.sp 0
.B R8 uint64
.sp 0
.B R9 uint64
.sp 0
.B R10 uint64
.sp 0
.B R11 uint64
.sp 0
.B R12 uint64
.sp 0
.B R13 uint64
.sp 0
.B R14 uint64
.sp 0
.B R15 uint64
.sp 0
.B IP uint64
.sp 0
.B FLAGS uint64
.sp 0
.B CS uint64
.sp 0
.B FS uint64
.sp 0
.B GS uint64
.RE
.B }
.PP
RegsAMD64 is the Mach\-O AMD64 register structure. 
.SS "Section"
.B type Section struct {
.RS
.B SectionHeader
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*Section) Data() ([]byte, error)"
.PP
Data reads and returns the contents of the Mach\-O section. 
.PP
.BR "func (*Section) Open() io.ReadSeeker"
.PP
Open returns a new ReadSeeker reading the Mach\-O section. 
.SS "Section32"
.B type Section32 struct {
.RS
.B Name []byte
.sp 0
.B Seg []byte
.sp 0
.B Addr uint32
.sp 0
.B Size uint32
.sp 0
.B Offset uint32
.sp 0
.B Align uint32
.sp 0
.B Reloff uint32
.sp 0
.B Nreloc uint32
.sp 0
.B Flags uint32
.sp 0
.B Reserve1 uint32
.sp 0
.B Reserve2 uint32
.RE
.B }
.PP
A Section32 is a 32\-bit Mach\-O section header. 
.SS "Section64"
.B type Section64 struct {
.RS
.B Name []byte
.sp 0
.B Seg []byte
.sp 0
.B Addr uint64
.sp 0
.B Size uint64
.sp 0
.B Offset uint32
.sp 0
.B Align uint32
.sp 0
.B Reloff uint32
.sp 0
.B Nreloc uint32
.sp 0
.B Flags uint32
.sp 0
.B Reserve1 uint32
.sp 0
.B Reserve2 uint32
.sp 0
.B Reserve3 uint32
.RE
.B }
.PP
A Section32 is a 64\-bit Mach\-O section header. 
.SS "SectionHeader"
.B type SectionHeader struct {
.RS
.B Name string
.sp 0
.B Seg string
.sp 0
.B Addr uint64
.sp 0
.B Size uint64
.sp 0
.B Offset uint32
.sp 0
.B Align uint32
.sp 0
.B Reloff uint32
.sp 0
.B Nreloc uint32
.sp 0
.B Flags uint32
.RE
.B }
.SS "Segment"
.B type Segment struct {
.RS
.B LoadBytes
.sp 0
.B SegmentHeader
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Segment represents a Mach\-O 32\-bit or 64\-bit load segment command. 
.PP
.BR "func (*Segment) Data() ([]byte, error)"
.PP
Data reads and returns the contents of the segment. 
.PP
.BR "func (*Segment) Open() io.ReadSeeker"
.PP
Open returns a new ReadSeeker reading the segment. 
.PP
.BR "func (Segment) Raw() []byte"
.SS "Segment32"
.B type Segment32 struct {
.RS
.B Cmd LoadCmd
.sp 0
.B Len uint32
.sp 0
.B Name []byte
.sp 0
.B Addr uint32
.sp 0
.B Memsz uint32
.sp 0
.B Offset uint32
.sp 0
.B Filesz uint32
.sp 0
.B Maxprot uint32
.sp 0
.B Prot uint32
.sp 0
.B Nsect uint32
.sp 0
.B Flag uint32
.RE
.B }
.PP
A Segment32 is a 32\-bit Mach\-O segment load command. 
.SS "Segment64"
.B type Segment64 struct {
.RS
.B Cmd LoadCmd
.sp 0
.B Len uint32
.sp 0
.B Name []byte
.sp 0
.B Addr uint64
.sp 0
.B Memsz uint64
.sp 0
.B Offset uint64
.sp 0
.B Filesz uint64
.sp 0
.B Maxprot uint32
.sp 0
.B Prot uint32
.sp 0
.B Nsect uint32
.sp 0
.B Flag uint32
.RE
.B }
.PP
A Segment64 is a 64\-bit Mach\-O segment load command. 
.SS "SegmentHeader"
.B type SegmentHeader struct {
.RS
.B Cmd LoadCmd
.sp 0
.B Len uint32
.sp 0
.B Name string
.sp 0
.B Addr uint64
.sp 0
.B Memsz uint64
.sp 0
.B Offset uint64
.sp 0
.B Filesz uint64
.sp 0
.B Maxprot uint32
.sp 0
.B Prot uint32
.sp 0
.B Nsect uint32
.sp 0
.B Flag uint32
.RE
.B }
.PP
A SegmentHeader is the header for a Mach\-O 32\-bit or 64\-bit load segment command. 
.SS "Symbol"
.B type Symbol struct {
.RS
.B Name string
.sp 0
.B Type uint8
.sp 0
.B Sect uint8
.sp 0
.B Desc uint16
.sp 0
.B Value uint64
.RE
.B }
.PP
A Symbol is a Mach\-O 32\-bit or 64\-bit symbol table entry. 
.SS "Symtab"
.B type Symtab struct {
.RS
.B LoadBytes
.sp 0
.B SymtabCmd
.sp 0
.B Syms []Symbol
.RE
.B }
.PP
A Symtab represents a Mach\-O symbol table command. 
.PP
.BR "func (Symtab) Raw() []byte"
.SS "SymtabCmd"
.B type SymtabCmd struct {
.RS
.B Cmd LoadCmd
.sp 0
.B Len uint32
.sp 0
.B Symoff uint32
.sp 0
.B Nsyms uint32
.sp 0
.B Stroff uint32
.sp 0
.B Strsize uint32
.RE
.B }
.PP
A SymtabCmd is a Mach\-O symbol table command. 
.SS "Thread"
.B type Thread struct {
.RS
.B Cmd LoadCmd
.sp 0
.B Len uint32
.sp 0
.B Type uint32
.sp 0
.B Data []uint32
.RE
.B }
.PP
A Thread is a Mach\-O thread state command. 
.SS "Type"
.B type Type uint32
.PP
A Type is the Mach\-O file type, e.g. 
an object file, executable, or dynamic library. 
.PP
.B const (
.RS
.B TypeObj 
.sp 0
.B TypeExec 
.sp 0
.B TypeDylib 
.sp 0
.B TypeBundle 
.sp 0
.RE
.B )
