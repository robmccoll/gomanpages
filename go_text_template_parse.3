.\"    Automatically generated by mango(1)
.TH "parse" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
parse \- Package parse builds parse trees for templates as defined by text/template
and html/template.
.SH "SYNOPSIS"
.B import \*(lqparse\(rq
.sp
.RB "func " IsEmptyTree
.sp 0
.RB "func " Parse
.sp 0
.RB "type " ActionNode
.sp 0
.RS
.RB "func (*ActionNode) " Copy
.sp 0
.RB "func (ActionNode) " Position
.sp 0
.RB "func (*ActionNode) " String
.sp 0
.RB "func (ActionNode) " Type
.sp 0
.RE
.RB "type " BoolNode
.sp 0
.RS
.RB "func (*BoolNode) " Copy
.sp 0
.RB "func (BoolNode) " Position
.sp 0
.RB "func (*BoolNode) " String
.sp 0
.RB "func (BoolNode) " Type
.sp 0
.RE
.RB "type " BranchNode
.sp 0
.RS
.RB "func (BranchNode) " Position
.sp 0
.RB "func (*BranchNode) " String
.sp 0
.RB "func (BranchNode) " Type
.sp 0
.RE
.RB "type " ChainNode
.sp 0
.RS
.RB "func (*ChainNode) " Add
.sp 0
.RB "func (*ChainNode) " Copy
.sp 0
.RB "func (ChainNode) " Position
.sp 0
.RB "func (*ChainNode) " String
.sp 0
.RB "func (ChainNode) " Type
.sp 0
.RE
.RB "type " CommandNode
.sp 0
.RS
.RB "func (*CommandNode) " Copy
.sp 0
.RB "func (CommandNode) " Position
.sp 0
.RB "func (*CommandNode) " String
.sp 0
.RB "func (CommandNode) " Type
.sp 0
.RE
.RB "type " DotNode
.sp 0
.RS
.RB "func (*DotNode) " Copy
.sp 0
.RB "func (DotNode) " Position
.sp 0
.RB "func (*DotNode) " String
.sp 0
.RB "func (*DotNode) " Type
.sp 0
.RE
.RB "type " FieldNode
.sp 0
.RS
.RB "func (*FieldNode) " Copy
.sp 0
.RB "func (FieldNode) " Position
.sp 0
.RB "func (*FieldNode) " String
.sp 0
.RB "func (FieldNode) " Type
.sp 0
.RE
.RB "type " IdentifierNode
.sp 0
.RS
.RB "func " NewIdentifier
.sp 0
.RB "func (*IdentifierNode) " Copy
.sp 0
.RB "func (IdentifierNode) " Position
.sp 0
.RB "func (*IdentifierNode) " SetPos
.sp 0
.RB "func (*IdentifierNode) " String
.sp 0
.RB "func (IdentifierNode) " Type
.sp 0
.RE
.RB "type " IfNode
.sp 0
.RS
.RB "func (*IfNode) " Copy
.sp 0
.RB "func (IfNode) " Position
.sp 0
.RB "func (*IfNode) " String
.sp 0
.RB "func (IfNode) " Type
.sp 0
.RE
.RB "type " ListNode
.sp 0
.RS
.RB "func (*ListNode) " Copy
.sp 0
.RB "func (*ListNode) " CopyList
.sp 0
.RB "func (ListNode) " Position
.sp 0
.RB "func (*ListNode) " String
.sp 0
.RB "func (ListNode) " Type
.sp 0
.RE
.RB "type " NilNode
.sp 0
.RS
.RB "func (*NilNode) " Copy
.sp 0
.RB "func (NilNode) " Position
.sp 0
.RB "func (*NilNode) " String
.sp 0
.RB "func (*NilNode) " Type
.sp 0
.RE
.RB "type " Node
.sp 0
.RB "type " NodeType
.sp 0
.RS
.RB "func (NodeType) " Type
.sp 0
.RE
.RB "type " NumberNode
.sp 0
.RS
.RB "func (*NumberNode) " Copy
.sp 0
.RB "func (NumberNode) " Position
.sp 0
.RB "func (*NumberNode) " String
.sp 0
.RB "func (NumberNode) " Type
.sp 0
.RE
.RB "type " PipeNode
.sp 0
.RS
.RB "func (*PipeNode) " Copy
.sp 0
.RB "func (*PipeNode) " CopyPipe
.sp 0
.RB "func (PipeNode) " Position
.sp 0
.RB "func (*PipeNode) " String
.sp 0
.RB "func (PipeNode) " Type
.sp 0
.RE
.RB "type " Pos
.sp 0
.RS
.RB "func (Pos) " Position
.sp 0
.RE
.RB "type " RangeNode
.sp 0
.RS
.RB "func (*RangeNode) " Copy
.sp 0
.RB "func (RangeNode) " Position
.sp 0
.RB "func (*RangeNode) " String
.sp 0
.RB "func (RangeNode) " Type
.sp 0
.RE
.RB "type " StringNode
.sp 0
.RS
.RB "func (*StringNode) " Copy
.sp 0
.RB "func (StringNode) " Position
.sp 0
.RB "func (*StringNode) " String
.sp 0
.RB "func (StringNode) " Type
.sp 0
.RE
.RB "type " TemplateNode
.sp 0
.RS
.RB "func (*TemplateNode) " Copy
.sp 0
.RB "func (TemplateNode) " Position
.sp 0
.RB "func (*TemplateNode) " String
.sp 0
.RB "func (TemplateNode) " Type
.sp 0
.RE
.RB "type " TextNode
.sp 0
.RS
.RB "func (*TextNode) " Copy
.sp 0
.RB "func (TextNode) " Position
.sp 0
.RB "func (*TextNode) " String
.sp 0
.RB "func (TextNode) " Type
.sp 0
.RE
.RB "type " Tree
.sp 0
.RS
.RB "func " New
.sp 0
.RB "func (*Tree) " Copy
.sp 0
.RB "func (*Tree) " ErrorContext
.sp 0
.RB "func (*Tree) " Parse
.sp 0
.RE
.RB "type " VariableNode
.sp 0
.RS
.RB "func (*VariableNode) " Copy
.sp 0
.RB "func (VariableNode) " Position
.sp 0
.RB "func (*VariableNode) " String
.sp 0
.RB "func (VariableNode) " Type
.sp 0
.RE
.RB "type " WithNode
.sp 0
.RS
.RB "func (*WithNode) " Copy
.sp 0
.RB "func (WithNode) " Position
.sp 0
.RB "func (*WithNode) " String
.sp 0
.RB "func (WithNode) " Type
.sp 0
.RE
.RB "type " elseNode
.sp 0
.RS
.RB "func (*elseNode) " Copy
.sp 0
.RB "func (elseNode) " Position
.sp 0
.RB "func (*elseNode) " String
.sp 0
.RB "func (*elseNode) " Type
.sp 0
.RE
.RB "type " endNode
.sp 0
.RS
.RB "func (*endNode) " Copy
.sp 0
.RB "func (endNode) " Position
.sp 0
.RB "func (*endNode) " String
.sp 0
.RB "func (*endNode) " Type
.sp 0
.RE
.RB "type " item
.sp 0
.RS
.RB "func (item) " String
.sp 0
.RE
.SH "DESCRIPTION"
Package parse builds parse trees for templates as defined by text/template and html/template. 
Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use. 
.SH "FUNCTIONS"
.PP
.BR "func IsEmptyTree(" "n" " Node) bool"
.PP
IsEmptyTree reports whether this tree (node) is empty of everything but space. 
.PP
.BR "func Parse(" "name" ", " "text" ", " "leftDelim" ", " "rightDelim" " string, " "funcs" " ...map[string]interface{}) (" "treeSet" " map[string]*Tree, " "err" " error)"
.PP
Parse returns a map from template name to parse.Tree, created by parsing the templates described in the argument string. 
The top\-level template will be given the specified name. 
If an error is encountered, parsing stops and an empty map is returned with the error. 
.SH "TYPES"
.SS "ActionNode"
.B type ActionNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Line int
.sp 0
.B Pipe *PipeNode
.RE
.B }
.PP
ActionNode holds an action (something bounded by delimiters). 
Control actions have their own nodes; ActionNode represents simple ones such as field evaluations and parenthesized pipelines. 
.PP
.BR "func (*ActionNode) Copy() Node"
.PP
.BR "func (ActionNode) Position() Pos"
.PP
.BR "func (*ActionNode) String() string"
.PP
.BR "func (ActionNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "BoolNode"
.B type BoolNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B True bool
.RE
.B }
.PP
BoolNode holds a boolean constant. 
.PP
.BR "func (*BoolNode) Copy() Node"
.PP
.BR "func (BoolNode) Position() Pos"
.PP
.BR "func (*BoolNode) String() string"
.PP
.BR "func (BoolNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "BranchNode"
.B type BranchNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Line int
.sp 0
.B Pipe *PipeNode
.sp 0
.B List *ListNode
.sp 0
.B ElseList *ListNode
.RE
.B }
.PP
BranchNode is the common representation of if, range, and with. 
.PP
.BR "func (BranchNode) Position() Pos"
.PP
.BR "func (*BranchNode) String() string"
.PP
.BR "func (BranchNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "ChainNode"
.B type ChainNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Node Node
.sp 0
.B Field []string
.RE
.B }
.PP
ChainNode holds a term followed by a chain of field accesses (identifier starting with \(fm.'). 
The names may be chained ('.x.y'). 
The periods are dropped from each ident. 
.PP
.BR "func (*ChainNode) Add(" "field" " string)"
.PP
Add adds the named field (which should start with a period) to the end of the chain. 
.PP
.BR "func (*ChainNode) Copy() Node"
.PP
.BR "func (ChainNode) Position() Pos"
.PP
.BR "func (*ChainNode) String() string"
.PP
.BR "func (ChainNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "CommandNode"
.B type CommandNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Args []Node
.RE
.B }
.PP
CommandNode holds a command (a pipeline inside an evaluating action). 
.PP
.BR "func (*CommandNode) Copy() Node"
.PP
.BR "func (CommandNode) Position() Pos"
.PP
.BR "func (*CommandNode) String() string"
.PP
.BR "func (CommandNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "DotNode"
.B type DotNode struct {
.RS
.B Pos
.RE
.B }
.PP
DotNode holds the special identifier \(fm.'. 
.PP
.BR "func (*DotNode) Copy() Node"
.PP
.BR "func (DotNode) Position() Pos"
.PP
.BR "func (*DotNode) String() string"
.PP
.BR "func (*DotNode) Type() NodeType"
.SS "FieldNode"
.B type FieldNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Ident []string
.RE
.B }
.PP
FieldNode holds a field (identifier starting with \(fm.'). 
The names may be chained ('.x.y'). 
The period is dropped from each ident. 
.PP
.BR "func (*FieldNode) Copy() Node"
.PP
.BR "func (FieldNode) Position() Pos"
.PP
.BR "func (*FieldNode) String() string"
.PP
.BR "func (FieldNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "IdentifierNode"
.B type IdentifierNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Ident string
.RE
.B }
.PP
IdentifierNode holds an identifier. 
.PP
.BR "func NewIdentifier(" "ident" " string) *IdentifierNode"
.PP
NewIdentifier returns a new IdentifierNode with the given identifier name. 
.PP
.BR "func (*IdentifierNode) Copy() Node"
.PP
.BR "func (IdentifierNode) Position() Pos"
.PP
.BR "func (*IdentifierNode) SetPos(" "pos" " Pos) *IdentifierNode"
.PP
SetPos sets the position. 
NewIdentifier is a public method so we can't modify its signature. 
Chained for convenience. 
TODO: fix one day? 
.PP
.BR "func (*IdentifierNode) String() string"
.PP
.BR "func (IdentifierNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "IfNode"
.B type IfNode struct {
.RS
.B BranchNode
.RE
.B }
.PP
IfNode represents an {{if}} action and its commands. 
.PP
.BR "func (*IfNode) Copy() Node"
.PP
.BR "func (IfNode) Position() Pos"
.PP
.BR "func (*IfNode) String() string"
.PP
.BR "func (IfNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "ListNode"
.B type ListNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Nodes []Node
.RE
.B }
.PP
ListNode holds a sequence of nodes. 
.PP
.BR "func (*ListNode) Copy() Node"
.PP
.BR "func (*ListNode) CopyList() *ListNode"
.PP
.BR "func (ListNode) Position() Pos"
.PP
.BR "func (*ListNode) String() string"
.PP
.BR "func (ListNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "NilNode"
.B type NilNode struct {
.RS
.B Pos
.RE
.B }
.PP
NilNode holds the special identifier \(fmnil' representing an untyped nil constant. 
.PP
.BR "func (*NilNode) Copy() Node"
.PP
.BR "func (NilNode) Position() Pos"
.PP
.BR "func (*NilNode) String() string"
.PP
.BR "func (*NilNode) Type() NodeType"
.SS "Node"
.B type Node interface {
.RS
.B Type() NodeType
.sp 0
.B String() string
.sp 0
.B Copy() Node
.sp 0
.B Position() Pos
.sp 0
.B 
.sp 0
.sp 0
.B //contains unexported methods.
.RE
.B }
.PP
A Node is an element in the parse tree. 
The interface is trivial. 
The interface contains an unexported method so that only types local to this package can satisfy it. 
.SS "NodeType"
.B type NodeType int
.PP
NodeType identifies the type of a parse tree node. 
.PP
.B const (
.RS
.B NodeText 
.sp 0
.B NodeAction 
.sp 0
.B NodeBool 
.sp 0
.B NodeChain 
.sp 0
.B NodeCommand 
.sp 0
.B NodeDot 
.sp 0
.B 
.sp 0
.B 
.sp 0
.B NodeField 
.sp 0
.B NodeIdentifier 
.sp 0
.B NodeIf 
.sp 0
.B NodeList 
.sp 0
.B NodeNil 
.sp 0
.B NodeNumber 
.sp 0
.B NodePipe 
.sp 0
.B NodeRange 
.sp 0
.B NodeString 
.sp 0
.B NodeTemplate 
.sp 0
.B NodeVariable 
.sp 0
.B NodeWith 
.sp 0
.RE
.B )
.PP
.BR "func (NodeType) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "NumberNode"
.B type NumberNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B IsInt bool
.sp 0
.B IsUint bool
.sp 0
.B IsFloat bool
.sp 0
.B IsComplex bool
.sp 0
.B Int64 int64
.sp 0
.B Uint64 uint64
.sp 0
.B Float64 float64
.sp 0
.B Complex128 complex128
.sp 0
.B Text string
.RE
.B }
.PP
NumberNode holds a number: signed or unsigned integer, float, or complex. 
The value is parsed and stored under all the types that can represent the value. 
This simulates in a small amount of code the behavior of Go's ideal constants. 
.PP
.BR "func (*NumberNode) Copy() Node"
.PP
.BR "func (NumberNode) Position() Pos"
.PP
.BR "func (*NumberNode) String() string"
.PP
.BR "func (NumberNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "PipeNode"
.B type PipeNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Line int
.sp 0
.B Decl []*VariableNode
.sp 0
.B Cmds []*CommandNode
.RE
.B }
.PP
PipeNode holds a pipeline with optional declaration    
.PP
.BR "func (*PipeNode) Copy() Node"
.PP
.BR "func (*PipeNode) CopyPipe() *PipeNode"
.PP
.BR "func (PipeNode) Position() Pos"
.PP
.BR "func (*PipeNode) String() string"
.PP
.BR "func (PipeNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "Pos"
.B type Pos int
.PP
Pos represents a byte position in the original input text from which this template was parsed. 
.PP
.BR "func (Pos) Position() Pos"
.SS "RangeNode"
.B type RangeNode struct {
.RS
.B BranchNode
.RE
.B }
.PP
RangeNode represents a {{range}} action and its commands. 
.PP
.BR "func (*RangeNode) Copy() Node"
.PP
.BR "func (RangeNode) Position() Pos"
.PP
.BR "func (*RangeNode) String() string"
.PP
.BR "func (RangeNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "StringNode"
.B type StringNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Quoted string
.sp 0
.B Text string
.RE
.B }
.PP
StringNode holds a string constant. 
The value has been "unquoted". 
.PP
.BR "func (*StringNode) Copy() Node"
.PP
.BR "func (StringNode) Position() Pos"
.PP
.BR "func (*StringNode) String() string"
.PP
.BR "func (StringNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "TemplateNode"
.B type TemplateNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Line int
.sp 0
.B Name string
.sp 0
.B Pipe *PipeNode
.RE
.B }
.PP
TemplateNode represents a {{template}} action. 
.PP
.BR "func (*TemplateNode) Copy() Node"
.PP
.BR "func (TemplateNode) Position() Pos"
.PP
.BR "func (*TemplateNode) String() string"
.PP
.BR "func (TemplateNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "TextNode"
.B type TextNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Text []byte
.RE
.B }
.PP
TextNode holds plain text. 
.PP
.BR "func (*TextNode) Copy() Node"
.PP
.BR "func (TextNode) Position() Pos"
.PP
.BR "func (*TextNode) String() string"
.PP
.BR "func (TextNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "Tree"
.B type Tree struct {
.RS
.B Name string
.sp 0
.B ParseName string
.sp 0
.B Root *ListNode
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Tree is the representation of a single parsed template. 
.PP
.BR "func New(" "name" " string, " "funcs" " ...map[string]interface{}) *Tree"
.PP
New allocates a new parse tree with the given name. 
.PP
.BR "func (*Tree) Copy() *Tree"
.PP
Copy returns a copy of the Tree. 
Any parsing state is discarded. 
.PP
.BR "func (*Tree) ErrorContext(" "n" " Node) (" "location" ", " "context" " string)"
.PP
ErrorContext returns a textual representation of the location of the node in the input text. 
.PP
.BR "func (*Tree) Parse(" "text" ", " "leftDelim" ", " "rightDelim" " string, " "treeSet" " map[string]*Tree, " "funcs" " ...map[string]interface{}) (" "tree" " *Tree, " "err" " error)"
.PP
Parse parses the template definition string to construct a representation of the template for execution. 
If either action delimiter string is empty, the default ("{{" or "}}") is used. 
Embedded template definitions are added to the treeSet map. 
.SS "VariableNode"
.B type VariableNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Ident []string
.RE
.B }
.PP
VariableNode holds a list of variable names, possibly with chained field accesses. 
The dollar sign is part of the (first) name. 
.PP
.BR "func (*VariableNode) Copy() Node"
.PP
.BR "func (VariableNode) Position() Pos"
.PP
.BR "func (*VariableNode) String() string"
.PP
.BR "func (VariableNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "WithNode"
.B type WithNode struct {
.RS
.B BranchNode
.RE
.B }
.PP
WithNode represents a {{with}} action and its commands. 
.PP
.BR "func (*WithNode) Copy() Node"
.PP
.BR "func (WithNode) Position() Pos"
.PP
.BR "func (*WithNode) String() string"
.PP
.BR "func (WithNode) Type() NodeType"
.PP
Type returns itself and provides an easy default implementation for embedding in a Node. 
Embedded in all non\-trivial Nodes. 
.SS "elseNode"
.B type elseNode struct {
.RS
.B NodeType
.sp 0
.B Pos
.sp 0
.B Line int
.RE
.B }
.PP
elseNode represents an {{else}} action. 
Does not appear in the final tree. 
.PP
.BR "func (*elseNode) Copy() Node"
.PP
.BR "func (elseNode) Position() Pos"
.PP
.BR "func (*elseNode) String() string"
.PP
.BR "func (*elseNode) Type() NodeType"
.SS "endNode"
.B type endNode struct {
.RS
.B Pos
.RE
.B }
.PP
endNode represents an {{end}} action. 
It does not appear in the final parse tree. 
.PP
.BR "func (*endNode) Copy() Node"
.PP
.BR "func (endNode) Position() Pos"
.PP
.BR "func (*endNode) String() string"
.PP
.BR "func (*endNode) Type() NodeType"
.SS "item"
.B type item struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
item represents a token or text string returned from the scanner. 
.PP
.BR "func (item) String() string"
