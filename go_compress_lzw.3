.\"    Automatically generated by mango(1)
.TH "lzw" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
lzw \- Package lzw implements the Lempel-Ziv-Welch compressed data format,
described in T.
.SH "SYNOPSIS"
.B import \*(lqlzw\(rq
.sp
.RB "func " NewReader
.sp 0
.RB "func " NewWriter
.sp 0
.RB "type " Order
.sp 0
.RB "type " decoder
.sp 0
.RS
.RB "func (*decoder) " Close
.sp 0
.RB "func (*decoder) " Read
.sp 0
.RE
.RB "type " encoder
.sp 0
.RS
.RB "func (*encoder) " Close
.sp 0
.RB "func (*encoder) " Write
.sp 0
.RE
.RB "type " errWriteCloser
.sp 0
.RS
.RB "func (*errWriteCloser) " Close
.sp 0
.RB "func (*errWriteCloser) " Write
.sp 0
.RE
.RB "type " writer
.sp 0
.SH "DESCRIPTION"
Package lzw implements the Lempel\-Ziv\-Welch compressed data format, described in T. 
A. 
Welch, ``A Technique for High\-Performance Data Compression'', Computer, 
.BR 17 (6)
(June 1984), pp 8\-19. 
.PP
In particular, it implements LZW as used by the GIF, TIFF and PDF file formats, which means variable\-width codes up to 12 bits and the first two non\-literal codes are a clear code and an EOF code. 
.SH "FUNCTIONS"
.PP
.BR "func NewReader(" "r" " io.Reader, " "order" " Order, " "litWidth" " int) io.ReadCloser"
.PP
NewReader creates a new io.ReadCloser. 
Reads from the returned io.ReadCloser read and decompress data from r. 
It is the caller's responsibility to call Close on the ReadCloser when finished reading. 
The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. 
.PP
.BR "func NewWriter(" "w" " io.Writer, " "order" " Order, " "litWidth" " int) io.WriteCloser"
.PP
NewWriter creates a new io.WriteCloser. 
Writes to the returned io.WriteCloser are compressed and written to w. 
It is the caller's responsibility to call Close on the WriteCloser when finished writing. 
The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. 
.SH "TYPES"
.SS "Order"
.B type Order int
.PP
Order specifies the bit ordering in an LZW data stream. 
.PP
.B const (
.RS
.B LSB 
.sp 0
.B MSB 
.sp 0
.RE
.B )
.SS "decoder"
.B type decoder struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
decoder is the state from which the readXxx method converts a byte stream into a code stream. 
.PP
.BR "func (*decoder) Close() error"
.PP
.BR "func (*decoder) Read(" "b" " []byte) (int, error)"
.SS "encoder"
.B type encoder struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
encoder is LZW compressor. 
.PP
.BR "func (*encoder) Close() error"
.PP
Close closes the encoder, flushing any pending output. 
It does not close or flush e's underlying writer. 
.PP
.BR "func (*encoder) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
.PP
Write writes a compressed representation of p to e's underlying writer. 
.SS "errWriteCloser"
.B type errWriteCloser struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
An errWriteCloser is an io.WriteCloser that always returns a given error. 
.PP
.BR "func (*errWriteCloser) Close() error"
.PP
.BR "func (*errWriteCloser) Write([]byte) (int, error)"
.SS "writer"
.B type writer interface {
.RS
.B io.ByteWriter
.sp 0
.B Flush() error
.sp 0
.RE
.B }
.PP
A writer is a buffered, flushable writer. 
