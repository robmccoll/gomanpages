.\"    Automatically generated by mango(1)
.TH "http" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
http \- Package http provides HTTP client and server implementations.
.SH "SYNOPSIS"
.B import \*(lqhttp\(rq
.sp
.B Constants
.sp 0
.B Variables
.sp 0
.RB "func " CanonicalHeaderKey
.sp 0
.RB "func " DetectContentType
.sp 0
.RB "func " Error
.sp 0
.RB "func " Handle
.sp 0
.RB "func " HandleFunc
.sp 0
.RB "func " ListenAndServe
.sp 0
.RB "func " ListenAndServeTLS
.sp 0
.RB "func " MaxBytesReader
.sp 0
.RB "func " NotFound
.sp 0
.RB "func " ParseHTTPVersion
.sp 0
.RB "func " ParseTime
.sp 0
.RB "func " ProxyFromEnvironment
.sp 0
.RB "func " ProxyURL
.sp 0
.RB "func " Redirect
.sp 0
.RB "func " Serve
.sp 0
.RB "func " ServeContent
.sp 0
.RB "func " ServeFile
.sp 0
.RB "func " SetCookie
.sp 0
.RB "func " StatusText
.sp 0
.RB "type " Client
.sp 0
.RS
.RB "func (*Client) " Do
.sp 0
.RB "func (*Client) " Get
.sp 0
.RB "func (*Client) " Head
.sp 0
.RB "func (*Client) " Post
.sp 0
.RB "func (*Client) " PostForm
.sp 0
.RE
.RB "type " CloseNotifier
.sp 0
.RB "type " ConnState
.sp 0
.RS
.RB "func (ConnState) " String
.sp 0
.RE
.RB "type " Cookie
.sp 0
.RS
.RB "func (*Cookie) " String
.sp 0
.RE
.RB "type " CookieJar
.sp 0
.RB "type " Dir
.sp 0
.RS
.RB "func (Dir) " Open
.sp 0
.RE
.RB "type " File
.sp 0
.RB "type " FileSystem
.sp 0
.RB "type " Flusher
.sp 0
.RB "type " Handler
.sp 0
.RS
.RB "func " FileServer
.sp 0
.RB "func " NotFoundHandler
.sp 0
.RB "func " RedirectHandler
.sp 0
.RB "func " StripPrefix
.sp 0
.RB "func " TimeoutHandler
.sp 0
.RE
.RB "type " HandlerFunc
.sp 0
.RS
.RB "func (HandlerFunc) " ServeHTTP
.sp 0
.RE
.RB "type " Header
.sp 0
.RS
.RB "func (Header) " Add
.sp 0
.RB "func (Header) " Del
.sp 0
.RB "func (Header) " Get
.sp 0
.RB "func (Header) " Set
.sp 0
.RB "func (Header) " Write
.sp 0
.RB "func (Header) " WriteSubset
.sp 0
.RE
.RB "type " Hijacker
.sp 0
.RB "type " ProtocolError
.sp 0
.RS
.RB "func (*ProtocolError) " Error
.sp 0
.RE
.RB "type " Request
.sp 0
.RS
.RB "func " NewRequest
.sp 0
.RB "func " ReadRequest
.sp 0
.RB "func (*Request) " AddCookie
.sp 0
.RB "func (*Request) " Cookie
.sp 0
.RB "func (*Request) " Cookies
.sp 0
.RB "func (*Request) " FormFile
.sp 0
.RB "func (*Request) " FormValue
.sp 0
.RB "func (*Request) " MultipartReader
.sp 0
.RB "func (*Request) " ParseForm
.sp 0
.RB "func (*Request) " ParseMultipartForm
.sp 0
.RB "func (*Request) " PostFormValue
.sp 0
.RB "func (*Request) " ProtoAtLeast
.sp 0
.RB "func (*Request) " Referer
.sp 0
.RB "func (*Request) " SetBasicAuth
.sp 0
.RB "func (*Request) " UserAgent
.sp 0
.RB "func (*Request) " Write
.sp 0
.RB "func (*Request) " WriteProxy
.sp 0
.RE
.RB "type " Response
.sp 0
.RS
.RB "func " Get
.sp 0
.RB "func " Head
.sp 0
.RB "func " Post
.sp 0
.RB "func " PostForm
.sp 0
.RB "func " ReadResponse
.sp 0
.RB "func (*Response) " Cookies
.sp 0
.RB "func (*Response) " Location
.sp 0
.RB "func (*Response) " ProtoAtLeast
.sp 0
.RB "func (*Response) " Write
.sp 0
.RE
.RB "type " ResponseWriter
.sp 0
.RB "type " RoundTripper
.sp 0
.RS
.RB "func " NewFileTransport
.sp 0
.RE
.RB "type " ServeMux
.sp 0
.RS
.RB "func " NewServeMux
.sp 0
.RB "func (*ServeMux) " Handle
.sp 0
.RB "func (*ServeMux) " HandleFunc
.sp 0
.RB "func (*ServeMux) " Handler
.sp 0
.RB "func (*ServeMux) " ServeHTTP
.sp 0
.RE
.RB "type " Server
.sp 0
.RS
.RB "func (*Server) " ListenAndServe
.sp 0
.RB "func (*Server) " ListenAndServeTLS
.sp 0
.RB "func (*Server) " Serve
.sp 0
.RB "func (*Server) " SetKeepAlivesEnabled
.sp 0
.RE
.RB "type " Transport
.sp 0
.RS
.RB "func (*Transport) " CancelRequest
.sp 0
.RB "func (*Transport) " CloseIdleConnections
.sp 0
.RB "func (*Transport) " RegisterProtocol
.sp 0
.RB "func (*Transport) " RoundTrip
.sp 0
.RE
.RB "type " badStringError
.sp 0
.RS
.RB "func (*badStringError) " Error
.sp 0
.RE
.RB "type " body
.sp 0
.RS
.RB "func (*body) " Close
.sp 0
.RB "func (*body) " Read
.sp 0
.RE
.RB "type " bodyEOFSignal
.sp 0
.RS
.RB "func (*bodyEOFSignal) " Close
.sp 0
.RB "func (*bodyEOFSignal) " Read
.sp 0
.RE
.RB "type " bodyLocked
.sp 0
.RS
.RB "func (bodyLocked) " Read
.sp 0
.RE
.RB "type " cancelTimerBody
.sp 0
.RS
.RB "func (*cancelTimerBody) " Close
.sp 0
.RB "func (*cancelTimerBody) " Read
.sp 0
.RE
.RB "type " chunkWriter
.sp 0
.RS
.RB "func (*chunkWriter) " Write
.sp 0
.RE
.RB "type " chunkedReader
.sp 0
.RS
.RB "func (*chunkedReader) " Read
.sp 0
.RE
.RB "type " chunkedWriter
.sp 0
.RS
.RB "func (*chunkedWriter) " Close
.sp 0
.RB "func (*chunkedWriter) " Write
.sp 0
.RE
.RB "type " connectMethodKey
.sp 0
.RS
.RB "func (connectMethodKey) " String
.sp 0
.RE
.RB "type " countingWriter
.sp 0
.RS
.RB "func (*countingWriter) " Write
.sp 0
.RE
.RB "type " envOnce
.sp 0
.RS
.RB "func (*envOnce) " Get
.sp 0
.RE
.RB "type " eofReaderWithWriteTo
.sp 0
.RS
.RB "func (eofReaderWithWriteTo) " Read
.sp 0
.RB "func (eofReaderWithWriteTo) " WriteTo
.sp 0
.RE
.RB "type " errorReader
.sp 0
.RS
.RB "func (*errorReader) " Read
.sp 0
.RE
.RB "type " expectContinueReader
.sp 0
.RS
.RB "func (*expectContinueReader) " Close
.sp 0
.RB "func (*expectContinueReader) " Read
.sp 0
.RE
.RB "type " extraHeader
.sp 0
.RS
.RB "func (extraHeader) " Write
.sp 0
.RE
.RB "type " fileHandler
.sp 0
.RS
.RB "func (*fileHandler) " ServeHTTP
.sp 0
.RE
.RB "type " fileTransport
.sp 0
.RS
.RB "func (fileTransport) " RoundTrip
.sp 0
.RE
.RB "type " globalOptionsHandler
.sp 0
.RS
.RB "func (globalOptionsHandler) " ServeHTTP
.sp 0
.RE
.RB "type " gzipReader
.sp 0
.RS
.RB "func (*gzipReader) " Close
.sp 0
.RB "func (*gzipReader) " Read
.sp 0
.RE
.RB "type " headerSorter
.sp 0
.RS
.RB "func (*headerSorter) " Len
.sp 0
.RB "func (*headerSorter) " Less
.sp 0
.RB "func (*headerSorter) " Swap
.sp 0
.RE
.RB "type " httpError
.sp 0
.RS
.RB "func (*httpError) " Error
.sp 0
.RB "func (*httpError) " Temporary
.sp 0
.RB "func (*httpError) " Timeout
.sp 0
.RE
.RB "type " initNPNRequest
.sp 0
.RS
.RB "func (initNPNRequest) " ServeHTTP
.sp 0
.RE
.RB "type " liveSwitchReader
.sp 0
.RS
.RB "func (*liveSwitchReader) " Read
.sp 0
.RE
.RB "type " loggingConn
.sp 0
.RS
.RB "func (*loggingConn) " Close
.sp 0
.RB "func (*loggingConn) " Read
.sp 0
.RB "func (*loggingConn) " Write
.sp 0
.RE
.RB "type " maxBytesReader
.sp 0
.RS
.RB "func (*maxBytesReader) " Close
.sp 0
.RB "func (*maxBytesReader) " Read
.sp 0
.RE
.RB "type " noteEOFReader
.sp 0
.RS
.RB "func (noteEOFReader) " Read
.sp 0
.RE
.RB "type " populateResponse
.sp 0
.RS
.RB "func (*populateResponse) " Header
.sp 0
.RB "func (*populateResponse) " Write
.sp 0
.RB "func (*populateResponse) " WriteHeader
.sp 0
.RE
.RB "type " redirectHandler
.sp 0
.RS
.RB "func (*redirectHandler) " ServeHTTP
.sp 0
.RE
.RB "type " response
.sp 0
.RS
.RB "func (*response) " CloseNotify
.sp 0
.RB "func (*response) " Flush
.sp 0
.RB "func (*response) " Header
.sp 0
.RB "func (*response) " Hijack
.sp 0
.RB "func (*response) " ReadFrom
.sp 0
.RB "func (*response) " Write
.sp 0
.RB "func (*response) " WriteHeader
.sp 0
.RB "func (*response) " WriteString
.sp 0
.RE
.RB "type " serverHandler
.sp 0
.RS
.RB "func (serverHandler) " ServeHTTP
.sp 0
.RE
.RB "type " stringWriter
.sp 0
.RS
.RB "func (stringWriter) " WriteString
.sp 0
.RE
.RB "type " tcpKeepAliveListener
.sp 0
.RS
.RB "func (tcpKeepAliveListener) " Accept
.sp 0
.RE
.RB "type " timeoutHandler
.sp 0
.RS
.RB "func (*timeoutHandler) " ServeHTTP
.sp 0
.RE
.RB "type " timeoutWriter
.sp 0
.RS
.RB "func (*timeoutWriter) " Header
.sp 0
.RB "func (*timeoutWriter) " Write
.sp 0
.RB "func (*timeoutWriter) " WriteHeader
.sp 0
.RE
.RB "type " tlsHandshakeTimeoutError
.sp 0
.RS
.RB "func (tlsHandshakeTimeoutError) " Error
.sp 0
.RB "func (tlsHandshakeTimeoutError) " Temporary
.sp 0
.RB "func (tlsHandshakeTimeoutError) " Timeout
.sp 0
.RE
.RB "type " transferReader
.sp 0
.RB "type " transferWriter
.sp 0
.RS
.RB "func (*transferWriter) " WriteBody
.sp 0
.RB "func (*transferWriter) " WriteHeader
.sp 0
.RE
.RB "type " transportRequest
.sp 0
.RS
.RB "func (transportRequest) " AddCookie
.sp 0
.RB "func (transportRequest) " Cookie
.sp 0
.RB "func (transportRequest) " Cookies
.sp 0
.RB "func (transportRequest) " FormFile
.sp 0
.RB "func (transportRequest) " FormValue
.sp 0
.RB "func (transportRequest) " MultipartReader
.sp 0
.RB "func (transportRequest) " ParseForm
.sp 0
.RB "func (transportRequest) " ParseMultipartForm
.sp 0
.RB "func (transportRequest) " PostFormValue
.sp 0
.RB "func (transportRequest) " ProtoAtLeast
.sp 0
.RB "func (transportRequest) " Referer
.sp 0
.RB "func (transportRequest) " SetBasicAuth
.sp 0
.RB "func (transportRequest) " UserAgent
.sp 0
.RB "func (transportRequest) " Write
.sp 0
.RB "func (transportRequest) " WriteProxy
.sp 0
.RE
.RB "type " writeStringer
.sp 0
.SH "DESCRIPTION"
Get, Head, Post, and PostForm make HTTP (or HTTPS) requests:    
.PP
.RS
resp, err := http.Get("http://example.com/")
.sp 0
\&...
.sp 0
resp, err := http.Post("http://example.com/upload", "image/jpeg", &buf)
.sp 0
\&...
.sp 0
resp, err := http.PostForm("http://example.com/form",
.sp 0
.RS
url.Values{"key": {"Value"}, "id": {"123"}})
.sp 0
.sp
.RE
.RE
.PP
The client must close the response body when finished with it: 
.PP
.RS
resp, err := http.Get("http://example.com/")
.sp 0
if err != nil {
.sp 0
.RS
// handle error
.sp 0
.RE
}
.sp 0
defer resp.Body.Close()
.sp 0
body, err := ioutil.ReadAll(resp.Body)
.sp 0
// \&...
.sp 0
.sp
.RE
.PP
For control over HTTP client headers, redirect policy, and other settings, create a Client: 
.PP
.RS
client := &http.Client{
.sp 0
.RS
CheckRedirect: redirectPolicyFunc,
.sp 0
.RE
}
.sp 0
.sp
resp, err := client.Get("http://example.com")
.sp 0
// \&...
.sp 0
.sp
req, err := http.NewRequest("GET", "http://example.com", nil)
.sp 0
// \&...
.sp 0
req.Header.Add("If\-None\-Match", `W/"wyzzy"`)
.sp 0
resp, err := client.Do(req)
.sp 0
// \&...
.sp 0
.sp
.RE
.PP
For control over proxies, TLS configuration, keep\-alives, compression, and other settings, create a Transport: 
.PP
.RS
tr := &http.Transport{
.sp 0
.RS
TLSClientConfig:    &tls.Config{RootCAs: pool},
.sp 0
DisableCompression: true,
.sp 0
.RE
}
.sp 0
client := &http.Client{Transport: tr}
.sp 0
resp, err := client.Get("https://example.com")
.sp 0
.sp
.RE
.PP
Clients and Transports are safe for concurrent use by multiple goroutines and for efficiency should only be created once and re\-used. 
.PP
ListenAndServe starts an HTTP server with a given address and handler. 
The handler is usually nil, which means to use DefaultServeMux. 
Handle and HandleFunc add handlers to DefaultServeMux: 
.PP
.RS
http.Handle("/foo", fooHandler)
.sp 0
.sp
http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
.sp 0
.RS
fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
.sp 0
.RE
})
.sp 0
.sp
log.Fatal(http.ListenAndServe(":8080", nil))
.sp 0
.sp
.RE
.PP
More control over the server's behavior is available by creating a custom Server: 
.PP
.RS
s := &http.Server{
.sp 0
.RS
Addr:           ":8080",
.sp 0
Handler:        myHandler,
.sp 0
ReadTimeout:    10 * time.Second,
.sp 0
WriteTimeout:   10 * time.Second,
.sp 0
MaxHeaderBytes: 1 << 20,
.sp 0
.RE
}
.sp 0
log.Fatal(s.ListenAndServe())
.RE
.SH "CONSTANTS"
HTTP status codes, defined in RFC 2616. 
.PP
.B const (
.RS
.B StatusContinue 
.sp 0
.B StatusSwitchingProtocols 
.sp 0
.B StatusOK 
.sp 0
.B StatusCreated 
.sp 0
.B StatusAccepted 
.sp 0
.B StatusNonAuthoritativeInfo 
.sp 0
.B StatusNoContent 
.sp 0
.B StatusResetContent 
.sp 0
.B StatusPartialContent 
.sp 0
.B StatusMultipleChoices 
.sp 0
.B StatusMovedPermanently 
.sp 0
.B StatusFound 
.sp 0
.B StatusSeeOther 
.sp 0
.B StatusNotModified 
.sp 0
.B StatusUseProxy 
.sp 0
.B StatusTemporaryRedirect 
.sp 0
.B StatusBadRequest 
.sp 0
.B StatusUnauthorized 
.sp 0
.B StatusPaymentRequired 
.sp 0
.B StatusForbidden 
.sp 0
.B StatusNotFound 
.sp 0
.B StatusMethodNotAllowed 
.sp 0
.B StatusNotAcceptable 
.sp 0
.B StatusProxyAuthRequired 
.sp 0
.B StatusRequestTimeout 
.sp 0
.B StatusConflict 
.sp 0
.B StatusGone 
.sp 0
.B StatusLengthRequired 
.sp 0
.B StatusPreconditionFailed 
.sp 0
.B StatusRequestEntityTooLarge 
.sp 0
.B StatusRequestURITooLong 
.sp 0
.B StatusUnsupportedMediaType 
.sp 0
.B StatusRequestedRangeNotSatisfiable 
.sp 0
.B StatusExpectationFailed 
.sp 0
.B StatusTeapot 
.sp 0
.B StatusInternalServerError 
.sp 0
.B StatusNotImplemented 
.sp 0
.B StatusBadGateway 
.sp 0
.B StatusServiceUnavailable 
.sp 0
.B StatusGatewayTimeout 
.sp 0
.B StatusHTTPVersionNotSupported 
.sp 0
.B 
.sp 0
.B 
.sp 0
.B 
.sp 0
.B 
.sp 0
.RE
.B )
.sp 0
DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request. 
This can be overridden by setting Server.MaxHeaderBytes. 
.PP
.B const 
.B DefaultMaxHeaderBytes 
.sp 0

.sp 0
DefaultMaxIdleConnsPerHost is the default value of Transport's MaxIdleConnsPerHost. 
.PP
.B const 
.B DefaultMaxIdleConnsPerHost 
.sp 0

.sp 0
TimeFormat is the time format to use with time.Parse and time.Time.Format when parsing or generating times in HTTP headers. 
It is like time.RFC1123 but hard codes GMT as the time zone. 
.PP
.B const 
.B TimeFormat 
.sp 0
.SH "VARIABLES"
.PP
.B var (
.RS
.B ErrHeaderTooLong 
.sp 0
.B ErrShortBody 
.sp 0
.B ErrNotSupported 
.sp 0
.B ErrUnexpectedTrailer 
.sp 0
.B ErrMissingContentLength 
.sp 0
.B ErrNotMultipart 
.sp 0
.B ErrMissingBoundary 
.sp 0
.RE
.B )
.sp 0
Errors introduced by the HTTP server. 
.PP
.B var (
.RS
.B ErrWriteAfterFlush 
.sp 0
.B ErrBodyNotAllowed 
.sp 0
.B ErrHijacked 
.sp 0
.B ErrContentLength 
.sp 0
.RE
.B )
.sp 0
DefaultClient is the default Client and is used by Get, Head, and Post. 
.PP
.B var 
.B DefaultClient 
.sp 0

.sp 0
DefaultServeMux is the default ServeMux used by Serve. 
.PP
.B var 
.B DefaultServeMux 
.sp 0

.sp 0
ErrBodyReadAfterClose is returned when reading a Request or Response Body after the body has been closed. 
This typically happens when the body is read after an HTTP Handler calls WriteHeader or Write on its ResponseWriter. 
.PP
.B var 
.B ErrBodyReadAfterClose 
.sp 0

.sp 0
ErrHandlerTimeout is returned on ResponseWriter Write calls in handlers which have timed out. 
.PP
.B var 
.B ErrHandlerTimeout 
.sp 0

.sp 0
.PP
.B var 
.B ErrLineTooLong 
.sp 0

.sp 0
ErrMissingFile is returned by FormFile when the provided file field name is either not present in the request or not a file field. 
.PP
.B var 
.B ErrMissingFile 
.sp 0

.sp 0
.PP
.B var 
.B ErrNoCookie 
.sp 0

.sp 0
.PP
.B var 
.B ErrNoLocation 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func CanonicalHeaderKey(" "s" " string) string"
.PP
CanonicalHeaderKey returns the canonical format of the header key s. 
The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. 
For example, the canonical key for "accept\-encoding" is "Accept\-Encoding". 
.PP
.BR "func DetectContentType(" "data" " []byte) string"
.PP
DetectContentType implements the algorithm described at http://mimesniff.spec.whatwg.org/ to determine the Content\-Type of the given data. 
It considers at most the first 512 bytes of data. 
DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns "application/octet\-stream". 
.PP
.BR "func Error(" "w" " ResponseWriter, " "error" " string, " "code" " int)"
.PP
Error replies to the request with the specified error message and HTTP code. 
The error message should be plain text. 
.PP
.BR "func Handle(" "pattern" " string, " "handler" " Handler)"
.PP
Handle registers the handler for the given pattern in the DefaultServeMux. 
The documentation for ServeMux explains how patterns are matched. 
.PP
.BR "func HandleFunc(" "pattern" " string, " "handler" " func(ResponseWriter, *Request))"
.PP
HandleFunc registers the handler function for the given pattern in the DefaultServeMux. 
The documentation for ServeMux explains how patterns are matched. 
.PP
.BR "func ListenAndServe(" "addr" " string, " "handler" " Handler) error"
.PP
ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. 
Handler is typically nil, in which case the DefaultServeMux is used. 
.PP
A trivial example server is:    
.PP
.RS
package main
.sp 0
.sp
import (
.sp 0
.RS
"io"
.sp 0
"net/http"
.sp 0
"log"
.sp 0
.RE
)
.sp 0
.sp
// hello world, the web server
.sp 0
func HelloServer(w http.ResponseWriter, req *http.Request) {
.sp 0
.RS
io.WriteString(w, "hello, world!\en")
.sp 0
.RE
}
.sp 0
.sp
func main() {
.sp 0
.RS
http.HandleFunc("/hello", HelloServer)
.sp 0
err := http.ListenAndServe(":12345", nil)
.sp 0
if err != nil {
.sp 0
.RS
log.Fatal("ListenAndServe: ", err)
.sp 0
.RE
}
.sp 0
.RE
}
.RE
.PP
.BR "func ListenAndServeTLS(" "addr" " string, " "certFile" " string, " "keyFile" " string, " "handler" " Handler) error"
.PP
ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. 
Additionally, files containing a certificate and matching private key for the server must be provided. 
If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate followed by the CA's certificate. 
.PP
A trivial example server is:    
.PP
.RS
import (
.sp 0
.RS
"log"
.sp 0
"net/http"
.sp 0
.RE
)
.sp 0
.sp
func handler(w http.ResponseWriter, req *http.Request) {
.sp 0
.RS
w.Header().Set("Content\-Type", "text/plain")
.sp 0
w.Write([]byte("This is an example server.\en"))
.sp 0
.RE
}
.sp 0
.sp
func main() {
.sp 0
.RS
http.HandleFunc("/", handler)
.sp 0
log.Printf("About to listen on 10443. Go to https://127.0.0.1:10443/")
.sp 0
err := http.ListenAndServeTLS(":10443", "cert.pem", "key.pem", nil)
.sp 0
if err != nil {
.sp 0
.RS
log.Fatal(err)
.sp 0
.RE
}
.sp 0
.RE
}
.sp 0
.sp
.RE
.PP
One can use generate_cert.go in crypto/tls to generate cert.pem and key.pem. 
.PP
.BR "func MaxBytesReader(" "w" " ResponseWriter, " "r" " io.ReadCloser, " "n" " int64) io.ReadCloser"
.PP
MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. 
In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non\-EOF error for a Read beyond the limit, and Closes the underlying reader when its Close method is called. 
.PP
MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. 
.PP
.BR "func NotFound(" "w" " ResponseWriter, " "r" " *Request)"
.PP
NotFound replies to the request with an HTTP 404 not found error. 
.PP
.BR "func ParseHTTPVersion(" "vers" " string) (" "major" ", " "minor" " int, " "ok" " bool)"
.PP
ParseHTTPVersion parses a HTTP version string. 
"HTTP/1.0" returns (1, 0, true). 
.PP
.BR "func ParseTime(" "text" " string) (" "t" " time.Time, " "err" " error)"
.PP
ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC. 
.PP
.BR "func ProxyFromEnvironment(" "req" " *Request) (*url.URL, error)"
.PP
ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy). 
An error is returned if the proxy environment is invalid. 
A nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request. 
.PP
As a special case, if req.URL.Host is "localhost" (with or without a port number), then a nil URL and nil error will be returned. 
.PP
.BR "func ProxyURL(" "fixedURL" " *url.URL) func(*Request) (*url.URL, error)"
.PP
ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL. 
.PP
.BR "func Redirect(" "w" " ResponseWriter, " "r" " *Request, " "urlStr" " string, " "code" " int)"
.PP
Redirect replies to the request with a redirect to url, which may be a path relative to the request path. 
.PP
.BR "func Serve(" "l" " net.Listener, " "handler" " Handler) error"
.PP
Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. 
The service goroutines read requests and then call handler to reply to them. 
Handler is typically nil, in which case the DefaultServeMux is used. 
.PP
.BR "func ServeContent(" "w" " ResponseWriter, " "req" " *Request, " "name" " string, " "modtime" " time.Time, " "content" " io.ReadSeeker)"
.PP
ServeContent replies to the request using the content in the provided ReadSeeker. 
The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If\-Modified\-Since requests. 
.PP
If the response's Content\-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. 
The name is otherwise unused; in particular it can be empty and is never sent in the response. 
.PP
If modtime is not the zero time, ServeContent includes it in a Last\-Modified header in the response. 
If the request includes an If\-Modified\-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all. 
.PP
The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size. 
.PP
If the caller has set w's ETag header, ServeContent uses it to handle requests using If\-Range and If\-None\-Match. 
.PP
Note that *os.File implements the io.ReadSeeker interface. 
.PP
.BR "func ServeFile(" "w" " ResponseWriter, " "r" " *Request, " "name" " string)"
.PP
ServeFile replies to the request with the contents of the named file or directory. 
.PP
.BR "func SetCookie(" "w" " ResponseWriter, " "cookie" " *Cookie)"
.PP
SetCookie adds a Set\-Cookie header to the provided ResponseWriter's headers. 
.PP
.BR "func StatusText(" "code" " int) string"
.PP
StatusText returns a text for the HTTP status code. 
It returns the empty string if the code is unknown. 
.SH "TYPES"
.SS "Client"
.B type Client struct {
.RS
.B Transport RoundTripper
.sp 0
.B CheckRedirect func(req *Request, via []*Request) error
.sp 0
.B Jar CookieJar
.sp 0
.B Timeout time.Duration
.RE
.B }
.PP
A Client is an HTTP client. 
Its zero value (DefaultClient) is a usable client that uses DefaultTransport. 
.PP
The Client's Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. 
Clients are safe for concurrent use by multiple goroutines. 
.PP
A Client is higher\-level than a RoundTripper (such as Transport) and additionally handles HTTP details such as cookies and redirects. 
.PP
.BR "func (*Client) Do(" "req" " *Request) (" "resp" " *Response, " "err" " error)"
.PP
Do sends an HTTP request and returns an HTTP response, following policy (e.g. 
redirects, cookies, auth) as configured on the client. 
.PP
An error is returned if caused by client policy (such as CheckRedirect), or if there was an HTTP protocol error. 
A non\-2xx response doesn't cause an error. 
.PP
When err is nil, resp always contains a non\-nil resp.Body. 
.PP
Callers should close resp.Body when done reading from it. 
If resp.Body is not closed, the Client's underlying RoundTripper (typically Transport) may not be able to re\-use a persistent TCP connection to the server for a subsequent "keep\-alive" request. 
.PP
The request Body, if non\-nil, will be closed by the underlying Transport, even on errors. 
.PP
Generally Get, Post, or PostForm will be used instead of Do. 
.PP
.BR "func (*Client) Get(" "url" " string) (" "resp" " *Response, " "err" " error)"
.PP
Get issues a GET to the specified URL. 
If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function. 
.PP
.RS
301 (Moved Permanently)
.sp 0
302 (Found)
.sp 0
303 (See Other)
.sp 0
307 (Temporary Redirect)
.sp 0
.sp
.RE
.PP
An error is returned if the Client's CheckRedirect function fails or if there was an HTTP protocol error. 
A non\-2xx response doesn't cause an error. 
.PP
When err is nil, resp always contains a non\-nil resp.Body. 
Caller should close resp.Body when done reading from it. 
.PP
.BR "func (*Client) Head(" "url" " string) (" "resp" " *Response, " "err" " error)"
.PP
Head issues a HEAD to the specified URL. 
If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function. 
.PP
.RS
301 (Moved Permanently)
.sp 0
302 (Found)
.sp 0
303 (See Other)
.sp 0
307 (Temporary Redirect)
.RE
.PP
.BR "func (*Client) Post(" "url" " string, " "bodyType" " string, " "body" " io.Reader) (" "resp" " *Response, " "err" " error)"
.PP
Post issues a POST to the specified URL. 
.PP
Caller should close resp.Body when done reading from it. 
.PP
If the provided body is also an io.Closer, it is closed after the request. 
.PP
.BR "func (*Client) PostForm(" "url" " string, " "data" " url.Values) (" "resp" " *Response, " "err" " error)"
.PP
PostForm issues a POST to the specified URL, with data's keys and values urlencoded as the request body. 
.PP
When err is nil, resp always contains a non\-nil resp.Body. 
Caller should close resp.Body when done reading from it. 
.SS "CloseNotifier"
.B type CloseNotifier interface {
.RS
.B CloseNotify() <-chan bool
.sp 0
.RE
.B }
.PP
The CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away. 
.PP
This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready. 
.SS "ConnState"
.B type ConnState int
.PP
A ConnState represents the state of a client connection to a server. 
It's used by the optional Server.ConnState hook. 
.PP
.B const (
.RS
.B StateNew 
.sp 0
.B StateActive 
.sp 0
.B StateIdle 
.sp 0
.B StateHijacked 
.sp 0
.B StateClosed 
.sp 0
.RE
.B )
.PP
.BR "func (ConnState) String() string"
.SS "Cookie"
.B type Cookie struct {
.RS
.B Name string
.sp 0
.B Value string
.sp 0
.B Path string
.sp 0
.B Domain string
.sp 0
.B Expires time.Time
.sp 0
.B RawExpires string
.sp 0
.B MaxAge int
.sp 0
.B Secure bool
.sp 0
.B HttpOnly bool
.sp 0
.B Raw string
.sp 0
.B Unparsed []string
.RE
.B }
.PP
A Cookie represents an HTTP cookie as sent in the Set\-Cookie header of an HTTP response or the Cookie header of an HTTP request. 
.PP
.BR "func (*Cookie) String() string"
.PP
String returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set\-Cookie response header (if other fields are set). 
.SS "CookieJar"
.B type CookieJar interface {
.RS
.B SetCookies(u *url.URL, cookies []*Cookie)
.sp 0
.B Cookies(u *url.URL) []*Cookie
.sp 0
.RE
.B }
.PP
A CookieJar manages storage and use of cookies in HTTP requests. 
.PP
Implementations of CookieJar must be safe for concurrent use by multiple goroutines. 
.PP
The net/http/cookiejar package provides a CookieJar implementation. 
.SS "Dir"
.B type Dir string
.PP
A Dir implements http.FileSystem using the native file system restricted to a specific directory tree. 
.PP
An empty Dir is treated as ".". 
.PP
.BR "func (Dir) Open(" "name" " string) (File, error)"
.SS "File"
.B type File interface {
.RS
.B io.Closer
.sp 0
.B io.Reader
.sp 0
.B Readdir(count int) ([]os.FileInfo, error)
.sp 0
.B Seek(offset int64, whence int) (int64, error)
.sp 0
.B Stat() (os.FileInfo, error)
.sp 0
.RE
.B }
.PP
A File is returned by a FileSystem's Open method and can be served by the FileServer implementation. 
.PP
The methods should behave the same as those on an *os.File. 
.SS "FileSystem"
.B type FileSystem interface {
.RS
.B Open(name string) (File, error)
.sp 0
.RE
.B }
.PP
A FileSystem implements access to a collection of named files. 
The elements in a file path are separated by slash ('/', U+002F) characters, regardless of host operating system convention. 
.SS "Flusher"
.B type Flusher interface {
.RS
.B Flush()
.sp 0
.RE
.B }
.PP
The Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client. 
.PP
Note that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes. 
.SS "Handler"
.B type Handler interface {
.RS
.B ServeHTTP(ResponseWriter, *Request)
.sp 0
.RE
.B }
.PP
Objects implementing the Handler interface can be registered to serve a particular path or subtree in the HTTP server. 
.PP
ServeHTTP should write reply headers and data to the ResponseWriter and then return. 
Returning signals that the request is finished and that the HTTP server can move on to the next request on the connection. 
.PP
.BR "func FileServer(" "root" " FileSystem) Handler"
.PP
FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root. 
.PP
To use the operating system's file system implementation, use http.Dir: 
.PP
.RS
http.Handle("/", http.FileServer(http.Dir("/tmp")))
.RE
.PP
.BR "func NotFoundHandler() Handler"
.PP
NotFoundHandler returns a simple request handler that replies to each request with a ``404 page not found'' reply. 
.PP
.BR "func RedirectHandler(" "url" " string, " "code" " int) Handler"
.PP
RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code. 
.PP
.BR "func StripPrefix(" "prefix" " string, " "h" " Handler) Handler"
.PP
StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path and invoking the handler h. 
StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error. 
.PP
.BR "func TimeoutHandler(" "h" " Handler, " "dt" " time.Duration, " "msg" " string) Handler"
.PP
TimeoutHandler returns a Handler that runs h with the given time limit. 
.PP
The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. 
(If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout. 
.SS "HandlerFunc"
.B type HandlerFunc func(ResponseWriter, *Request)
.PP
The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. 
If f is a function with the appropriate signature, 
.BR HandlerFunc (f)
is a Handler object that calls f. 
.PP
.BR "func (HandlerFunc) ServeHTTP(" "w" " ResponseWriter, " "r" " *Request)"
.PP
ServeHTTP calls f(w, r). 
.SS "Header"
.B type Header map[string][]string
.PP
A Header represents the key\-value pairs in an HTTP header. 
.PP
.BR "func (Header) Add(" "key" ", " "value" " string)"
.PP
Add adds the key, value pair to the header. 
It appends to any existing values associated with key. 
.PP
.BR "func (Header) Del(" "key" " string)"
.PP
Del deletes the values associated with key. 
.PP
.BR "func (Header) Get(" "key" " string) string"
.PP
Get gets the first value associated with the given key. 
If there are no values associated with the key, Get returns "". 
To access multiple values of a key, access the map directly with CanonicalHeaderKey. 
.PP
.BR "func (Header) Set(" "key" ", " "value" " string)"
.PP
Set sets the header entries associated with key to the single element value. 
It replaces any existing values associated with key. 
.PP
.BR "func (Header) Write(" "w" " io.Writer) error"
.PP
Write writes a header in wire format. 
.PP
.BR "func (Header) WriteSubset(" "w" " io.Writer, " "exclude" " map[string]bool) error"
.PP
WriteSubset writes a header in wire format. 
If exclude is not nil, keys where exclude[key] == true are not written. 
.SS "Hijacker"
.B type Hijacker interface {
.RS
.B Hijack() (net.Conn, *bufio.ReadWriter, error)
.sp 0
.RE
.B }
.PP
The Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection. 
.SS "ProtocolError"
.B type ProtocolError struct {
.RS
.B ErrorString string
.RE
.B }
.PP
HTTP request parsing errors. 
.PP
.BR "func (*ProtocolError) Error() string"
.SS "Request"
.B type Request struct {
.RS
.B Method string
.sp 0
.B URL *url.URL
.sp 0
.B Proto string
.sp 0
.B ProtoMajor int
.sp 0
.B ProtoMinor int
.sp 0
.B Header Header
.sp 0
.B Body io.ReadCloser
.sp 0
.B ContentLength int64
.sp 0
.B TransferEncoding []string
.sp 0
.B Close bool
.sp 0
.B Host string
.sp 0
.B Form url.Values
.sp 0
.B PostForm url.Values
.sp 0
.B MultipartForm *multipart.Form
.sp 0
.B Trailer Header
.sp 0
.B RemoteAddr string
.sp 0
.B RequestURI string
.sp 0
.B TLS *tls.ConnectionState
.RE
.B }
.PP
A Request represents an HTTP request received by a server or to be sent by a client. 
.PP
The field semantics differ slightly between client and server usage. 
In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper. 
.PP
.BR "func NewRequest(" "method" ", " "urlStr" " string, " "body" " io.Reader) (*Request, error)"
.PP
NewRequest returns a new Request given a method, URL, and optional body. 
.PP
If the provided body is also an io.Closer, the returned Request.Body is set to body and will be closed by the Client methods Do, Post, and PostForm, and Transport.RoundTrip. 
.PP
.BR "func ReadRequest(" "b" " *bufio.Reader) (" "req" " *Request, " "err" " error)"
.PP
ReadRequest reads and parses a request from b. 
.PP
.BR "func (*Request) AddCookie(" "c" " *Cookie)"
.PP
AddCookie adds a cookie to the request. 
Per RFC 6265 section 5.4, AddCookie does not attach more than one Cookie header field. 
That means all cookies, if any, are written into the same line, separated by semicolon. 
.PP
.BR "func (*Request) Cookie(" "name" " string) (*Cookie, error)"
.PP
Cookie returns the named cookie provided in the request or ErrNoCookie if not found. 
.PP
.BR "func (*Request) Cookies() []*Cookie"
.PP
Cookies parses and returns the HTTP cookies sent with the request. 
.PP
.BR "func (*Request) FormFile(" "key" " string) (multipart.File, *multipart.FileHeader, error)"
.PP
FormFile returns the first file for the provided form key. 
FormFile calls ParseMultipartForm and ParseForm if necessary. 
.PP
.BR "func (*Request) FormValue(" "key" " string) string"
.PP
FormValue returns the first value for the named component of the query. 
POST and PUT body parameters take precedence over URL query string values. 
FormValue calls ParseMultipartForm and ParseForm if necessary. 
To access multiple values of the same key use ParseForm. 
.PP
.BR "func (*Request) MultipartReader() (*multipart.Reader, error)"
.PP
MultipartReader returns a MIME multipart reader if this is a multipart/form\-data POST request, else returns nil and an error. 
Use this function instead of ParseMultipartForm to process the request body as a stream. 
.PP
.BR "func (*Request) ParseForm() error"
.PP
ParseForm parses the raw query from the URL and updates r.Form. 
.PP
For POST or PUT requests, it also parses the request body as a form and put the results into both r.PostForm and r.Form. 
POST and PUT body parameters take precedence over URL query string values in r.Form. 
.PP
If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB. 
.PP
ParseMultipartForm calls ParseForm automatically. 
It is idempotent. 
.PP
.BR "func (*Request) ParseMultipartForm(" "maxMemory" " int64) error"
.PP
ParseMultipartForm parses a request body as multipart/form\-data. 
The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. 
ParseMultipartForm calls ParseForm if necessary. 
After one call to ParseMultipartForm, subsequent calls have no effect. 
.PP
.BR "func (*Request) PostFormValue(" "key" " string) string"
.PP
PostFormValue returns the first value for the named component of the POST or PUT request body. 
URL query parameters are ignored. 
PostFormValue calls ParseMultipartForm and ParseForm if necessary. 
.PP
.BR "func (*Request) ProtoAtLeast(" "major" ", " "minor" " int) bool"
.PP
ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor. 
.PP
.BR "func (*Request) Referer() string"
.PP
Referer returns the referring URL, if sent in the request. 
.PP
Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. 
This value can also be fetched from the Header map as Header["Referer"]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header["Referrer"]. 
.PP
.BR "func (*Request) SetBasicAuth(" "username" ", " "password" " string)"
.PP
SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password. 
.PP
With HTTP Basic Authentication the provided username and password are not encrypted. 
.PP
.BR "func (*Request) UserAgent() string"
.PP
UserAgent returns the client's User\-Agent, if sent in the request. 
.PP
.BR "func (*Request) Write(" "w" " io.Writer) error"
.PP
Write writes an HTTP/1.1 request 
.B \--
header and body 
.B \--
in wire format. 
This method consults the following fields of the request: 
.PP
.RS
Host
.sp 0
URL
.sp 0
Method (defaults to "GET")
.sp 0
Header
.sp 0
ContentLength
.sp 0
TransferEncoding
.sp 0
Body
.sp 0
.sp
.RE
.PP
If Body is present, Content\-Length is <= 0 and TransferEncoding hasn't been set to "identity", Write adds "Transfer\-Encoding: chunked" to the header. 
Body is closed after it is sent. 
.PP
.BR "func (*Request) WriteProxy(" "w" " io.Writer) error"
.PP
WriteProxy is like Write but writes the request in the form expected by an HTTP proxy. 
In particular, WriteProxy writes the initial Request\-URI line of the request with an absolute URI, per section 5.1.2 of RFC 2616, including the scheme and host. 
In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host. 
.SS "Response"
.B type Response struct {
.RS
.B Status string
.sp 0
.B StatusCode int
.sp 0
.B Proto string
.sp 0
.B ProtoMajor int
.sp 0
.B ProtoMinor int
.sp 0
.B Header Header
.sp 0
.B Body io.ReadCloser
.sp 0
.B ContentLength int64
.sp 0
.B TransferEncoding []string
.sp 0
.B Close bool
.sp 0
.B Trailer Header
.sp 0
.B Request *Request
.sp 0
.B TLS *tls.ConnectionState
.RE
.B }
.PP
Response represents the response from an HTTP request. 
.PP
.BR "func Get(" "url" " string) (" "resp" " *Response, " "err" " error)"
.PP
Get issues a GET to the specified URL. 
If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects: 
.PP
.RS
301 (Moved Permanently)
.sp 0
302 (Found)
.sp 0
303 (See Other)
.sp 0
307 (Temporary Redirect)
.sp 0
.sp
.RE
.PP
An error is returned if there were too many redirects or if there was an HTTP protocol error. 
A non\-2xx response doesn't cause an error. 
.PP
When err is nil, resp always contains a non\-nil resp.Body. 
Caller should close resp.Body when done reading from it. 
.PP
Get is a wrapper around DefaultClient.Get. 
.PP
.BR "func Head(" "url" " string) (" "resp" " *Response, " "err" " error)"
.PP
Head issues a HEAD to the specified URL. 
If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function. 
.PP
.RS
301 (Moved Permanently)
.sp 0
302 (Found)
.sp 0
303 (See Other)
.sp 0
307 (Temporary Redirect)
.sp 0
.sp
.RE
.PP
Head is a wrapper around DefaultClient.Head    
.PP
.BR "func Post(" "url" " string, " "bodyType" " string, " "body" " io.Reader) (" "resp" " *Response, " "err" " error)"
.PP
Post issues a POST to the specified URL. 
.PP
Caller should close resp.Body when done reading from it. 
.PP
Post is a wrapper around DefaultClient.Post    
.PP
.BR "func PostForm(" "url" " string, " "data" " url.Values) (" "resp" " *Response, " "err" " error)"
.PP
PostForm issues a POST to the specified URL, with data's keys and values URL\-encoded as the request body. 
.PP
When err is nil, resp always contains a non\-nil resp.Body. 
Caller should close resp.Body when done reading from it. 
.PP
PostForm is a wrapper around DefaultClient.PostForm    
.PP
.BR "func ReadResponse(" "r" " *bufio.Reader, " "req" " *Request) (*Response, error)"
.PP
ReadResponse reads and returns an HTTP response from r. 
The req parameter optionally specifies the Request that corresponds to this Response. 
If nil, a GET request is assumed. 
Clients must call resp.Body.Close when finished reading resp.Body. 
After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer. 
.PP
.BR "func (*Response) Cookies() []*Cookie"
.PP
Cookies parses and returns the cookies set in the Set\-Cookie headers. 
.PP
.BR "func (*Response) Location() (*url.URL, error)"
.PP
Location returns the URL of the response's "Location" header, if present. 
Relative redirects are resolved relative to the Response's Request. 
ErrNoLocation is returned if no Location header is present. 
.PP
.BR "func (*Response) ProtoAtLeast(" "major" ", " "minor" " int) bool"
.PP
ProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor. 
.PP
.BR "func (*Response) Write(" "w" " io.Writer) error"
.PP
Writes the response (header, body and trailer) in wire format. 
This method consults the following fields of the response: 
.PP
StatusCode ProtoMajor ProtoMinor Request.Method TransferEncoding Trailer Body ContentLength Header, values for non\-canonical keys will have unpredictable behavior 
.PP
Body is closed after it is sent. 
.SS "ResponseWriter"
.B type ResponseWriter interface {
.RS
.B Header() Header
.sp 0
.B Write([]byte) (int, error)
.sp 0
.B WriteHeader(int)
.sp 0
.RE
.B }
.PP
A ResponseWriter interface is used by an HTTP handler to construct an HTTP response. 
.SS "RoundTripper"
.B type RoundTripper interface {
.RS
.B RoundTrip(*Request) (*Response, error)
.sp 0
.RE
.B }
.PP
RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request. 
.PP
A RoundTripper must be safe for concurrent use by multiple goroutines. 
DefaultTransport is the default implementation of Transport and is used by DefaultClient. 
It establishes network connections as needed and caches them for reuse by subsequent calls. 
It uses HTTP proxies as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy) environment variables. 
.PP
.B var 
.B DefaultTransport 
.sp 0
.PP
.BR "func NewFileTransport(" "fs" " FileSystem) RoundTripper"
.PP
NewFileTransport returns a new RoundTripper, serving the provided FileSystem. 
The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request. 
.PP
The typical use case for NewFileTransport is to register the "file" protocol with a Transport, as in: 
.PP
t := &http.Transport{} t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/"))) c := &http.Client{Transport: t} res, err := c.Get("file:///etc/passwd") \&... 
.SS "ServeMux"
.B type ServeMux struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
ServeMux is an HTTP request multiplexer. 
It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL. 
.PP
Patterns name fixed, rooted paths, like "/favicon.ico", or rooted subtrees, like "/images/" (note the trailing slash). 
Longer patterns take precedence over shorter ones, so that if there are handlers registered for both "/images/" and "/images/thumbnails/", the latter handler will be called for paths beginning "/images/thumbnails/" and the former will receive requests for any other paths in the "/images/" subtree. 
.PP
Note that since a pattern ending in a slash names a rooted subtree, the pattern "/" matches all paths not matched by other registered patterns, not just the URL with Path == "/". 
.PP
Patterns may optionally begin with a host name, restricting matches to URLs on that host only. 
Host\-specific patterns take precedence over general patterns, so that a handler might register for the two patterns "/codesearch" and "codesearch.google.com/" without also taking over requests for "http://www.google.com/". 
.PP
ServeMux also takes care of sanitizing the URL request path, redirecting any request containing \&. or \&.. 
elements to an equivalent \&.\- and \&..\-free URL. 
.PP
.BR "func NewServeMux() *ServeMux"
.PP
NewServeMux allocates and returns a new ServeMux. 
.PP
.BR "func (*ServeMux) Handle(" "pattern" " string, " "handler" " Handler)"
.PP
Handle registers the handler for the given pattern. 
If a handler already exists for pattern, Handle panics. 
.PP
.BR "func (*ServeMux) HandleFunc(" "pattern" " string, " "handler" " func(ResponseWriter, *Request))"
.PP
HandleFunc registers the handler function for the given pattern. 
.PP
.BR "func (*ServeMux) Handler(" "r" " *Request) (" "h" " Handler, " "pattern" " string)"
.PP
Handler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. 
It always returns a non\-nil handler. 
If the path is not in its canonical form, the handler will be an internally\-generated handler that redirects to the canonical path. 
.PP
Handler also returns the registered pattern that matches the request or, in the case of internally\-generated redirects, the pattern that will match after following the redirect. 
.PP
If there is no registered handler that applies to the request, Handler returns a ``page not found'' handler and an empty pattern. 
.PP
.BR "func (*ServeMux) ServeHTTP(" "w" " ResponseWriter, " "r" " *Request)"
.PP
ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL. 
.SS "Server"
.B type Server struct {
.RS
.B Addr string
.sp 0
.B Handler Handler
.sp 0
.B ReadTimeout time.Duration
.sp 0
.B WriteTimeout time.Duration
.sp 0
.B MaxHeaderBytes int
.sp 0
.B TLSConfig *tls.Config
.sp 0
.B TLSNextProto map[string]func(*Server, *tls.Conn, Handler)
.sp 0
.B ConnState func(net.Conn, ConnState)
.sp 0
.B ErrorLog *log.Logger
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Server defines parameters for running an HTTP server. 
The zero value for Server is a valid configuration. 
.PP
.BR "func (*Server) ListenAndServe() error"
.PP
ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. 
If srv.Addr is blank, ":http" is used. 
.PP
.BR "func (*Server) ListenAndServeTLS(" "certFile" ", " "keyFile" " string) error"
.PP
ListenAndServeTLS listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming TLS connections. 
.PP
Filenames containing a certificate and matching private key for the server must be provided. 
If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate followed by the CA's certificate. 
.PP
If srv.Addr is blank, ":https" is used. 
.PP
.BR "func (*Server) Serve(" "l" " net.Listener) error"
.PP
Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. 
The service goroutines read requests and then call srv.Handler to reply to them. 
.PP
.BR "func (*Server) SetKeepAlivesEnabled(" "v" " bool)"
.PP
SetKeepAlivesEnabled controls whether HTTP keep\-alives are enabled. 
By default, keep\-alives are always enabled. 
Only very resource\-constrained environments or servers in the process of shutting down should disable them. 
.SS "Transport"
.B type Transport struct {
.RS
.B Proxy func(*Request) (*url.URL, error)
.sp 0
.B Dial func(network, addr string) (net.Conn, error)
.sp 0
.B TLSClientConfig *tls.Config
.sp 0
.B TLSHandshakeTimeout time.Duration
.sp 0
.B DisableKeepAlives bool
.sp 0
.B DisableCompression bool
.sp 0
.B MaxIdleConnsPerHost int
.sp 0
.B ResponseHeaderTimeout time.Duration
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Transport is an implementation of RoundTripper that supports http, https, and http proxies (for either http or https with CONNECT). 
Transport can also cache connections for future re\-use. 
.PP
.BR "func (*Transport) CancelRequest(" "req" " *Request)"
.PP
CancelRequest cancels an in\-flight request by closing its connection. 
.PP
.BR "func (*Transport) CloseIdleConnections()"
.PP
CloseIdleConnections closes any connections which were previously connected from previous requests but are now sitting idle in a "keep\-alive" state. 
It does not interrupt any connections currently in use. 
.PP
.BR "func (*Transport) RegisterProtocol(" "scheme" " string, " "rt" " RoundTripper)"
.PP
RegisterProtocol registers a new protocol with scheme. 
The Transport will pass requests using the given scheme to rt. 
It is rt's responsibility to simulate HTTP request semantics. 
.PP
RegisterProtocol can be used by other packages to provide implementations of protocol schemes like "ftp" or "file". 
.PP
.BR "func (*Transport) RoundTrip(" "req" " *Request) (" "resp" " *Response, " "err" " error)"
.PP
RoundTrip implements the RoundTripper interface. 
.PP
For higher\-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type. 
.SS "badStringError"
.B type badStringError struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*badStringError) Error() string"
.SS "body"
.B type body struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
body turns a Reader into a ReadCloser. 
Close ensures that the body has been fully read and then reads the trailer if necessary. 
.PP
.BR "func (*body) Close() error"
.PP
.BR "func (*body) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "bodyEOFSignal"
.B type bodyEOFSignal struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
bodyEOFSignal wraps a ReadCloser but runs fn (if non\-nil) at most once, right before its final (error\-producing) Read or Close call returns. 
If earlyCloseFn is non\-nil and Close is called before io.EOF is seen, earlyCloseFn is called instead of fn, and its return value is the return value from Close. 
.PP
.BR "func (*bodyEOFSignal) Close() error"
.PP
.BR "func (*bodyEOFSignal) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "bodyLocked"
.B type bodyLocked struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
bodyLocked is a io.Reader reading from a *body when its mutex is already held. 
.PP
.BR "func (bodyLocked) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "cancelTimerBody"
.B type cancelTimerBody struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*cancelTimerBody) Close() error"
.PP
.BR "func (*cancelTimerBody) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "chunkWriter"
.B type chunkWriter struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
chunkWriter writes to a response's conn buffer, and is the writer wrapped by the response.bufw buffered writer. 
.PP
chunkWriter also is responsible for finalizing the Header, including conditionally setting the Content\-Type and setting a Content\-Length in cases where the handler's final output is smaller than the buffer size. 
It also conditionally adds chunk headers, when in chunking mode. 
.PP
See the comment above (*response).Write for the entire write flow. 
.PP
.BR "func (*chunkWriter) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "chunkedReader"
.B type chunkedReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*chunkedReader) Read(" "b" " []uint8) (" "n" " int, " "err" " error)"
.SS "chunkedWriter"
.B type chunkedWriter struct {
.RS
.B Wire io.Writer
.RE
.B }
.PP
Writing to chunkedWriter translates to writing in HTTP chunked Transfer Encoding wire format to the underlying Wire chunkedWriter. 
.PP
.BR "func (*chunkedWriter) Close() error"
.PP
.BR "func (*chunkedWriter) Write(" "data" " []byte) (" "n" " int, " "err" " error)"
.PP
Write the contents of data as one chunk to Wire. 
NOTE: Note that the corresponding chunk\-writing procedure in Conn.Write has a bug since it does not check for success of io.WriteString 
.SS "connectMethodKey"
.B type connectMethodKey struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
connectMethodKey is the map key version of connectMethod, with a stringified proxy URL (or the empty string) instead of a pointer to a URL. 
.PP
.BR "func (connectMethodKey) String() string"
.SS "countingWriter"
.B type countingWriter int64
.PP
countingWriter counts how many bytes have been written to it. 
.PP
.BR "func (*countingWriter) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "envOnce"
.B type envOnce struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
envOnce looks up an environment variable (optionally by multiple names) once. 
It mitigates expensive lookups on some platforms (e.g. 
Windows). 
.PP
.BR "func (*envOnce) Get() string"
.SS "eofReaderWithWriteTo"
.B type eofReaderWithWriteTo struct {
.RS
.RE
.B }
.PP
.PP
.BR "func (eofReaderWithWriteTo) Read([]byte) (int, error)"
.PP
.BR "func (eofReaderWithWriteTo) WriteTo(io.Writer) (int64, error)"
.SS "errorReader"
.B type errorReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*errorReader) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "expectContinueReader"
.B type expectContinueReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
wrapper around io.ReaderCloser which on first read, sends an HTTP/1.1 100 Continue header 
.PP
.BR "func (*expectContinueReader) Close() error"
.PP
.BR "func (*expectContinueReader) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "extraHeader"
.B type extraHeader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
extraHeader is the set of headers sometimes added by chunkWriter.writeHeader. 
This type is used to avoid extra allocations from cloning and/or populating the response Header map and all its 1\-element slices. 
.PP
.BR "func (extraHeader) Write(" "w" " *bufio.Writer)"
.PP
Write writes the headers described in h to w. 
.PP
This method has a value receiver, despite the somewhat large size of h, because it prevents an allocation. 
The escape analysis isn't smart enough to realize this function doesn't mutate h. 
.SS "fileHandler"
.B type fileHandler struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*fileHandler) ServeHTTP(" "w" " ResponseWriter, " "r" " *Request)"
.SS "fileTransport"
.B type fileTransport struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
fileTransport implements RoundTripper for the \(fmfile' protocol. 
.PP
.BR "func (fileTransport) RoundTrip(" "req" " *Request) (" "resp" " *Response, " "err" " error)"
.SS "globalOptionsHandler"
.B type globalOptionsHandler struct {
.RS
.RE
.B }
.PP
globalOptionsHandler responds to "OPTIONS *" requests. 
.PP
.BR "func (globalOptionsHandler) ServeHTTP(" "w" " ResponseWriter, " "r" " *Request)"
.SS "gzipReader"
.B type gzipReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
gzipReader wraps a response body so it can lazily call gzip.NewReader on the first call to Read 
.PP
.BR "func (*gzipReader) Close() error"
.PP
.BR "func (*gzipReader) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "headerSorter"
.B type headerSorter struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A headerSorter implements sort.Interface by sorting a []keyValues by key. 
It's used as a pointer, so it can fit in a sort.Interface interface value without allocation. 
.PP
.BR "func (*headerSorter) Len() int"
.PP
.BR "func (*headerSorter) Less(" "i" ", " "j" " int) bool"
.PP
.BR "func (*headerSorter) Swap(" "i" ", " "j" " int)"
.SS "httpError"
.B type httpError struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*httpError) Error() string"
.PP
.BR "func (*httpError) Temporary() bool"
.PP
.BR "func (*httpError) Timeout() bool"
.SS "initNPNRequest"
.B type initNPNRequest struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
initNPNRequest is an HTTP handler that initializes certain uninitialized fields in its *Request. 
Such partially\-initialized Requests come from NPN protocol handlers. 
.PP
.BR "func (initNPNRequest) ServeHTTP(" "rw" " ResponseWriter, " "req" " *Request)"
.SS "liveSwitchReader"
.B type liveSwitchReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A liveSwitchReader is a switchReader that's safe for concurrent reads and switches, if its mutex is held. 
.PP
.BR "func (*liveSwitchReader) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "loggingConn"
.B type loggingConn struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
loggingConn is used for debugging. 
.PP
.BR "func (*loggingConn) Close() (" "err" " error)"
.PP
.BR "func (*loggingConn) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.PP
.BR "func (*loggingConn) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "maxBytesReader"
.B type maxBytesReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*maxBytesReader) Close() error"
.PP
.BR "func (*maxBytesReader) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "noteEOFReader"
.B type noteEOFReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (noteEOFReader) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "populateResponse"
.B type populateResponse struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
populateResponse is a ResponseWriter that populates the *Response in res, and writes its body to a pipe connected to the response body. 
Once writes begin or finish() is called, the response is sent on ch. 
.PP
.BR "func (*populateResponse) Header() Header"
.PP
.BR "func (*populateResponse) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
.PP
.BR "func (*populateResponse) WriteHeader(" "code" " int)"
.SS "redirectHandler"
.B type redirectHandler struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Redirect to a fixed URL    
.PP
.BR "func (*redirectHandler) ServeHTTP(" "w" " ResponseWriter, " "r" " *Request)"
.SS "response"
.B type response struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A response represents the server side of an HTTP response. 
.PP
.BR "func (*response) CloseNotify() <-chan bool"
.PP
.BR "func (*response) Flush()"
.PP
.BR "func (*response) Header() Header"
.PP
.BR "func (*response) Hijack() (" "rwc" " net.Conn, " "buf" " *bufio.ReadWriter, " "err" " error)"
.PP
Hijack implements the Hijacker.Hijack method. 
Our response is both a ResponseWriter and a Hijacker. 
.PP
.BR "func (*response) ReadFrom(" "src" " io.Reader) (" "n" " int64, " "err" " error)"
.PP
ReadFrom is here to optimize copying from an *os.File regular file to a *net.TCPConn with sendfile. 
.PP
.BR "func (*response) Write(" "data" " []byte) (" "n" " int, " "err" " error)"
.PP
The Life Of A Write is like this:    
.PP
Handler starts. 
No header has been sent. 
The handler can either write a header, or just start writing. 
Writing before sending a header sends an implicitly empty 200 OK header. 
.PP
If the handler didn't declare a Content\-Length up front, we either go into chunking mode or, if the handler finishes running before the chunking buffer size, we compute a Content\-Length and send that in the header instead. 
.PP
Likewise, if the handler didn't set a Content\-Type, we sniff that from the initial chunk of output. 
.PP
The Writers are wired together like:    
.PP
*response (the ResponseWriter) 
.B \->
2. 
(*response).w, a *bufio.Writer of bufferBeforeChunkingSize bytes 3. 
chunkWriter.Writer (whose writeHeader finalizes Content\-Length/Type) 
.PP
.RS
and which writes the chunk headers, if needed.
.RE
.PP
conn.buf, a bufio.Writer of default (4kB) bytes 5. 
the rwc, the net.Conn. 
.PP
TODO(bradfitz): short\-circuit some of the buffering when the initial header contains both a Content\-Type and Content\-Length. 
Also short\-circuit in (1) when the header's been sent and not in chunking mode, writing directly to (4) instead, if (2) has no buffered data. 
More generally, we could short\-circuit from (1) to (3) even in chunking mode if the write size from (1) is over some threshold and nothing is in (2). 
The answer might be mostly making bufferBeforeChunkingSize smaller and having bufio's fast\-paths deal with this instead. 
.PP
.BR "func (*response) WriteHeader(" "code" " int)"
.PP
.BR "func (*response) WriteString(" "data" " string) (" "n" " int, " "err" " error)"
.SS "serverHandler"
.B type serverHandler struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
serverHandler delegates to either the server's Handler or DefaultServeMux and also handles "OPTIONS *" requests. 
.PP
.BR "func (serverHandler) ServeHTTP(" "rw" " ResponseWriter, " "req" " *Request)"
.SS "stringWriter"
.B type stringWriter struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
stringWriter implements WriteString on a Writer. 
.PP
.BR "func (stringWriter) WriteString(" "s" " string) (" "n" " int, " "err" " error)"
.SS "tcpKeepAliveListener"
.B type tcpKeepAliveListener struct {
.RS
.RE
.B }
.PP
tcpKeepAliveListener sets TCP keep\-alive timeouts on accepted connections. 
It's used by ListenAndServe and ListenAndServeTLS so dead TCP connections (e.g. 
closing laptop mid\-download) eventually go away. 
.PP
.BR "func (tcpKeepAliveListener) Accept() (" "c" " net.Conn, " "err" " error)"
.SS "timeoutHandler"
.B type timeoutHandler struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*timeoutHandler) ServeHTTP(" "w" " ResponseWriter, " "r" " *Request)"
.SS "timeoutWriter"
.B type timeoutWriter struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*timeoutWriter) Header() Header"
.PP
.BR "func (*timeoutWriter) Write(" "p" " []byte) (int, error)"
.PP
.BR "func (*timeoutWriter) WriteHeader(" "code" " int)"
.SS "tlsHandshakeTimeoutError"
.B type tlsHandshakeTimeoutError struct {
.RS
.RE
.B }
.PP
.PP
.BR "func (tlsHandshakeTimeoutError) Error() string"
.PP
.BR "func (tlsHandshakeTimeoutError) Temporary() bool"
.PP
.BR "func (tlsHandshakeTimeoutError) Timeout() bool"
.SS "transferReader"
.B type transferReader struct {
.RS
.B Header Header
.sp 0
.B StatusCode int
.sp 0
.B RequestMethod string
.sp 0
.B ProtoMajor int
.sp 0
.B ProtoMinor int
.sp 0
.B Body io.ReadCloser
.sp 0
.B ContentLength int64
.sp 0
.B TransferEncoding []string
.sp 0
.B Close bool
.sp 0
.B Trailer Header
.RE
.B }
.SS "transferWriter"
.B type transferWriter struct {
.RS
.B Method string
.sp 0
.B Body io.Reader
.sp 0
.B BodyCloser io.Closer
.sp 0
.B ResponseToHEAD bool
.sp 0
.B ContentLength int64
.sp 0
.B Close bool
.sp 0
.B TransferEncoding []string
.sp 0
.B Trailer Header
.RE
.B }
.PP
transferWriter inspects the fields of a user\-supplied Request or Response, sanitizes them without changing the user object and provides methods for writing the respective header, body and trailer in wire format. 
.PP
.BR "func (*transferWriter) WriteBody(" "w" " io.Writer) error"
.PP
.BR "func (*transferWriter) WriteHeader(" "w" " io.Writer) error"
.SS "transportRequest"
.B type transportRequest struct {
.RS
.B *Request
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
transportRequest is a wrapper around a *Request that adds optional extra headers to write. 
.PP
.BR "func (transportRequest) AddCookie(" "c" " *Cookie)"
.PP
AddCookie adds a cookie to the request. 
Per RFC 6265 section 5.4, AddCookie does not attach more than one Cookie header field. 
That means all cookies, if any, are written into the same line, separated by semicolon. 
.PP
.BR "func (transportRequest) Cookie(" "name" " string) (*Cookie, error)"
.PP
Cookie returns the named cookie provided in the request or ErrNoCookie if not found. 
.PP
.BR "func (transportRequest) Cookies() []*Cookie"
.PP
Cookies parses and returns the HTTP cookies sent with the request. 
.PP
.BR "func (transportRequest) FormFile(" "key" " string) (multipart.File, *multipart.FileHeader, error)"
.PP
FormFile returns the first file for the provided form key. 
FormFile calls ParseMultipartForm and ParseForm if necessary. 
.PP
.BR "func (transportRequest) FormValue(" "key" " string) string"
.PP
FormValue returns the first value for the named component of the query. 
POST and PUT body parameters take precedence over URL query string values. 
FormValue calls ParseMultipartForm and ParseForm if necessary. 
To access multiple values of the same key use ParseForm. 
.PP
.BR "func (transportRequest) MultipartReader() (*multipart.Reader, error)"
.PP
MultipartReader returns a MIME multipart reader if this is a multipart/form\-data POST request, else returns nil and an error. 
Use this function instead of ParseMultipartForm to process the request body as a stream. 
.PP
.BR "func (transportRequest) ParseForm() error"
.PP
ParseForm parses the raw query from the URL and updates r.Form. 
.PP
For POST or PUT requests, it also parses the request body as a form and put the results into both r.PostForm and r.Form. 
POST and PUT body parameters take precedence over URL query string values in r.Form. 
.PP
If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB. 
.PP
ParseMultipartForm calls ParseForm automatically. 
It is idempotent. 
.PP
.BR "func (transportRequest) ParseMultipartForm(" "maxMemory" " int64) error"
.PP
ParseMultipartForm parses a request body as multipart/form\-data. 
The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. 
ParseMultipartForm calls ParseForm if necessary. 
After one call to ParseMultipartForm, subsequent calls have no effect. 
.PP
.BR "func (transportRequest) PostFormValue(" "key" " string) string"
.PP
PostFormValue returns the first value for the named component of the POST or PUT request body. 
URL query parameters are ignored. 
PostFormValue calls ParseMultipartForm and ParseForm if necessary. 
.PP
.BR "func (transportRequest) ProtoAtLeast(" "major" ", " "minor" " int) bool"
.PP
ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor. 
.PP
.BR "func (transportRequest) Referer() string"
.PP
Referer returns the referring URL, if sent in the request. 
.PP
Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. 
This value can also be fetched from the Header map as Header["Referer"]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header["Referrer"]. 
.PP
.BR "func (transportRequest) SetBasicAuth(" "username" ", " "password" " string)"
.PP
SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password. 
.PP
With HTTP Basic Authentication the provided username and password are not encrypted. 
.PP
.BR "func (transportRequest) UserAgent() string"
.PP
UserAgent returns the client's User\-Agent, if sent in the request. 
.PP
.BR "func (transportRequest) Write(" "w" " io.Writer) error"
.PP
Write writes an HTTP/1.1 request 
.B \--
header and body 
.B \--
in wire format. 
This method consults the following fields of the request: 
.PP
.RS
Host
.sp 0
URL
.sp 0
Method (defaults to "GET")
.sp 0
Header
.sp 0
ContentLength
.sp 0
TransferEncoding
.sp 0
Body
.sp 0
.sp
.RE
.PP
If Body is present, Content\-Length is <= 0 and TransferEncoding hasn't been set to "identity", Write adds "Transfer\-Encoding: chunked" to the header. 
Body is closed after it is sent. 
.PP
.BR "func (transportRequest) WriteProxy(" "w" " io.Writer) error"
.PP
WriteProxy is like Write but writes the request in the form expected by an HTTP proxy. 
In particular, WriteProxy writes the initial Request\-URI line of the request with an absolute URI, per section 5.1.2 of RFC 2616, including the scheme and host. 
In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host. 
.SS "writeStringer"
.B type writeStringer interface {
.RS
.B WriteString(string) (int, error)
.sp 0
.RE
.B }
