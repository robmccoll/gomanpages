.\"    Automatically generated by mango(1)
.TH "x509" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
x509 \- Package x509 parses X.509-encoded keys and certificates.
.SH "SYNOPSIS"
.B import \*(lqx509\(rq
.sp
.B Variables
.sp 0
.RB "func " CreateCertificate
.sp 0
.RB "func " CreateCertificateRequest
.sp 0
.RB "func " DecryptPEMBlock
.sp 0
.RB "func " EncryptPEMBlock
.sp 0
.RB "func " IsEncryptedPEMBlock
.sp 0
.RB "func " MarshalECPrivateKey
.sp 0
.RB "func " MarshalPKCS1PrivateKey
.sp 0
.RB "func " MarshalPKIXPublicKey
.sp 0
.RB "func " ParseCRL
.sp 0
.RB "func " ParseCertificates
.sp 0
.RB "func " ParseDERCRL
.sp 0
.RB "func " ParseECPrivateKey
.sp 0
.RB "func " ParsePKCS1PrivateKey
.sp 0
.RB "func " ParsePKCS8PrivateKey
.sp 0
.RB "func " ParsePKIXPublicKey
.sp 0
.RB "type " CertPool
.sp 0
.RS
.RB "func " NewCertPool
.sp 0
.RB "func (*CertPool) " AddCert
.sp 0
.RB "func (*CertPool) " AppendCertsFromPEM
.sp 0
.RB "func (*CertPool) " Subjects
.sp 0
.RE
.RB "type " Certificate
.sp 0
.RS
.RB "func " ParseCertificate
.sp 0
.RB "func (*Certificate) " CheckCRLSignature
.sp 0
.RB "func (*Certificate) " CheckSignature
.sp 0
.RB "func (*Certificate) " CheckSignatureFrom
.sp 0
.RB "func (*Certificate) " CreateCRL
.sp 0
.RB "func (*Certificate) " Equal
.sp 0
.RB "func (*Certificate) " Verify
.sp 0
.RB "func (*Certificate) " VerifyHostname
.sp 0
.RE
.RB "type " CertificateInvalidError
.sp 0
.RS
.RB "func (CertificateInvalidError) " Error
.sp 0
.RE
.RB "type " CertificateRequest
.sp 0
.RS
.RB "func " ParseCertificateRequest
.sp 0
.RE
.RB "type " ConstraintViolationError
.sp 0
.RS
.RB "func (ConstraintViolationError) " Error
.sp 0
.RE
.RB "type " ExtKeyUsage
.sp 0
.RS
.RE
.RB "type " HostnameError
.sp 0
.RS
.RB "func (HostnameError) " Error
.sp 0
.RE
.RB "type " InvalidReason
.sp 0
.RB "type " KeyUsage
.sp 0
.RB "type " PEMCipher
.sp 0
.RB "type " PublicKeyAlgorithm
.sp 0
.RS
.RE
.RB "type " SignatureAlgorithm
.sp 0
.RS
.RE
.RB "type " SystemRootsError
.sp 0
.RS
.RB "func (SystemRootsError) " Error
.sp 0
.RE
.RB "type " UnhandledCriticalExtension
.sp 0
.RS
.RB "func (UnhandledCriticalExtension) " Error
.sp 0
.RE
.RB "type " UnknownAuthorityError
.sp 0
.RS
.RB "func (UnknownAuthorityError) " Error
.sp 0
.RE
.RB "type " VerifyOptions
.sp 0
.RB "type " authKeyId
.sp 0
.RB "type " authorityInfoAccess
.sp 0
.RB "type " basicConstraints
.sp 0
.RB "type " certificate
.sp 0
.RB "type " certificateRequest
.sp 0
.RB "type " distributionPoint
.sp 0
.RB "type " distributionPointName
.sp 0
.RB "type " dsaAlgorithmParameters
.sp 0
.RB "type " dsaSignature
.sp 0
.RB "type " ecPrivateKey
.sp 0
.RB "type " generalSubtree
.sp 0
.RB "type " nameConstraints
.sp 0
.RB "type " pkcs1AdditionalRSAPrime
.sp 0
.RB "type " pkcs1PrivateKey
.sp 0
.RB "type " pkcs8
.sp 0
.RB "type " pkixPublicKey
.sp 0
.RB "type " policyInformation
.sp 0
.RB "type " publicKeyInfo
.sp 0
.RB "type " rsaPublicKey
.sp 0
.RB "type " tbsCertificate
.sp 0
.RB "type " tbsCertificateRequest
.sp 0
.RB "type " validity
.sp 0
.SH "VARIABLES"
ErrUnsupportedAlgorithm results from attempting to perform an operation that involves algorithms that are not currently implemented. 
.PP
.B var 
.B ErrUnsupportedAlgorithm 
.sp 0

.sp 0
IncorrectPasswordError is returned when an incorrect password is detected. 
.PP
.B var 
.B IncorrectPasswordError 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func CreateCertificate(" "rand" " io.Reader, " "template" ", " "parent" " *Certificate, " "pub" " interface{}, " "priv" " interface{}) (" "cert" " []byte, " "err" " error)"
.PP
CreateCertificate creates a new certificate based on a template. 
The following members of template are used: SerialNumber, Subject, NotBefore, NotAfter, KeyUsage, ExtKeyUsage, UnknownExtKeyUsage, BasicConstraintsValid, IsCA, MaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical, PermittedDNSDomains, SignatureAlgorithm. 
.PP
The certificate is signed by parent. 
If parent is equal to template then the certificate is self\-signed. 
The parameter pub is the public key of the signee and priv is the private key of the signer. 
.PP
The returned slice is the certificate in DER encoding. 
.PP
The only supported key types are RSA and ECDSA (*rsa.PublicKey or *ecdsa.PublicKey for pub, *rsa.PrivateKey or *ecdsa.PrivateKey for priv). 
.PP
.BR "func CreateCertificateRequest(" "rand" " io.Reader, " "template" " *CertificateRequest, " "priv" " interface{}) (" "csr" " []byte, " "err" " error)"
.PP
CreateCertificateRequest creates a new certificate based on a template. 
The following members of template are used: Subject, Attributes, SignatureAlgorithm, Extension, DNSNames, EmailAddresses, and IPAddresses. 
The private key is the private key of the signer. 
.PP
The returned slice is the certificate request in DER encoding. 
.PP
The only supported key types are RSA (*rsa.PrivateKey) and ECDSA (*ecdsa.PrivateKey). 
.PP
.BR "func DecryptPEMBlock(" "b" " *pem.Block, " "password" " []byte) ([]byte, error)"
.PP
DecryptPEMBlock takes a password encrypted PEM block and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. 
It inspects the DEK\-Info header to determine the algorithm used for decryption. 
If no DEK\-Info header is present, an error is returned. 
If an incorrect password is detected an IncorrectPasswordError is returned. 
.PP
.BR "func EncryptPEMBlock(" "rand" " io.Reader, " "blockType" " string, " "data" ", " "password" " []byte, " "alg" " PEMCipher) (*pem.Block, error)"
.PP
EncryptPEMBlock returns a PEM block of the specified type holding the given DER\-encoded data encrypted with the specified algorithm and password. 
.PP
.BR "func IsEncryptedPEMBlock(" "b" " *pem.Block) bool"
.PP
IsEncryptedPEMBlock returns if the PEM block is password encrypted. 
.PP
.BR "func MarshalECPrivateKey(" "key" " *ecdsa.PrivateKey) ([]byte, error)"
.PP
MarshalECPrivateKey marshals an EC private key into ASN.1, DER format. 
.PP
.BR "func MarshalPKCS1PrivateKey(" "key" " *rsa.PrivateKey) []byte"
.PP
MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form. 
.PP
.BR "func MarshalPKIXPublicKey(" "pub" " interface{}) ([]byte, error)"
.PP
MarshalPKIXPublicKey serialises a public key to DER\-encoded PKIX format. 
.PP
.BR "func ParseCRL(" "crlBytes" " []byte) (" "certList" " *pkix.CertificateList, " "err" " error)"
.PP
ParseCRL parses a CRL from the given bytes. 
It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage. 
.PP
.BR "func ParseCertificates(" "asn1Data" " []byte) ([]*Certificate, error)"
.PP
ParseCertificates parses one or more certificates from the given ASN.1 DER data. 
The certificates must be concatenated with no intermediate padding. 
.PP
.BR "func ParseDERCRL(" "derBytes" " []byte) (" "certList" " *pkix.CertificateList, " "err" " error)"
.PP
ParseDERCRL parses a DER encoded CRL from the given bytes. 
.PP
.BR "func ParseECPrivateKey(" "der" " []byte) (" "key" " *ecdsa.PrivateKey, " "err" " error)"
.PP
ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure. 
.PP
.BR "func ParsePKCS1PrivateKey(" "der" " []byte) (" "key" " *rsa.PrivateKey, " "err" " error)"
.PP
ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form. 
.PP
.BR "func ParsePKCS8PrivateKey(" "der" " []byte) (" "key" " interface{}, " "err" " error)"
.PP
ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key. 
See http://www.rsa.com/rsalabs/node.asp?id=2130 and RFC5208. 
.PP
.BR "func ParsePKIXPublicKey(" "derBytes" " []byte) (" "pub" " interface{}, " "err" " error)"
.PP
ParsePKIXPublicKey parses a DER encoded public key. 
These values are typically found in PEM blocks with "BEGIN PUBLIC KEY". 
.SH "TYPES"
.SS "CertPool"
.B type CertPool struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
CertPool is a set of certificates. 
.PP
.B var (
.RS
.B 
.sp 0
.B 
.sp 0
.RE
.B )
.PP
.BR "func NewCertPool() *CertPool"
.PP
NewCertPool returns a new, empty CertPool. 
.PP
.BR "func (*CertPool) AddCert(" "cert" " *Certificate)"
.PP
AddCert adds a certificate to a pool. 
.PP
.BR "func (*CertPool) AppendCertsFromPEM(" "pemCerts" " []byte) (" "ok" " bool)"
.PP
AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. 
It appends any certificates found to s and returns true if any certificates were successfully parsed. 
.PP
On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function. 
.PP
.BR "func (*CertPool) Subjects() (" "res" " [][]byte)"
.PP
Subjects returns a list of the DER\-encoded subjects of all of the certificates in the pool. 
.SS "Certificate"
.B type Certificate struct {
.RS
.B Raw []byte
.sp 0
.B RawTBSCertificate []byte
.sp 0
.B RawSubjectPublicKeyInfo []byte
.sp 0
.B RawSubject []byte
.sp 0
.B RawIssuer []byte
.sp 0
.B Signature []byte
.sp 0
.B SignatureAlgorithm SignatureAlgorithm
.sp 0
.B PublicKeyAlgorithm PublicKeyAlgorithm
.sp 0
.B PublicKey interface{}
.sp 0
.B Version int
.sp 0
.B SerialNumber *big.Int
.sp 0
.B Issuer pkix.Name
.sp 0
.B Subject pkix.Name
.sp 0
.B NotBefore, NotAfter time.Time
.sp 0
.B KeyUsage KeyUsage
.sp 0
.B Extensions []pkix.Extension
.sp 0
.B ExtraExtensions []pkix.Extension
.sp 0
.B ExtKeyUsage []ExtKeyUsage
.sp 0
.B UnknownExtKeyUsage []asn1.ObjectIdentifier
.sp 0
.B BasicConstraintsValid bool
.sp 0
.B IsCA bool
.sp 0
.B MaxPathLen int
.sp 0
.B SubjectKeyId []byte
.sp 0
.B AuthorityKeyId []byte
.sp 0
.B OCSPServer []string
.sp 0
.B IssuingCertificateURL []string
.sp 0
.B DNSNames []string
.sp 0
.B EmailAddresses []string
.sp 0
.B IPAddresses []net.IP
.sp 0
.B PermittedDNSDomainsCritical bool
.sp 0
.B PermittedDNSDomains []string
.sp 0
.B CRLDistributionPoints []string
.sp 0
.B PolicyIdentifiers []asn1.ObjectIdentifier
.RE
.B }
.PP
A Certificate represents an X.509 certificate. 
.PP
.BR "func ParseCertificate(" "asn1Data" " []byte) (*Certificate, error)"
.PP
ParseCertificate parses a single certificate from the given ASN.1 DER data. 
.PP
.BR "func (*Certificate) CheckCRLSignature(" "crl" " *pkix.CertificateList) (" "err" " error)"
.PP
CheckCRLSignature checks that the signature in crl is from c. 
.PP
.BR "func (*Certificate) CheckSignature(" "algo" " SignatureAlgorithm, " "signed" ", " "signature" " []byte) (" "err" " error)"
.PP
CheckSignature verifies that signature is a valid signature over signed from c's public key. 
.PP
.BR "func (*Certificate) CheckSignatureFrom(" "parent" " *Certificate) (" "err" " error)"
.PP
CheckSignatureFrom verifies that the signature on c is a valid signature from parent. 
.PP
.BR "func (*Certificate) CreateCRL(" "rand" " io.Reader, " "priv" " interface{}, " "revokedCerts" " []pkix.RevokedCertificate, " "now" ", " "expiry" " time.Time) (" "crlBytes" " []byte, " "err" " error)"
.PP
CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates. 
.PP
The only supported key type is RSA (*rsa.PrivateKey for priv). 
.PP
.BR "func (*Certificate) Equal(" "other" " *Certificate) bool"
.PP
.BR "func (*Certificate) Verify(" "opts" " VerifyOptions) (" "chains" " [][]*Certificate, " "err" " error)"
.PP
Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. 
If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots. 
.PP
WARNING: this doesn't do any revocation checking. 
.PP
.BR "func (*Certificate) VerifyHostname(" "h" " string) error"
.PP
VerifyHostname returns nil if c is a valid certificate for the named host. 
Otherwise it returns an error describing the mismatch. 
.SS "CertificateInvalidError"
.B type CertificateInvalidError struct {
.RS
.B Cert *Certificate
.sp 0
.B Reason InvalidReason
.RE
.B }
.PP
CertificateInvalidError results when an odd error occurs. 
Users of this library probably want to handle all these errors uniformly. 
.PP
.BR "func (CertificateInvalidError) Error() string"
.SS "CertificateRequest"
.B type CertificateRequest struct {
.RS
.B Raw []byte
.sp 0
.B RawTBSCertificateRequest []byte
.sp 0
.B RawSubjectPublicKeyInfo []byte
.sp 0
.B RawSubject []byte
.sp 0
.B Version int
.sp 0
.B Signature []byte
.sp 0
.B SignatureAlgorithm SignatureAlgorithm
.sp 0
.B PublicKeyAlgorithm PublicKeyAlgorithm
.sp 0
.B PublicKey interface{}
.sp 0
.B Subject pkix.Name
.sp 0
.B Attributes []pkix.AttributeTypeAndValueSET
.sp 0
.B Extensions []pkix.Extension
.sp 0
.B ExtraExtensions []pkix.Extension
.sp 0
.B DNSNames []string
.sp 0
.B EmailAddresses []string
.sp 0
.B IPAddresses []net.IP
.RE
.B }
.PP
CertificateRequest represents a PKCS #10, certificate signature request. 
.PP
.BR "func ParseCertificateRequest(" "asn1Data" " []byte) (*CertificateRequest, error)"
.PP
ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data. 
.SS "ConstraintViolationError"
.B type ConstraintViolationError struct {
.RS
.RE
.B }
.PP
ConstraintViolationError results when a requested usage is not permitted by a certificate. 
For example: checking a signature when the public key isn't a certificate signing key. 
.PP
.BR "func (ConstraintViolationError) Error() string"
.SS "ExtKeyUsage"
.B type ExtKeyUsage int
.PP
ExtKeyUsage represents an extended set of actions that are valid for a given key. 
Each of the ExtKeyUsage* constants define a unique action. 
.PP
.B const (
.RS
.B ExtKeyUsageAny 
.sp 0
.B ExtKeyUsageServerAuth 
.sp 0
.B ExtKeyUsageClientAuth 
.sp 0
.B ExtKeyUsageCodeSigning 
.sp 0
.B ExtKeyUsageEmailProtection 
.sp 0
.B ExtKeyUsageIPSECEndSystem 
.sp 0
.B ExtKeyUsageIPSECTunnel 
.sp 0
.B ExtKeyUsageIPSECUser 
.sp 0
.B ExtKeyUsageTimeStamping 
.sp 0
.B ExtKeyUsageOCSPSigning 
.sp 0
.B ExtKeyUsageMicrosoftServerGatedCrypto 
.sp 0
.B ExtKeyUsageNetscapeServerGatedCrypto 
.sp 0
.RE
.B )
.SS "HostnameError"
.B type HostnameError struct {
.RS
.B Certificate *Certificate
.sp 0
.B Host string
.RE
.B }
.PP
HostnameError results when the set of authorized names doesn't match the requested name. 
.PP
.BR "func (HostnameError) Error() string"
.SS "InvalidReason"
.B type InvalidReason int
.PP
.PP
.B const (
.RS
.B NotAuthorizedToSign 
.sp 0
.B Expired 
.sp 0
.B CANotAuthorizedForThisName 
.sp 0
.B TooManyIntermediates 
.sp 0
.B IncompatibleUsage 
.sp 0
.RE
.B )
.SS "KeyUsage"
.B type KeyUsage int
.PP
KeyUsage represents the set of actions that are valid for a given key. 
It's a bitmap of the KeyUsage* constants. 
.PP
.B const (
.RS
.B KeyUsageDigitalSignature 
.sp 0
.B KeyUsageContentCommitment 
.sp 0
.B KeyUsageKeyEncipherment 
.sp 0
.B KeyUsageDataEncipherment 
.sp 0
.B KeyUsageKeyAgreement 
.sp 0
.B KeyUsageCertSign 
.sp 0
.B KeyUsageCRLSign 
.sp 0
.B KeyUsageEncipherOnly 
.sp 0
.B KeyUsageDecipherOnly 
.sp 0
.RE
.B )
.SS "PEMCipher"
.B type PEMCipher int
.PP
Possible values for the EncryptPEMBlock encryption algorithm. 
.PP
.B const (
.RS
.B 
.sp 0
.B PEMCipherDES 
.sp 0
.B PEMCipher3DES 
.sp 0
.B PEMCipherAES128 
.sp 0
.B PEMCipherAES192 
.sp 0
.B PEMCipherAES256 
.sp 0
.RE
.B )
.SS "PublicKeyAlgorithm"
.B type PublicKeyAlgorithm int
.PP
.PP
.B const (
.RS
.B UnknownPublicKeyAlgorithm 
.sp 0
.B RSA 
.sp 0
.B DSA 
.sp 0
.B ECDSA 
.sp 0
.RE
.B )
.SS "SignatureAlgorithm"
.B type SignatureAlgorithm int
.PP
.PP
.B const (
.RS
.B UnknownSignatureAlgorithm 
.sp 0
.B MD2WithRSA 
.sp 0
.B MD5WithRSA 
.sp 0
.B SHA1WithRSA 
.sp 0
.B SHA256WithRSA 
.sp 0
.B SHA384WithRSA 
.sp 0
.B SHA512WithRSA 
.sp 0
.B DSAWithSHA1 
.sp 0
.B DSAWithSHA256 
.sp 0
.B ECDSAWithSHA1 
.sp 0
.B ECDSAWithSHA256 
.sp 0
.B ECDSAWithSHA384 
.sp 0
.B ECDSAWithSHA512 
.sp 0
.RE
.B )
.SS "SystemRootsError"
.B type SystemRootsError struct {
.RS
.RE
.B }
.PP
SystemRootsError results when we fail to load the system root certificates. 
.PP
.BR "func (SystemRootsError) Error() string"
.SS "UnhandledCriticalExtension"
.B type UnhandledCriticalExtension struct {
.RS
.RE
.B }
.PP
.PP
.BR "func (UnhandledCriticalExtension) Error() string"
.SS "UnknownAuthorityError"
.B type UnknownAuthorityError struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
UnknownAuthorityError results when the certificate issuer is unknown    
.PP
.BR "func (UnknownAuthorityError) Error() string"
.SS "VerifyOptions"
.B type VerifyOptions struct {
.RS
.B DNSName string
.sp 0
.B Intermediates *CertPool
.sp 0
.B Roots *CertPool
.sp 0
.B CurrentTime time.Time
.sp 0
.B KeyUsages []ExtKeyUsage
.RE
.B }
.PP
VerifyOptions contains parameters for Certificate.Verify. 
It's a structure because other PKIX verification APIs have ended up needing many options. 
.SS "authKeyId"
.B type authKeyId struct {
.RS
.B Id []byte
.RE
.B }
.PP
RFC 5280, 4.2.1.1    
.SS "authorityInfoAccess"
.B type authorityInfoAccess struct {
.RS
.B Method asn1.ObjectIdentifier
.sp 0
.B Location asn1.RawValue
.RE
.B }
.PP
RFC 5280, 4.2.2.1    
.SS "basicConstraints"
.B type basicConstraints struct {
.RS
.B IsCA bool
.sp 0
.B MaxPathLen int
.RE
.B }
.SS "certificate"
.B type certificate struct {
.RS
.B Raw asn1.RawContent
.sp 0
.B TBSCertificate tbsCertificate
.sp 0
.B SignatureAlgorithm pkix.AlgorithmIdentifier
.sp 0
.B SignatureValue asn1.BitString
.RE
.B }
.SS "certificateRequest"
.B type certificateRequest struct {
.RS
.B Raw asn1.RawContent
.sp 0
.B TBSCSR tbsCertificateRequest
.sp 0
.B SignatureAlgorithm pkix.AlgorithmIdentifier
.sp 0
.B SignatureValue asn1.BitString
.RE
.B }
.SS "distributionPoint"
.B type distributionPoint struct {
.RS
.B DistributionPoint distributionPointName
.sp 0
.B Reason asn1.BitString
.sp 0
.B CRLIssuer asn1.RawValue
.RE
.B }
.PP
RFC 5280, 4.2.1.14    
.SS "distributionPointName"
.B type distributionPointName struct {
.RS
.B FullName asn1.RawValue
.sp 0
.B RelativeName pkix.RDNSequence
.RE
.B }
.SS "dsaAlgorithmParameters"
.B type dsaAlgorithmParameters struct {
.RS
.B P, Q, G *big.Int
.RE
.B }
.SS "dsaSignature"
.B type dsaSignature struct {
.RS
.B R, S *big.Int
.RE
.B }
.SS "ecPrivateKey"
.B type ecPrivateKey struct {
.RS
.B Version int
.sp 0
.B PrivateKey []byte
.sp 0
.B NamedCurveOID asn1.ObjectIdentifier
.sp 0
.B PublicKey asn1.BitString
.RE
.B }
.PP
ecPrivateKey reflects an ASN.1 Elliptic Curve Private Key Structure. 
References: RFC5915 SEC1 
.B \-
http://www.secg.org/download/aid\-780/sec1\-v2.pdf Per RFC5915 the NamedCurveOID is marked as ASN.1 OPTIONAL, however in most cases it is not. 
.SS "generalSubtree"
.B type generalSubtree struct {
.RS
.B Name string
.RE
.B }
.SS "nameConstraints"
.B type nameConstraints struct {
.RS
.B Permitted []generalSubtree
.sp 0
.B Excluded []generalSubtree
.RE
.B }
.PP
RFC 5280, 4.2.1.10    
.SS "pkcs1AdditionalRSAPrime"
.B type pkcs1AdditionalRSAPrime struct {
.RS
.B Prime *big.Int
.sp 0
.B Exp *big.Int
.sp 0
.B Coeff *big.Int
.RE
.B }
.SS "pkcs1PrivateKey"
.B type pkcs1PrivateKey struct {
.RS
.B Version int
.sp 0
.B N *big.Int
.sp 0
.B E int
.sp 0
.B D *big.Int
.sp 0
.B P *big.Int
.sp 0
.B Q *big.Int
.sp 0
.B Dp *big.Int
.sp 0
.B Dq *big.Int
.sp 0
.B Qinv *big.Int
.sp 0
.B AdditionalPrimes []pkcs1AdditionalRSAPrime
.RE
.B }
.PP
pkcs1PrivateKey is a structure which mirrors the PKCS#1 ASN.1 for an RSA private key. 
.SS "pkcs8"
.B type pkcs8 struct {
.RS
.B Version int
.sp 0
.B Algo pkix.AlgorithmIdentifier
.sp 0
.B PrivateKey []byte
.RE
.B }
.PP
pkcs8 reflects an ASN.1, PKCS#8 PrivateKey. 
See ftp://ftp.rsasecurity.com/pub/pkcs/pkcs\-8/pkcs\-8v1_2.asn and RFC5208. 
.SS "pkixPublicKey"
.B type pkixPublicKey struct {
.RS
.B Algo pkix.AlgorithmIdentifier
.sp 0
.B BitString asn1.BitString
.RE
.B }
.PP
pkixPublicKey reflects a PKIX public key structure. 
See SubjectPublicKeyInfo in RFC 3280. 
.SS "policyInformation"
.B type policyInformation struct {
.RS
.B Policy asn1.ObjectIdentifier
.RE
.B }
.PP
RFC 5280 4.2.1.4    
.SS "publicKeyInfo"
.B type publicKeyInfo struct {
.RS
.B Raw asn1.RawContent
.sp 0
.B Algorithm pkix.AlgorithmIdentifier
.sp 0
.B PublicKey asn1.BitString
.RE
.B }
.SS "rsaPublicKey"
.B type rsaPublicKey struct {
.RS
.B N *big.Int
.sp 0
.B E int
.RE
.B }
.PP
rsaPublicKey reflects the ASN.1 structure of a PKCS#1 public key. 
.SS "tbsCertificate"
.B type tbsCertificate struct {
.RS
.B Raw asn1.RawContent
.sp 0
.B Version int
.sp 0
.B SerialNumber *big.Int
.sp 0
.B SignatureAlgorithm pkix.AlgorithmIdentifier
.sp 0
.B Issuer asn1.RawValue
.sp 0
.B Validity validity
.sp 0
.B Subject asn1.RawValue
.sp 0
.B PublicKey publicKeyInfo
.sp 0
.B UniqueId asn1.BitString
.sp 0
.B SubjectUniqueId asn1.BitString
.sp 0
.B Extensions []pkix.Extension
.RE
.B }
.SS "tbsCertificateRequest"
.B type tbsCertificateRequest struct {
.RS
.B Raw asn1.RawContent
.sp 0
.B Version int
.sp 0
.B Subject asn1.RawValue
.sp 0
.B PublicKey publicKeyInfo
.sp 0
.B Attributes []pkix.AttributeTypeAndValueSET
.RE
.B }
.SS "validity"
.B type validity struct {
.RS
.B NotBefore, NotAfter time.Time
.RE
.B }
