.\"    Automatically generated by mango(1)
.TH "utf8" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
utf8 \- Package utf8 implements functions and constants to support text encoded in
UTF-8.
.SH "SYNOPSIS"
.B import \*(lqutf8\(rq
.sp
.B Constants
.sp 0
.RB "func " DecodeLastRune
.sp 0
.RB "func " DecodeLastRuneInString
.sp 0
.RB "func " DecodeRune
.sp 0
.RB "func " DecodeRuneInString
.sp 0
.RB "func " EncodeRune
.sp 0
.RB "func " FullRune
.sp 0
.RB "func " FullRuneInString
.sp 0
.RB "func " RuneCount
.sp 0
.RB "func " RuneCountInString
.sp 0
.RB "func " RuneLen
.sp 0
.RB "func " RuneStart
.sp 0
.RB "func " Valid
.sp 0
.RB "func " ValidRune
.sp 0
.RB "func " ValidString
.sp 0
.SH "DESCRIPTION"
Package utf8 implements functions and constants to support text encoded in UTF\-8. 
It includes functions to translate between runes and UTF\-8 byte sequences. 
.SH "CONSTANTS"
Numbers fundamental to the encoding. 
.PP
.B const (
.RS
.B RuneError 
.sp 0
.B RuneSelf 
.sp 0
.B MaxRune 
.sp 0
.B UTFMax 
.sp 0
.RE
.B )
.SH "FUNCTIONS"
.PP
.BR "func DecodeLastRune(" "p" " []byte) (" "r" " rune, " "size" " int)"
.PP
DecodeLastRune unpacks the last UTF\-8 encoding in p and returns the rune and its width in bytes. 
If the encoding is invalid, it returns (RuneError, 1), an impossible result for correct UTF\-8. 
An encoding is invalid if it is incorrect UTF\-8, encodes a rune that is out of range, or is not the shortest possible UTF\-8 encoding for the value. 
No other validation is performed. 
.PP
.BR "func DecodeLastRuneInString(" "s" " string) (" "r" " rune, " "size" " int)"
.PP
DecodeLastRuneInString is like DecodeLastRune but its input is a string. 
If the encoding is invalid, it returns (RuneError, 1), an impossible result for correct UTF\-8. 
An encoding is invalid if it is incorrect UTF\-8, encodes a rune that is out of range, or is not the shortest possible UTF\-8 encoding for the value. 
No other validation is performed. 
.PP
.BR "func DecodeRune(" "p" " []byte) (" "r" " rune, " "size" " int)"
.PP
DecodeRune unpacks the first UTF\-8 encoding in p and returns the rune and its width in bytes. 
If the encoding is invalid, it returns (RuneError, 1), an impossible result for correct UTF\-8. 
An encoding is invalid if it is incorrect UTF\-8, encodes a rune that is out of range, or is not the shortest possible UTF\-8 encoding for the value. 
No other validation is performed. 
.PP
.BR "func DecodeRuneInString(" "s" " string) (" "r" " rune, " "size" " int)"
.PP
DecodeRuneInString is like DecodeRune but its input is a string. 
If the encoding is invalid, it returns (RuneError, 1), an impossible result for correct UTF\-8. 
An encoding is invalid if it is incorrect UTF\-8, encodes a rune that is out of range, or is not the shortest possible UTF\-8 encoding for the value. 
No other validation is performed. 
.PP
.BR "func EncodeRune(" "p" " []byte, " "r" " rune) int"
.PP
EncodeRune writes into p (which must be large enough) the UTF\-8 encoding of the rune. 
It returns the number of bytes written. 
.PP
.BR "func FullRune(" "p" " []byte) bool"
.PP
FullRune reports whether the bytes in p begin with a full UTF\-8 encoding of a rune. 
An invalid encoding is considered a full Rune since it will convert as a width\-1 error rune. 
.PP
.BR "func FullRuneInString(" "s" " string) bool"
.PP
FullRuneInString is like FullRune but its input is a string. 
.PP
.BR "func RuneCount(" "p" " []byte) int"
.PP
RuneCount returns the number of runes in p. 
Erroneous and short encodings are treated as single runes of width 1 byte. 
.PP
.BR "func RuneCountInString(" "s" " string) (" "n" " int)"
.PP
RuneCountInString is like RuneCount but its input is a string. 
.PP
.BR "func RuneLen(" "r" " rune) int"
.PP
RuneLen returns the number of bytes required to encode the rune. 
It returns 
.B \-1
if the rune is not a valid value to encode in UTF\-8. 
.PP
.BR "func RuneStart(" "b" " byte) bool"
.PP
RuneStart reports whether the byte could be the first byte of an encoded rune. 
Second and subsequent bytes always have the top two bits set to 10. 
.PP
.BR "func Valid(" "p" " []byte) bool"
.PP
Valid reports whether p consists entirely of valid UTF\-8\-encoded runes. 
.PP
.BR "func ValidRune(" "r" " rune) bool"
.PP
ValidRune reports whether r can be legally encoded as UTF\-8. 
Code points that are out of range or a surrogate half are illegal. 
.PP
.BR "func ValidString(" "s" " string) bool"
.PP
ValidString reports whether s consists entirely of valid UTF\-8\-encoded runes. 
