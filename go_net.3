.\"    Automatically generated by mango(1)
.TH "net" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
net \- Package net provides a portable interface for network I/O, including
TCP/IP, UDP, domain name resolution, and Unix domain sockets.
.SH "SYNOPSIS"
.B import \*(lqnet\(rq
.sp
.B Constants
.sp 0
.B Variables
.sp 0
.RB "func " InterfaceAddrs
.sp 0
.RB "func " Interfaces
.sp 0
.RB "func " JoinHostPort
.sp 0
.RB "func " LookupAddr
.sp 0
.RB "func " LookupCNAME
.sp 0
.RB "func " LookupHost
.sp 0
.RB "func " LookupIP
.sp 0
.RB "func " LookupMX
.sp 0
.RB "func " LookupNS
.sp 0
.RB "func " LookupPort
.sp 0
.RB "func " LookupSRV
.sp 0
.RB "func " LookupTXT
.sp 0
.RB "func " SplitHostPort
.sp 0
.RB "type " Addr
.sp 0
.RS
.RE
.RB "type " AddrError
.sp 0
.RS
.RB "func (*AddrError) " Error
.sp 0
.RB "func (*AddrError) " Temporary
.sp 0
.RB "func (*AddrError) " Timeout
.sp 0
.RE
.RB "type " Conn
.sp 0
.RS
.RB "func " Dial
.sp 0
.RB "func " DialTimeout
.sp 0
.RB "func " FileConn
.sp 0
.RB "func " Pipe
.sp 0
.RE
.RB "type " DNSConfigError
.sp 0
.RS
.RB "func (*DNSConfigError) " Error
.sp 0
.RB "func (*DNSConfigError) " Temporary
.sp 0
.RB "func (*DNSConfigError) " Timeout
.sp 0
.RE
.RB "type " DNSError
.sp 0
.RS
.RB "func (*DNSError) " Error
.sp 0
.RB "func (*DNSError) " Temporary
.sp 0
.RB "func (*DNSError) " Timeout
.sp 0
.RE
.RB "type " Dialer
.sp 0
.RS
.RB "func (*Dialer) " Dial
.sp 0
.RE
.RB "type " Error
.sp 0
.RB "type " Flags
.sp 0
.RS
.RB "func (Flags) " String
.sp 0
.RE
.RB "type " HardwareAddr
.sp 0
.RS
.RB "func " ParseMAC
.sp 0
.RB "func (HardwareAddr) " String
.sp 0
.RE
.RB "type " IP
.sp 0
.RS
.RB "func " IPv4
.sp 0
.RB "func " ParseCIDR
.sp 0
.RB "func " ParseIP
.sp 0
.RB "func (IP) " DefaultMask
.sp 0
.RB "func (IP) " Equal
.sp 0
.RB "func (IP) " IsGlobalUnicast
.sp 0
.RB "func (IP) " IsInterfaceLocalMulticast
.sp 0
.RB "func (IP) " IsLinkLocalMulticast
.sp 0
.RB "func (IP) " IsLinkLocalUnicast
.sp 0
.RB "func (IP) " IsLoopback
.sp 0
.RB "func (IP) " IsMulticast
.sp 0
.RB "func (IP) " IsUnspecified
.sp 0
.RB "func (IP) " MarshalText
.sp 0
.RB "func (IP) " Mask
.sp 0
.RB "func (IP) " String
.sp 0
.RB "func (IP) " To16
.sp 0
.RB "func (IP) " To4
.sp 0
.RB "func (*IP) " UnmarshalText
.sp 0
.RE
.RB "type " IPAddr
.sp 0
.RS
.RB "func " ResolveIPAddr
.sp 0
.RB "func (*IPAddr) " Network
.sp 0
.RB "func (*IPAddr) " String
.sp 0
.RE
.RB "type " IPConn
.sp 0
.RS
.RB "func " DialIP
.sp 0
.RB "func " ListenIP
.sp 0
.RB "func (*IPConn) " Close
.sp 0
.RB "func (*IPConn) " File
.sp 0
.RB "func (*IPConn) " LocalAddr
.sp 0
.RB "func (*IPConn) " Read
.sp 0
.RB "func (*IPConn) " ReadFrom
.sp 0
.RB "func (*IPConn) " ReadFromIP
.sp 0
.RB "func (*IPConn) " ReadMsgIP
.sp 0
.RB "func (*IPConn) " RemoteAddr
.sp 0
.RB "func (*IPConn) " SetDeadline
.sp 0
.RB "func (*IPConn) " SetReadBuffer
.sp 0
.RB "func (*IPConn) " SetReadDeadline
.sp 0
.RB "func (*IPConn) " SetWriteBuffer
.sp 0
.RB "func (*IPConn) " SetWriteDeadline
.sp 0
.RB "func (*IPConn) " Write
.sp 0
.RB "func (*IPConn) " WriteMsgIP
.sp 0
.RB "func (*IPConn) " WriteTo
.sp 0
.RB "func (*IPConn) " WriteToIP
.sp 0
.RE
.RB "type " IPMask
.sp 0
.RS
.RB "func " CIDRMask
.sp 0
.RB "func " IPv4Mask
.sp 0
.RB "func (IPMask) " Size
.sp 0
.RB "func (IPMask) " String
.sp 0
.RE
.RB "type " IPNet
.sp 0
.RS
.RB "func (*IPNet) " Contains
.sp 0
.RB "func (*IPNet) " Network
.sp 0
.RB "func (*IPNet) " String
.sp 0
.RE
.RB "type " Interface
.sp 0
.RS
.RB "func " InterfaceByIndex
.sp 0
.RB "func " InterfaceByName
.sp 0
.RB "func (*Interface) " Addrs
.sp 0
.RB "func (*Interface) " MulticastAddrs
.sp 0
.RE
.RB "type " InvalidAddrError
.sp 0
.RS
.RB "func (InvalidAddrError) " Error
.sp 0
.RB "func (InvalidAddrError) " Temporary
.sp 0
.RB "func (InvalidAddrError) " Timeout
.sp 0
.RE
.RB "type " Listener
.sp 0
.RS
.RB "func " FileListener
.sp 0
.RB "func " Listen
.sp 0
.RE
.RB "type " MX
.sp 0
.RB "type " NS
.sp 0
.RB "type " OpError
.sp 0
.RS
.RB "func (*OpError) " Error
.sp 0
.RB "func (*OpError) " Temporary
.sp 0
.RB "func (*OpError) " Timeout
.sp 0
.RE
.RB "type " PacketConn
.sp 0
.RS
.RB "func " FilePacketConn
.sp 0
.RB "func " ListenPacket
.sp 0
.RE
.RB "type " ParseError
.sp 0
.RS
.RB "func (*ParseError) " Error
.sp 0
.RE
.RB "type " SRV
.sp 0
.RB "type " TCPAddr
.sp 0
.RS
.RB "func " ResolveTCPAddr
.sp 0
.RB "func (*TCPAddr) " Network
.sp 0
.RB "func (*TCPAddr) " String
.sp 0
.RE
.RB "type " TCPConn
.sp 0
.RS
.RB "func " DialTCP
.sp 0
.RB "func (*TCPConn) " Close
.sp 0
.RB "func (*TCPConn) " CloseRead
.sp 0
.RB "func (*TCPConn) " CloseWrite
.sp 0
.RB "func (*TCPConn) " File
.sp 0
.RB "func (*TCPConn) " LocalAddr
.sp 0
.RB "func (*TCPConn) " Read
.sp 0
.RB "func (*TCPConn) " ReadFrom
.sp 0
.RB "func (*TCPConn) " RemoteAddr
.sp 0
.RB "func (*TCPConn) " SetDeadline
.sp 0
.RB "func (*TCPConn) " SetKeepAlive
.sp 0
.RB "func (*TCPConn) " SetKeepAlivePeriod
.sp 0
.RB "func (*TCPConn) " SetLinger
.sp 0
.RB "func (*TCPConn) " SetNoDelay
.sp 0
.RB "func (*TCPConn) " SetReadBuffer
.sp 0
.RB "func (*TCPConn) " SetReadDeadline
.sp 0
.RB "func (*TCPConn) " SetWriteBuffer
.sp 0
.RB "func (*TCPConn) " SetWriteDeadline
.sp 0
.RB "func (*TCPConn) " Write
.sp 0
.RE
.RB "type " TCPListener
.sp 0
.RS
.RB "func " ListenTCP
.sp 0
.RB "func (*TCPListener) " Accept
.sp 0
.RB "func (*TCPListener) " AcceptTCP
.sp 0
.RB "func (*TCPListener) " Addr
.sp 0
.RB "func (*TCPListener) " Close
.sp 0
.RB "func (*TCPListener) " File
.sp 0
.RB "func (*TCPListener) " SetDeadline
.sp 0
.RE
.RB "type " UDPAddr
.sp 0
.RS
.RB "func " ResolveUDPAddr
.sp 0
.RB "func (*UDPAddr) " Network
.sp 0
.RB "func (*UDPAddr) " String
.sp 0
.RE
.RB "type " UDPConn
.sp 0
.RS
.RB "func " DialUDP
.sp 0
.RB "func " ListenMulticastUDP
.sp 0
.RB "func " ListenUDP
.sp 0
.RB "func (*UDPConn) " Close
.sp 0
.RB "func (*UDPConn) " File
.sp 0
.RB "func (*UDPConn) " LocalAddr
.sp 0
.RB "func (*UDPConn) " Read
.sp 0
.RB "func (*UDPConn) " ReadFrom
.sp 0
.RB "func (*UDPConn) " ReadFromUDP
.sp 0
.RB "func (*UDPConn) " ReadMsgUDP
.sp 0
.RB "func (*UDPConn) " RemoteAddr
.sp 0
.RB "func (*UDPConn) " SetDeadline
.sp 0
.RB "func (*UDPConn) " SetReadBuffer
.sp 0
.RB "func (*UDPConn) " SetReadDeadline
.sp 0
.RB "func (*UDPConn) " SetWriteBuffer
.sp 0
.RB "func (*UDPConn) " SetWriteDeadline
.sp 0
.RB "func (*UDPConn) " Write
.sp 0
.RB "func (*UDPConn) " WriteMsgUDP
.sp 0
.RB "func (*UDPConn) " WriteTo
.sp 0
.RB "func (*UDPConn) " WriteToUDP
.sp 0
.RE
.RB "type " UnixAddr
.sp 0
.RS
.RB "func " ResolveUnixAddr
.sp 0
.RB "func (*UnixAddr) " Network
.sp 0
.RB "func (*UnixAddr) " String
.sp 0
.RE
.RB "type " UnixConn
.sp 0
.RS
.RB "func " DialUnix
.sp 0
.RB "func " ListenUnixgram
.sp 0
.RB "func (*UnixConn) " Close
.sp 0
.RB "func (*UnixConn) " CloseRead
.sp 0
.RB "func (*UnixConn) " CloseWrite
.sp 0
.RB "func (*UnixConn) " File
.sp 0
.RB "func (*UnixConn) " LocalAddr
.sp 0
.RB "func (*UnixConn) " Read
.sp 0
.RB "func (*UnixConn) " ReadFrom
.sp 0
.RB "func (*UnixConn) " ReadFromUnix
.sp 0
.RB "func (*UnixConn) " ReadMsgUnix
.sp 0
.RB "func (*UnixConn) " RemoteAddr
.sp 0
.RB "func (*UnixConn) " SetDeadline
.sp 0
.RB "func (*UnixConn) " SetReadBuffer
.sp 0
.RB "func (*UnixConn) " SetReadDeadline
.sp 0
.RB "func (*UnixConn) " SetWriteBuffer
.sp 0
.RB "func (*UnixConn) " SetWriteDeadline
.sp 0
.RB "func (*UnixConn) " Write
.sp 0
.RB "func (*UnixConn) " WriteMsgUnix
.sp 0
.RB "func (*UnixConn) " WriteTo
.sp 0
.RB "func (*UnixConn) " WriteToUnix
.sp 0
.RE
.RB "type " UnixListener
.sp 0
.RS
.RB "func " ListenUnix
.sp 0
.RB "func (*UnixListener) " Accept
.sp 0
.RB "func (*UnixListener) " AcceptUnix
.sp 0
.RB "func (*UnixListener) " Addr
.sp 0
.RB "func (*UnixListener) " Close
.sp 0
.RB "func (*UnixListener) " File
.sp 0
.RB "func (*UnixListener) " SetDeadline
.sp 0
.RE
.RB "type " UnknownNetworkError
.sp 0
.RS
.RB "func (UnknownNetworkError) " Error
.sp 0
.RB "func (UnknownNetworkError) " Temporary
.sp 0
.RB "func (UnknownNetworkError) " Timeout
.sp 0
.RE
.RB "type " byPref
.sp 0
.RS
.RB "func (byPref) " Len
.sp 0
.RB "func (byPref) " Less
.sp 0
.RB "func (byPref) " Swap
.sp 0
.RE
.RB "type " byPriorityWeight
.sp 0
.RS
.RB "func (byPriorityWeight) " Len
.sp 0
.RB "func (byPriorityWeight) " Less
.sp 0
.RB "func (byPriorityWeight) " Swap
.sp 0
.RE
.RB "type " conn
.sp 0
.RS
.RB "func (*conn) " Close
.sp 0
.RB "func (*conn) " File
.sp 0
.RB "func (*conn) " LocalAddr
.sp 0
.RB "func (*conn) " Read
.sp 0
.RB "func (*conn) " RemoteAddr
.sp 0
.RB "func (*conn) " SetDeadline
.sp 0
.RB "func (*conn) " SetReadBuffer
.sp 0
.RB "func (*conn) " SetReadDeadline
.sp 0
.RB "func (*conn) " SetWriteBuffer
.sp 0
.RB "func (*conn) " SetWriteDeadline
.sp 0
.RB "func (*conn) " Write
.sp 0
.RE
.RB "type " dnsHeader
.sp 0
.RS
.RB "func (*dnsHeader) " Walk
.sp 0
.RE
.RB "type " dnsMsg
.sp 0
.RS
.RB "func (*dnsMsg) " Pack
.sp 0
.RB "func (*dnsMsg) " String
.sp 0
.RB "func (*dnsMsg) " Unpack
.sp 0
.RB "func (*dnsMsg) " Walk
.sp 0
.RE
.RB "type " dnsMsgHdr
.sp 0
.RS
.RB "func (*dnsMsgHdr) " Walk
.sp 0
.RE
.RB "type " dnsQuestion
.sp 0
.RS
.RB "func (*dnsQuestion) " Walk
.sp 0
.RE
.RB "type " dnsRR
.sp 0
.RS
.RE
.RB "type " dnsRR_A
.sp 0
.RS
.RB "func (*dnsRR_A) " Header
.sp 0
.RB "func (*dnsRR_A) " Walk
.sp 0
.RE
.RB "type " dnsRR_AAAA
.sp 0
.RS
.RB "func (*dnsRR_AAAA) " Header
.sp 0
.RB "func (*dnsRR_AAAA) " Walk
.sp 0
.RE
.RB "type " dnsRR_CNAME
.sp 0
.RS
.RB "func (*dnsRR_CNAME) " Header
.sp 0
.RB "func (*dnsRR_CNAME) " Walk
.sp 0
.RE
.RB "type " dnsRR_HINFO
.sp 0
.RS
.RB "func (*dnsRR_HINFO) " Header
.sp 0
.RB "func (*dnsRR_HINFO) " Walk
.sp 0
.RE
.RB "type " dnsRR_Header
.sp 0
.RS
.RB "func (*dnsRR_Header) " Header
.sp 0
.RB "func (*dnsRR_Header) " Walk
.sp 0
.RE
.RB "type " dnsRR_MB
.sp 0
.RS
.RB "func (*dnsRR_MB) " Header
.sp 0
.RB "func (*dnsRR_MB) " Walk
.sp 0
.RE
.RB "type " dnsRR_MG
.sp 0
.RS
.RB "func (*dnsRR_MG) " Header
.sp 0
.RB "func (*dnsRR_MG) " Walk
.sp 0
.RE
.RB "type " dnsRR_MINFO
.sp 0
.RS
.RB "func (*dnsRR_MINFO) " Header
.sp 0
.RB "func (*dnsRR_MINFO) " Walk
.sp 0
.RE
.RB "type " dnsRR_MR
.sp 0
.RS
.RB "func (*dnsRR_MR) " Header
.sp 0
.RB "func (*dnsRR_MR) " Walk
.sp 0
.RE
.RB "type " dnsRR_MX
.sp 0
.RS
.RB "func (*dnsRR_MX) " Header
.sp 0
.RB "func (*dnsRR_MX) " Walk
.sp 0
.RE
.RB "type " dnsRR_NS
.sp 0
.RS
.RB "func (*dnsRR_NS) " Header
.sp 0
.RB "func (*dnsRR_NS) " Walk
.sp 0
.RE
.RB "type " dnsRR_PTR
.sp 0
.RS
.RB "func (*dnsRR_PTR) " Header
.sp 0
.RB "func (*dnsRR_PTR) " Walk
.sp 0
.RE
.RB "type " dnsRR_SOA
.sp 0
.RS
.RB "func (*dnsRR_SOA) " Header
.sp 0
.RB "func (*dnsRR_SOA) " Walk
.sp 0
.RE
.RB "type " dnsRR_SRV
.sp 0
.RS
.RB "func (*dnsRR_SRV) " Header
.sp 0
.RB "func (*dnsRR_SRV) " Walk
.sp 0
.RE
.RB "type " dnsRR_TXT
.sp 0
.RS
.RB "func (*dnsRR_TXT) " Header
.sp 0
.RB "func (*dnsRR_TXT) " Walk
.sp 0
.RE
.RB "type " dnsStruct
.sp 0
.RB "type " fdMutex
.sp 0
.RS
.RB "func (*fdMutex) " Decref
.sp 0
.RB "func (*fdMutex) " Incref
.sp 0
.RB "func (*fdMutex) " IncrefAndClose
.sp 0
.RB "func (*fdMutex) " RWLock
.sp 0
.RB "func (*fdMutex) " RWUnlock
.sp 0
.RE
.RB "type " ioSrv
.sp 0
.RS
.RB "func (*ioSrv) " ExecIO
.sp 0
.RB "func (*ioSrv) " ProcessRemoteIO
.sp 0
.RE
.RB "type " netFD
.sp 0
.RS
.RB "func (*netFD) " Close
.sp 0
.RB "func (*netFD) " Read
.sp 0
.RB "func (*netFD) " Write
.sp 0
.RE
.RB "type " operation
.sp 0
.RS
.RB "func (*operation) " InitBuf
.sp 0
.RE
.RB "type " pipe
.sp 0
.RS
.RB "func (*pipe) " Close
.sp 0
.RB "func (*pipe) " LocalAddr
.sp 0
.RB "func (*pipe) " RemoteAddr
.sp 0
.RB "func (*pipe) " SetDeadline
.sp 0
.RB "func (*pipe) " SetReadDeadline
.sp 0
.RB "func (*pipe) " SetWriteDeadline
.sp 0
.RE
.RB "type " pipeAddr
.sp 0
.RS
.RB "func (pipeAddr) " Network
.sp 0
.RB "func (pipeAddr) " String
.sp 0
.RE
.RB "type " pollDesc
.sp 0
.RS
.RB "func (*pollDesc) " Close
.sp 0
.RB "func (*pollDesc) " Evict
.sp 0
.RB "func (*pollDesc) " Init
.sp 0
.RB "func (*pollDesc) " Lock
.sp 0
.RB "func (*pollDesc) " Prepare
.sp 0
.RB "func (*pollDesc) " PrepareRead
.sp 0
.RB "func (*pollDesc) " PrepareWrite
.sp 0
.RB "func (*pollDesc) " Unlock
.sp 0
.RB "func (*pollDesc) " Wait
.sp 0
.RB "func (*pollDesc) " WaitCanceled
.sp 0
.RB "func (*pollDesc) " WaitCanceledRead
.sp 0
.RB "func (*pollDesc) " WaitCanceledWrite
.sp 0
.RB "func (*pollDesc) " WaitRead
.sp 0
.RB "func (*pollDesc) " WaitWrite
.sp 0
.RB "func (*pollDesc) " Wakeup
.sp 0
.RE
.RB "type " singleflight
.sp 0
.RS
.RB "func (*singleflight) " Do
.sp 0
.RE
.RB "type " temporary
.sp 0
.RB "type " timeout
.sp 0
.RB "type " timeoutError
.sp 0
.RS
.RB "func (*timeoutError) " Error
.sp 0
.RB "func (*timeoutError) " Temporary
.sp 0
.RB "func (*timeoutError) " Timeout
.sp 0
.RE
.RB "type " udpHeader
.sp 0
.RS
.RB "func (*udpHeader) " Bytes
.sp 0
.RE
.SH "DESCRIPTION"
Although the package provides access to low\-level networking primitives, most clients will need only the basic interface provided by the Dial, Listen, and Accept functions and the associated Conn and Listener interfaces. 
The crypto/tls package uses the same interfaces and similar Dial and Listen functions. 
.PP
The Dial function connects to a server:    
.PP
.RS
conn, err := net.Dial("tcp", "google.com:80")
.sp 0
if err != nil {
.sp 0
.RS
// handle error
.sp 0
.RE
}
.sp 0
fmt.Fprintf(conn, "GET / HTTP/1.0\er\en\er\en")
.sp 0
status, err := bufio.NewReader(conn).ReadString('\en')
.sp 0
// \&...
.sp 0
.sp
.RE
.PP
The Listen function creates servers:    
.PP
.RS
ln, err := net.Listen("tcp", ":8080")
.sp 0
if err != nil {
.sp 0
.RS
// handle error
.sp 0
.RE
}
.sp 0
for {
.sp 0
.RS
conn, err := ln.Accept()
.sp 0
if err != nil {
.sp 0
.RS
// handle error
.sp 0
continue
.sp 0
.RE
}
.sp 0
go handleConnection(conn)
.sp 0
.RE
}
.RE
.SH "CONSTANTS"
IP address lengths (bytes). 
.PP
.B const (
.RS
.B IPv4len 
.sp 0
.B IPv6len 
.sp 0
.RE
.B )
.SH "VARIABLES"
Well\-known IPv4 addresses    
.PP
.B var (
.RS
.B IPv4bcast 
.sp 0
.B IPv4allsys 
.sp 0
.B IPv4allrouter 
.sp 0
.B IPv4zero 
.sp 0
.RE
.B )
.sp 0
Well\-known IPv6 addresses    
.PP
.B var (
.RS
.B IPv6zero 
.sp 0
.B IPv6unspecified 
.sp 0
.B IPv6loopback 
.sp 0
.B IPv6interfacelocalallnodes 
.sp 0
.B IPv6linklocalallnodes 
.sp 0
.B IPv6linklocalallrouters 
.sp 0
.RE
.B )
.sp 0
Various errors contained in OpError. 
.PP
.B var (
.RS
.B 
.sp 0
.B 
.sp 0
.B 
.sp 0
.B ErrWriteToConnected 
.sp 0
.RE
.B )
.SH "FUNCTIONS"
.PP
.BR "func InterfaceAddrs() ([]Addr, error)"
.PP
InterfaceAddrs returns a list of the system's network interface addresses. 
.PP
.BR "func Interfaces() ([]Interface, error)"
.PP
Interfaces returns a list of the system's network interfaces. 
.PP
.BR "func JoinHostPort(" "host" ", " "port" " string) string"
.PP
JoinHostPort combines host and port into a network address of the form "host:port" or, if host contains a colon or a percent sign, "[host]:port". 
.PP
.BR "func LookupAddr(" "addr" " string) (" "name" " []string, " "err" " error)"
.PP
LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. 
.PP
.BR "func LookupCNAME(" "name" " string) (" "cname" " string, " "err" " error)"
.PP
LookupCNAME returns the canonical DNS host for the given name. 
Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup. 
.PP
.BR "func LookupHost(" "host" " string) (" "addrs" " []string, " "err" " error)"
.PP
LookupHost looks up the given host using the local resolver. 
It returns an array of that host's addresses. 
.PP
.BR "func LookupIP(" "host" " string) (" "addrs" " []IP, " "err" " error)"
.PP
LookupIP looks up host using the local resolver. 
It returns an array of that host's IPv4 and IPv6 addresses. 
.PP
.BR "func LookupMX(" "name" " string) (" "mx" " []*MX, " "err" " error)"
.PP
LookupMX returns the DNS MX records for the given domain name sorted by preference. 
.PP
.BR "func LookupNS(" "name" " string) (" "ns" " []*NS, " "err" " error)"
.PP
LookupNS returns the DNS NS records for the given domain name. 
.PP
.BR "func LookupPort(" "network" ", " "service" " string) (" "port" " int, " "err" " error)"
.PP
LookupPort looks up the port for the given network and service. 
.PP
.BR "func LookupSRV(" "service" ", " "proto" ", " "name" " string) (" "cname" " string, " "addrs" " []*SRV, " "err" " error)"
.PP
LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. 
The proto is "tcp" or "udp". 
The returned records are sorted by priority and randomized by weight within a priority. 
.PP
LookupSRV constructs the DNS name to look up following RFC 2782. 
That is, it looks up _service._proto.name. 
To accommodate services publishing SRV records under non\-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. 
.PP
.BR "func LookupTXT(" "name" " string) (" "txt" " []string, " "err" " error)"
.PP
LookupTXT returns the DNS TXT records for the given domain name. 
.PP
.BR "func SplitHostPort(" "hostport" " string) (" "host" ", " "port" " string, " "err" " error)"
.PP
SplitHostPort splits a network address of the form "host:port", "[host]:port" or "[ipv6\-host%zone]:port" into host or ipv6\-host%zone and port. 
A literal address or host name for IPv6 must be enclosed in square brackets, as in "[::1]:80", "[ipv6\-host]:http" or "[ipv6\-host%zone]:80". 
.SH "TYPES"
.SS "Addr"
.B type Addr interface {
.RS
.B Network() string
.sp 0
.B String() string
.sp 0
.RE
.B }
.PP
Addr represents a network end point address. 
.SS "AddrError"
.B type AddrError struct {
.RS
.B Err string
.sp 0
.B Addr string
.RE
.B }
.PP
.PP
.BR "func (*AddrError) Error() string"
.PP
.BR "func (*AddrError) Temporary() bool"
.PP
.BR "func (*AddrError) Timeout() bool"
.SS "Conn"
.B type Conn interface {
.RS
.B Read(b []byte) (n int, err error)
.sp 0
.B Write(b []byte) (n int, err error)
.sp 0
.B Close() error
.sp 0
.B LocalAddr() Addr
.sp 0
.B RemoteAddr() Addr
.sp 0
.B SetDeadline(t time.Time) error
.sp 0
.B SetReadDeadline(t time.Time) error
.sp 0
.B SetWriteDeadline(t time.Time) error
.sp 0
.RE
.B }
.PP
Conn is a generic stream\-oriented network connection. 
.PP
Multiple goroutines may invoke methods on a Conn simultaneously. 
.PP
.BR "func Dial(" "network" ", " "address" " string) (Conn, error)"
.PP
Dial connects to the address on the named network. 
.PP
Known networks are "tcp", "tcp4" (IPv4\-only), "tcp6" (IPv6\-only), "udp", "udp4" (IPv4\-only), "udp6" (IPv6\-only), "ip", "ip4" (IPv4\-only), "ip6" (IPv6\-only), "unix", "unixgram" and "unixpacket". 
.PP
For TCP and UDP networks, addresses have the form host:port. 
If host is a literal IPv6 address or host name, it must be enclosed in square brackets as in "[::1]:80", "[ipv6\-host]:http" or "[ipv6\-host%zone]:80". 
The functions JoinHostPort and SplitHostPort manipulate addresses in this form. 
.PP
Examples:    
.PP
.RS
Dial("tcp", "12.34.56.78:80")
.sp 0
Dial("tcp", "google.com:http")
.sp 0
Dial("tcp", "[2001:db8::1]:http")
.sp 0
Dial("tcp", "[fe80::1%lo0]:80")
.sp 0
.sp
.RE
.PP
For IP networks, the network must be "ip", "ip4" or "ip6" followed by a colon and a protocol number or name and the addr must be a literal IP address. 
.PP
Examples:    
.PP
.RS
Dial("ip4:1", "127.0.0.1")
.sp 0
Dial("ip6:ospf", "::1")
.sp 0
.sp
.RE
.PP
For Unix networks, the address must be a file system path. 
.PP
.BR "func DialTimeout(" "network" ", " "address" " string, " "timeout" " time.Duration) (Conn, error)"
.PP
DialTimeout acts like Dial but takes a timeout. 
The timeout includes name resolution, if required. 
.PP
.BR "func FileConn(" "f" " *os.File) (" "c" " Conn, " "err" " error)"
.PP
FileConn returns a copy of the network connection corresponding to the open file f. 
It is the caller's responsibility to close f when finished. 
Closing c does not affect f, and closing f does not affect c. 
.PP
.BR "func Pipe() (Conn, Conn)"
.PP
Pipe creates a synchronous, in\-memory, full duplex network connection; both ends implement the Conn interface. 
Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering. 
.SS "DNSConfigError"
.B type DNSConfigError struct {
.RS
.B Err error
.RE
.B }
.PP
DNSConfigError represents an error reading the machine's DNS configuration. 
.PP
.BR "func (*DNSConfigError) Error() string"
.PP
.BR "func (*DNSConfigError) Temporary() bool"
.PP
.BR "func (*DNSConfigError) Timeout() bool"
.SS "DNSError"
.B type DNSError struct {
.RS
.B Err string
.sp 0
.B Name string
.sp 0
.B Server string
.sp 0
.B IsTimeout bool
.RE
.B }
.PP
DNSError represents a DNS lookup error. 
.PP
.BR "func (*DNSError) Error() string"
.PP
.BR "func (*DNSError) Temporary() bool"
.PP
.BR "func (*DNSError) Timeout() bool"
.SS "Dialer"
.B type Dialer struct {
.RS
.B Timeout time.Duration
.sp 0
.B Deadline time.Time
.sp 0
.B LocalAddr Addr
.sp 0
.B DualStack bool
.sp 0
.B KeepAlive time.Duration
.RE
.B }
.PP
A Dialer contains options for connecting to an address. 
.PP
The zero value for each field is equivalent to dialing without that option. 
Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function. 
.PP
.BR "func (*Dialer) Dial(" "network" ", " "address" " string) (Conn, error)"
.PP
Dial connects to the address on the named network. 
.PP
See func Dial for a description of the network and address parameters. 
.SS "Error"
.B type Error interface {
.RS
.B error
.sp 0
.B Timeout() bool
.sp 0
.B Temporary() bool
.sp 0
.RE
.B }
.PP
An Error represents a network error. 
.SS "Flags"
.B type Flags uint
.PP
.PP
.B const (
.RS
.B FlagUp 
.sp 0
.B FlagBroadcast 
.sp 0
.B FlagLoopback 
.sp 0
.B FlagPointToPoint 
.sp 0
.B FlagMulticast 
.sp 0
.RE
.B )
.PP
.BR "func (Flags) String() string"
.SS "HardwareAddr"
.B type HardwareAddr []byte
.PP
A HardwareAddr represents a physical hardware address. 
.PP
.BR "func ParseMAC(" "s" " string) (" "hw" " HardwareAddr, " "err" " error)"
.PP
ParseMAC parses s as an IEEE 802 MAC\-48, EUI\-48, or EUI\-64 using one of the following formats: 01:23:45:67:89:ab 01:23:45:67:89:ab:cd:ef 01\-23\-45\-67\-89\-ab 01\-23\-45\-67\-89\-ab\-cd\-ef 0123.4567.89ab 0123.4567.89ab.cdef 
.PP
.BR "func (HardwareAddr) String() string"
.SS "IP"
.B type IP []byte
.PP
An IP is a single IP address, a slice of bytes. 
Functions in this package accept either 4\-byte (IPv4) or 16\-byte (IPv6) slices as input. 
.PP
Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16\-byte slice can still be an IPv4 address. 
.PP
.BR "func IPv4(" "a" ", " "b" ", " "c" ", " "d" " byte) IP"
.PP
IPv4 returns the IP address (in 16\-byte form) of the IPv4 address a.b.c.d. 
.PP
.BR "func ParseCIDR(" "s" " string) (IP, *IPNet, error)"
.PP
ParseCIDR parses s as a CIDR notation IP address and mask, like "192.168.100.1/24" or "2001:DB8::/48", as defined in RFC 4632 and RFC 4291. 
.PP
It returns the IP address and the network implied by the IP and mask. 
For example, ParseCIDR("192.168.100.1/16") returns the IP address 192.168.100.1 and the network 192.168.0.0/16. 
.PP
.BR "func ParseIP(" "s" " string) IP"
.PP
ParseIP parses s as an IP address, returning the result. 
The string s can be in dotted decimal ("74.125.19.99") or IPv6 ("2001:4860:0:2001::68") form. 
If s is not a valid textual representation of an IP address, ParseIP returns nil. 
.PP
.BR "func (IP) DefaultMask() IPMask"
.PP
DefaultMask returns the default IP mask for the IP address ip. 
Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address. 
.PP
.BR "func (IP) Equal(" "x" " IP) bool"
.PP
Equal returns true if ip and x are the same IP address. 
An IPv4 address and that same address in IPv6 form are considered to be equal. 
.PP
.BR "func (IP) IsGlobalUnicast() bool"
.PP
IsGlobalUnicast returns true if ip is a global unicast address. 
.PP
.BR "func (IP) IsInterfaceLocalMulticast() bool"
.PP
IsInterfaceLinkLocalMulticast returns true if ip is an interface\-local multicast address. 
.PP
.BR "func (IP) IsLinkLocalMulticast() bool"
.PP
IsLinkLocalMulticast returns true if ip is a link\-local multicast address. 
.PP
.BR "func (IP) IsLinkLocalUnicast() bool"
.PP
IsLinkLocalUnicast returns true if ip is a link\-local unicast address. 
.PP
.BR "func (IP) IsLoopback() bool"
.PP
IsLoopback returns true if ip is a loopback address. 
.PP
.BR "func (IP) IsMulticast() bool"
.PP
IsMulticast returns true if ip is a multicast address. 
.PP
.BR "func (IP) IsUnspecified() bool"
.PP
IsUnspecified returns true if ip is an unspecified address. 
.PP
.BR "func (IP) MarshalText() ([]byte, error)"
.PP
MarshalText implements the encoding.TextMarshaler interface. 
The encoding is the same as returned by String. 
.PP
.BR "func (IP) Mask(" "mask" " IPMask) IP"
.PP
Mask returns the result of masking the IP address ip with mask. 
.PP
.BR "func (IP) String() string"
.PP
String returns the string form of the IP address ip. 
If the address is an IPv4 address, the string representation is dotted decimal ("74.125.19.99"). 
Otherwise the representation is IPv6 ("2001:4860:0:2001::68"). 
.PP
.BR "func (IP) To16() IP"
.PP
To16 converts the IP address ip to a 16\-byte representation. 
If ip is not an IP address (it is the wrong length), To16 returns nil. 
.PP
.BR "func (IP) To4() IP"
.PP
To4 converts the IPv4 address ip to a 4\-byte representation. 
If ip is not an IPv4 address, To4 returns nil. 
.PP
.BR "func (*IP) UnmarshalText(" "text" " []byte) error"
.PP
UnmarshalText implements the encoding.TextUnmarshaler interface. 
The IP address is expected in a form accepted by ParseIP. 
.SS "IPAddr"
.B type IPAddr struct {
.RS
.B IP IP
.sp 0
.B Zone string
.RE
.B }
.PP
IPAddr represents the address of an IP end point. 
.PP
.BR "func ResolveIPAddr(" "net" ", " "addr" " string) (*IPAddr, error)"
.PP
ResolveIPAddr parses addr as an IP address of the form "host" or "ipv6\-host%zone" and resolves the domain name on the network net, which must be "ip", "ip4" or "ip6". 
.PP
.BR "func (*IPAddr) Network() string"
.PP
Network returns the address's network name, "ip". 
.PP
.BR "func (*IPAddr) String() string"
.SS "IPConn"
.B type IPConn struct {
.RS
.RE
.B }
.PP
IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections. 
.PP
.BR "func DialIP(" "netProto" " string, " "laddr" ", " "raddr" " *IPAddr) (*IPConn, error)"
.PP
DialIP connects to the remote address raddr on the network protocol netProto, which must be "ip", "ip4", or "ip6" followed by a colon and a protocol number or name. 
.PP
.BR "func ListenIP(" "netProto" " string, " "laddr" " *IPAddr) (*IPConn, error)"
.PP
ListenIP listens for incoming IP packets addressed to the local address laddr. 
The returned connection's ReadFrom and WriteTo methods can be used to receive and send IP packets with per\-packet addressing. 
.PP
.BR "func (*IPConn) Close() error"
.PP
Close closes the connection. 
.PP
.BR "func (*IPConn) File() (" "f" " *os.File, " "err" " error)"
.PP
File sets the underlying os.File to blocking mode and returns a copy. 
It is the caller's responsibility to close f when finished. 
Closing c does not affect f, and closing f does not affect c. 
.PP
The returned os.File's file descriptor is different from the connection's. 
Attempting to change properties of the original using this duplicate may or may not have the desired effect. 
.PP
.BR "func (*IPConn) LocalAddr() Addr"
.PP
LocalAddr returns the local network address. 
.PP
.BR "func (*IPConn) Read(" "b" " []byte) (int, error)"
.PP
Read implements the Conn Read method. 
.PP
.BR "func (*IPConn) ReadFrom(" "b" " []byte) (int, Addr, error)"
.PP
ReadFrom implements the PacketConn ReadFrom method. 
.PP
.BR "func (*IPConn) ReadFromIP(" "b" " []byte) (int, *IPAddr, error)"
.PP
ReadFromIP reads an IP packet from c, copying the payload into b. 
It returns the number of bytes copied into b and the return address that was on the packet. 
.PP
ReadFromIP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. 
.PP
.BR "func (*IPConn) ReadMsgIP(" "b" ", " "oob" " []byte) (" "n" ", " "oobn" ", " "flags" " int, " "addr" " *IPAddr, " "err" " error)"
.PP
ReadMsgIP reads a packet from c, copying the payload into b and the associated out\-of\-band data into oob. 
It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet and the source address of the packet. 
.PP
.BR "func (*IPConn) RemoteAddr() Addr"
.PP
RemoteAddr returns the remote network address. 
.PP
.BR "func (*IPConn) SetDeadline(" "t" " time.Time) error"
.PP
SetDeadline implements the Conn SetDeadline method. 
.PP
.BR "func (*IPConn) SetReadBuffer(" "bytes" " int) error"
.PP
SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. 
.PP
.BR "func (*IPConn) SetReadDeadline(" "t" " time.Time) error"
.PP
SetReadDeadline implements the Conn SetReadDeadline method. 
.PP
.BR "func (*IPConn) SetWriteBuffer(" "bytes" " int) error"
.PP
SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. 
.PP
.BR "func (*IPConn) SetWriteDeadline(" "t" " time.Time) error"
.PP
SetWriteDeadline implements the Conn SetWriteDeadline method. 
.PP
.BR "func (*IPConn) Write(" "b" " []byte) (int, error)"
.PP
Write implements the Conn Write method. 
.PP
.BR "func (*IPConn) WriteMsgIP(" "b" ", " "oob" " []byte, " "addr" " *IPAddr) (" "n" ", " "oobn" " int, " "err" " error)"
.PP
WriteMsgIP writes a packet to addr via c, copying the payload from b and the associated out\-of\-band data from oob. 
It returns the number of payload and out\-of\-band bytes written. 
.PP
.BR "func (*IPConn) WriteTo(" "b" " []byte, " "addr" " Addr) (int, error)"
.PP
WriteTo implements the PacketConn WriteTo method. 
.PP
.BR "func (*IPConn) WriteToIP(" "b" " []byte, " "addr" " *IPAddr) (int, error)"
.PP
WriteToIP writes an IP packet to addr via c, copying the payload from b. 
.PP
WriteToIP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. 
On packet\-oriented connections, write timeouts are rare. 
.SS "IPMask"
.B type IPMask []byte
.PP
An IP mask is an IP address. 
.PP
.BR "func CIDRMask(" "ones" ", " "bits" " int) IPMask"
.PP
CIDRMask returns an IPMask consisting of `ones' 1 bits followed by 0s up to a total length of `bits' bits. 
For a mask of this form, CIDRMask is the inverse of IPMask.Size. 
.PP
.BR "func IPv4Mask(" "a" ", " "b" ", " "c" ", " "d" " byte) IPMask"
.PP
IPv4Mask returns the IP mask (in 4\-byte form) of the IPv4 mask a.b.c.d. 
.PP
.BR "func (IPMask) Size() (" "ones" ", " "bits" " int)"
.PP
Size returns the number of leading ones and total bits in the mask. 
If the mask is not in the canonical form\-\-ones followed by zeros\-\-then Size returns 0, 0. 
.PP
.BR "func (IPMask) String() string"
.PP
String returns the hexadecimal form of m, with no punctuation. 
.SS "IPNet"
.B type IPNet struct {
.RS
.B IP IP
.sp 0
.B Mask IPMask
.RE
.B }
.PP
An IPNet represents an IP network. 
.PP
.BR "func (*IPNet) Contains(" "ip" " IP) bool"
.PP
Contains reports whether the network includes ip. 
.PP
.BR "func (*IPNet) Network() string"
.PP
Network returns the address's network name, "ip+net". 
.PP
.BR "func (*IPNet) String() string"
.PP
String returns the CIDR notation of n like "192.168.100.1/24" or "2001:DB8::/48" as defined in RFC 4632 and RFC 4291. 
If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like "192.168.100.1/c000ff00". 
.SS "Interface"
.B type Interface struct {
.RS
.B Index int
.sp 0
.B MTU int
.sp 0
.B Name string
.sp 0
.B HardwareAddr HardwareAddr
.sp 0
.B Flags Flags
.RE
.B }
.PP
Interface represents a mapping between network interface name and index. 
It also represents network interface facility information. 
.PP
.BR "func InterfaceByIndex(" "index" " int) (*Interface, error)"
.PP
InterfaceByIndex returns the interface specified by index. 
.PP
.BR "func InterfaceByName(" "name" " string) (*Interface, error)"
.PP
InterfaceByName returns the interface specified by name. 
.PP
.BR "func (*Interface) Addrs() ([]Addr, error)"
.PP
Addrs returns interface addresses for a specific interface. 
.PP
.BR "func (*Interface) MulticastAddrs() ([]Addr, error)"
.PP
MulticastAddrs returns multicast, joined group addresses for a specific interface. 
.SS "InvalidAddrError"
.B type InvalidAddrError string
.PP
.PP
.BR "func (InvalidAddrError) Error() string"
.PP
.BR "func (InvalidAddrError) Temporary() bool"
.PP
.BR "func (InvalidAddrError) Timeout() bool"
.SS "Listener"
.B type Listener interface {
.RS
.B Accept() (c Conn, err error)
.sp 0
.B Close() error
.sp 0
.B Addr() Addr
.sp 0
.RE
.B }
.PP
A Listener is a generic network listener for stream\-oriented protocols. 
.PP
Multiple goroutines may invoke methods on a Listener simultaneously. 
.PP
.BR "func FileListener(" "f" " *os.File) (" "l" " Listener, " "err" " error)"
.PP
FileListener returns a copy of the network listener corresponding to the open file f. 
It is the caller's responsibility to close l when finished. 
Closing l does not affect f, and closing f does not affect l. 
.PP
.BR "func Listen(" "net" ", " "laddr" " string) (Listener, error)"
.PP
Listen announces on the local network address laddr. 
The network net must be a stream\-oriented network: "tcp", "tcp4", "tcp6", "unix" or "unixpacket". 
See Dial for the syntax of laddr. 
.SS "MX"
.B type MX struct {
.RS
.B Host string
.sp 0
.B Pref uint16
.RE
.B }
.PP
An MX represents a single DNS MX record. 
.SS "NS"
.B type NS struct {
.RS
.B Host string
.RE
.B }
.PP
An NS represents a single DNS NS record. 
.SS "OpError"
.B type OpError struct {
.RS
.B Op string
.sp 0
.B Net string
.sp 0
.B Addr Addr
.sp 0
.B Err error
.RE
.B }
.PP
OpError is the error type usually returned by functions in the net package. 
It describes the operation, network type, and address of an error. 
.PP
.BR "func (*OpError) Error() string"
.PP
.BR "func (*OpError) Temporary() bool"
.PP
.BR "func (*OpError) Timeout() bool"
.SS "PacketConn"
.B type PacketConn interface {
.RS
.B ReadFrom(b []byte) (n int, addr Addr, err error)
.sp 0
.B WriteTo(b []byte, addr Addr) (n int, err error)
.sp 0
.B Close() error
.sp 0
.B LocalAddr() Addr
.sp 0
.B SetDeadline(t time.Time) error
.sp 0
.B SetReadDeadline(t time.Time) error
.sp 0
.B SetWriteDeadline(t time.Time) error
.sp 0
.RE
.B }
.PP
PacketConn is a generic packet\-oriented network connection. 
.PP
Multiple goroutines may invoke methods on a PacketConn simultaneously. 
.PP
.BR "func FilePacketConn(" "f" " *os.File) (" "c" " PacketConn, " "err" " error)"
.PP
FilePacketConn returns a copy of the packet network connection corresponding to the open file f. 
It is the caller's responsibility to close f when finished. 
Closing c does not affect f, and closing f does not affect c. 
.PP
.BR "func ListenPacket(" "net" ", " "laddr" " string) (PacketConn, error)"
.PP
ListenPacket announces on the local network address laddr. 
The network net must be a packet\-oriented network: "udp", "udp4", "udp6", "ip", "ip4", "ip6" or "unixgram". 
See Dial for the syntax of laddr. 
.SS "ParseError"
.B type ParseError struct {
.RS
.B Type string
.sp 0
.B Text string
.RE
.B }
.PP
A ParseError represents a malformed text string and the type of string that was expected. 
.PP
.BR "func (*ParseError) Error() string"
.SS "SRV"
.B type SRV struct {
.RS
.B Target string
.sp 0
.B Port uint16
.sp 0
.B Priority uint16
.sp 0
.B Weight uint16
.RE
.B }
.PP
An SRV represents a single DNS SRV record. 
.SS "TCPAddr"
.B type TCPAddr struct {
.RS
.B IP IP
.sp 0
.B Port int
.sp 0
.B Zone string
.RE
.B }
.PP
TCPAddr represents the address of a TCP end point. 
.PP
.BR "func ResolveTCPAddr(" "net" ", " "addr" " string) (*TCPAddr, error)"
.PP
ResolveTCPAddr parses addr as a TCP address of the form "host:port" or "[ipv6\-host%zone]:port" and resolves a pair of domain name and port name on the network net, which must be "tcp", "tcp4" or "tcp6". 
A literal address or host name for IPv6 must be enclosed in square brackets, as in "[::1]:80", "[ipv6\-host]:http" or "[ipv6\-host%zone]:80". 
.PP
.BR "func (*TCPAddr) Network() string"
.PP
Network returns the address's network name, "tcp". 
.PP
.BR "func (*TCPAddr) String() string"
.SS "TCPConn"
.B type TCPConn struct {
.RS
.RE
.B }
.PP
TCPConn is an implementation of the Conn interface for TCP network connections. 
.PP
.BR "func DialTCP(" "net" " string, " "laddr" ", " "raddr" " *TCPAddr) (*TCPConn, error)"
.PP
DialTCP connects to the remote address raddr on the network net, which must be "tcp", "tcp4", or "tcp6". 
If laddr is not nil, it is used as the local address for the connection. 
.PP
.BR "func (*TCPConn) Close() error"
.PP
Close closes the connection. 
.PP
.BR "func (*TCPConn) CloseRead() error"
.PP
CloseRead shuts down the reading side of the TCP connection. 
Most callers should just use Close. 
.PP
.BR "func (*TCPConn) CloseWrite() error"
.PP
CloseWrite shuts down the writing side of the TCP connection. 
Most callers should just use Close. 
.PP
.BR "func (*TCPConn) File() (" "f" " *os.File, " "err" " error)"
.PP
File sets the underlying os.File to blocking mode and returns a copy. 
It is the caller's responsibility to close f when finished. 
Closing c does not affect f, and closing f does not affect c. 
.PP
The returned os.File's file descriptor is different from the connection's. 
Attempting to change properties of the original using this duplicate may or may not have the desired effect. 
.PP
.BR "func (*TCPConn) LocalAddr() Addr"
.PP
LocalAddr returns the local network address. 
.PP
.BR "func (*TCPConn) Read(" "b" " []byte) (int, error)"
.PP
Read implements the Conn Read method. 
.PP
.BR "func (*TCPConn) ReadFrom(" "r" " io.Reader) (int64, error)"
.PP
ReadFrom implements the io.ReaderFrom ReadFrom method. 
.PP
.BR "func (*TCPConn) RemoteAddr() Addr"
.PP
RemoteAddr returns the remote network address. 
.PP
.BR "func (*TCPConn) SetDeadline(" "t" " time.Time) error"
.PP
SetDeadline implements the Conn SetDeadline method. 
.PP
.BR "func (*TCPConn) SetKeepAlive(" "keepalive" " bool) error"
.PP
SetKeepAlive sets whether the operating system should send keepalive messages on the connection. 
.PP
.BR "func (*TCPConn) SetKeepAlivePeriod(" "d" " time.Duration) error"
.PP
SetKeepAlivePeriod sets period between keep alives. 
.PP
.BR "func (*TCPConn) SetLinger(" "sec" " int) error"
.PP
SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged. 
.PP
If sec < 0 (the default), the operating system finishes sending the data in the background. 
.PP
If sec == 0, the operating system discards any unsent or unacknowledged data. 
.PP
If sec > 0, the data is sent in the background as with sec < 0. 
On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded. 
.PP
.BR "func (*TCPConn) SetNoDelay(" "noDelay" " bool) error"
.PP
SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). 
The default is true (no delay), meaning that data is sent as soon as possible after a Write. 
.PP
.BR "func (*TCPConn) SetReadBuffer(" "bytes" " int) error"
.PP
SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. 
.PP
.BR "func (*TCPConn) SetReadDeadline(" "t" " time.Time) error"
.PP
SetReadDeadline implements the Conn SetReadDeadline method. 
.PP
.BR "func (*TCPConn) SetWriteBuffer(" "bytes" " int) error"
.PP
SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. 
.PP
.BR "func (*TCPConn) SetWriteDeadline(" "t" " time.Time) error"
.PP
SetWriteDeadline implements the Conn SetWriteDeadline method. 
.PP
.BR "func (*TCPConn) Write(" "b" " []byte) (int, error)"
.PP
Write implements the Conn Write method. 
.SS "TCPListener"
.B type TCPListener struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
TCPListener is a TCP network listener. 
Clients should typically use variables of type Listener instead of assuming TCP. 
.PP
.BR "func ListenTCP(" "net" " string, " "laddr" " *TCPAddr) (*TCPListener, error)"
.PP
ListenTCP announces on the TCP address laddr and returns a TCP listener. 
Net must be "tcp", "tcp4", or "tcp6". 
If laddr has a port of 0, ListenTCP will choose an available port. 
The caller can use the Addr method of TCPListener to retrieve the chosen address. 
.PP
.BR "func (*TCPListener) Accept() (Conn, error)"
.PP
Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn. 
.PP
.BR "func (*TCPListener) AcceptTCP() (*TCPConn, error)"
.PP
AcceptTCP accepts the next incoming call and returns the new connection. 
.PP
.BR "func (*TCPListener) Addr() Addr"
.PP
Addr returns the listener's network address, a *TCPAddr. 
.PP
.BR "func (*TCPListener) Close() error"
.PP
Close stops listening on the TCP address. 
Already Accepted connections are not closed. 
.PP
.BR "func (*TCPListener) File() (" "f" " *os.File, " "err" " error)"
.PP
File returns a copy of the underlying os.File, set to blocking mode. 
It is the caller's responsibility to close f when finished. 
Closing l does not affect f, and closing f does not affect l. 
.PP
The returned os.File's file descriptor is different from the connection's. 
Attempting to change properties of the original using this duplicate may or may not have the desired effect. 
.PP
.BR "func (*TCPListener) SetDeadline(" "t" " time.Time) error"
.PP
SetDeadline sets the deadline associated with the listener. 
A zero time value disables the deadline. 
.SS "UDPAddr"
.B type UDPAddr struct {
.RS
.B IP IP
.sp 0
.B Port int
.sp 0
.B Zone string
.RE
.B }
.PP
UDPAddr represents the address of a UDP end point. 
.PP
.BR "func ResolveUDPAddr(" "net" ", " "addr" " string) (*UDPAddr, error)"
.PP
ResolveUDPAddr parses addr as a UDP address of the form "host:port" or "[ipv6\-host%zone]:port" and resolves a pair of domain name and port name on the network net, which must be "udp", "udp4" or "udp6". 
A literal address or host name for IPv6 must be enclosed in square brackets, as in "[::1]:80", "[ipv6\-host]:http" or "[ipv6\-host%zone]:80". 
.PP
.BR "func (*UDPAddr) Network() string"
.PP
Network returns the address's network name, "udp". 
.PP
.BR "func (*UDPAddr) String() string"
.SS "UDPConn"
.B type UDPConn struct {
.RS
.RE
.B }
.PP
UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections. 
.PP
.BR "func DialUDP(" "net" " string, " "laddr" ", " "raddr" " *UDPAddr) (*UDPConn, error)"
.PP
DialUDP connects to the remote address raddr on the network net, which must be "udp", "udp4", or "udp6". 
If laddr is not nil, it is used as the local address for the connection. 
.PP
.BR "func ListenMulticastUDP(" "net" " string, " "ifi" " *Interface, " "gaddr" " *UDPAddr) (*UDPConn, error)"
.PP
ListenMulticastUDP listens for incoming multicast UDP packets addressed to the group address gaddr on ifi, which specifies the interface to join. 
ListenMulticastUDP uses default multicast interface if ifi is nil. 
.PP
.BR "func ListenUDP(" "net" " string, " "laddr" " *UDPAddr) (*UDPConn, error)"
.PP
ListenUDP listens for incoming UDP packets addressed to the local address laddr. 
Net must be "udp", "udp4", or "udp6". 
If laddr has a port of 0, ListenUDP will choose an available port. 
The LocalAddr method of the returned UDPConn can be used to discover the port. 
The returned connection's ReadFrom and WriteTo methods can be used to receive and send UDP packets with per\-packet addressing. 
.PP
.BR "func (*UDPConn) Close() error"
.PP
Close closes the connection. 
.PP
.BR "func (*UDPConn) File() (" "f" " *os.File, " "err" " error)"
.PP
File sets the underlying os.File to blocking mode and returns a copy. 
It is the caller's responsibility to close f when finished. 
Closing c does not affect f, and closing f does not affect c. 
.PP
The returned os.File's file descriptor is different from the connection's. 
Attempting to change properties of the original using this duplicate may or may not have the desired effect. 
.PP
.BR "func (*UDPConn) LocalAddr() Addr"
.PP
LocalAddr returns the local network address. 
.PP
.BR "func (*UDPConn) Read(" "b" " []byte) (int, error)"
.PP
Read implements the Conn Read method. 
.PP
.BR "func (*UDPConn) ReadFrom(" "b" " []byte) (int, Addr, error)"
.PP
ReadFrom implements the PacketConn ReadFrom method. 
.PP
.BR "func (*UDPConn) ReadFromUDP(" "b" " []byte) (" "n" " int, " "addr" " *UDPAddr, " "err" " error)"
.PP
ReadFromUDP reads a UDP packet from c, copying the payload into b. 
It returns the number of bytes copied into b and the return address that was on the packet. 
.PP
ReadFromUDP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. 
.PP
.BR "func (*UDPConn) ReadMsgUDP(" "b" ", " "oob" " []byte) (" "n" ", " "oobn" ", " "flags" " int, " "addr" " *UDPAddr, " "err" " error)"
.PP
ReadMsgUDP reads a packet from c, copying the payload into b and the associated out\-of\-band data into oob. 
It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet and the source address of the packet. 
.PP
.BR "func (*UDPConn) RemoteAddr() Addr"
.PP
RemoteAddr returns the remote network address. 
.PP
.BR "func (*UDPConn) SetDeadline(" "t" " time.Time) error"
.PP
SetDeadline implements the Conn SetDeadline method. 
.PP
.BR "func (*UDPConn) SetReadBuffer(" "bytes" " int) error"
.PP
SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. 
.PP
.BR "func (*UDPConn) SetReadDeadline(" "t" " time.Time) error"
.PP
SetReadDeadline implements the Conn SetReadDeadline method. 
.PP
.BR "func (*UDPConn) SetWriteBuffer(" "bytes" " int) error"
.PP
SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. 
.PP
.BR "func (*UDPConn) SetWriteDeadline(" "t" " time.Time) error"
.PP
SetWriteDeadline implements the Conn SetWriteDeadline method. 
.PP
.BR "func (*UDPConn) Write(" "b" " []byte) (int, error)"
.PP
Write implements the Conn Write method. 
.PP
.BR "func (*UDPConn) WriteMsgUDP(" "b" ", " "oob" " []byte, " "addr" " *UDPAddr) (" "n" ", " "oobn" " int, " "err" " error)"
.PP
WriteMsgUDP writes a packet to addr via c, copying the payload from b and the associated out\-of\-band data from oob. 
It returns the number of payload and out\-of\-band bytes written. 
.PP
.BR "func (*UDPConn) WriteTo(" "b" " []byte, " "addr" " Addr) (int, error)"
.PP
WriteTo implements the PacketConn WriteTo method. 
.PP
.BR "func (*UDPConn) WriteToUDP(" "b" " []byte, " "addr" " *UDPAddr) (int, error)"
.PP
WriteToUDP writes a UDP packet to addr via c, copying the payload from b. 
.PP
WriteToUDP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. 
On packet\-oriented connections, write timeouts are rare. 
.SS "UnixAddr"
.B type UnixAddr struct {
.RS
.B Name string
.sp 0
.B Net string
.RE
.B }
.PP
UnixAddr represents the address of a Unix domain socket end point. 
.PP
.BR "func ResolveUnixAddr(" "net" ", " "addr" " string) (*UnixAddr, error)"
.PP
ResolveUnixAddr parses addr as a Unix domain socket address. 
The string net gives the network name, "unix", "unixgram" or "unixpacket". 
.PP
.BR "func (*UnixAddr) Network() string"
.PP
Network returns the address's network name, "unix", "unixgram" or "unixpacket". 
.PP
.BR "func (*UnixAddr) String() string"
.SS "UnixConn"
.B type UnixConn struct {
.RS
.RE
.B }
.PP
UnixConn is an implementation of the Conn interface for connections to Unix domain sockets. 
.PP
.BR "func DialUnix(" "net" " string, " "laddr" ", " "raddr" " *UnixAddr) (*UnixConn, error)"
.PP
DialUnix connects to the remote address raddr on the network net, which must be "unix", "unixgram" or "unixpacket". 
If laddr is not nil, it is used as the local address for the connection. 
.PP
.BR "func ListenUnixgram(" "net" " string, " "laddr" " *UnixAddr) (*UnixConn, error)"
.PP
ListenUnixgram listens for incoming Unix datagram packets addressed to the local address laddr. 
The network net must be "unixgram". 
The returned connection's ReadFrom and WriteTo methods can be used to receive and send packets with per\-packet addressing. 
.PP
.BR "func (*UnixConn) Close() error"
.PP
Close closes the connection. 
.PP
.BR "func (*UnixConn) CloseRead() error"
.PP
CloseRead shuts down the reading side of the Unix domain connection. 
Most callers should just use Close. 
.PP
.BR "func (*UnixConn) CloseWrite() error"
.PP
CloseWrite shuts down the writing side of the Unix domain connection. 
Most callers should just use Close. 
.PP
.BR "func (*UnixConn) File() (" "f" " *os.File, " "err" " error)"
.PP
File sets the underlying os.File to blocking mode and returns a copy. 
It is the caller's responsibility to close f when finished. 
Closing c does not affect f, and closing f does not affect c. 
.PP
The returned os.File's file descriptor is different from the connection's. 
Attempting to change properties of the original using this duplicate may or may not have the desired effect. 
.PP
.BR "func (*UnixConn) LocalAddr() Addr"
.PP
LocalAddr returns the local network address. 
.PP
.BR "func (*UnixConn) Read(" "b" " []byte) (int, error)"
.PP
Read implements the Conn Read method. 
.PP
.BR "func (*UnixConn) ReadFrom(" "b" " []byte) (int, Addr, error)"
.PP
ReadFrom implements the PacketConn ReadFrom method. 
.PP
.BR "func (*UnixConn) ReadFromUnix(" "b" " []byte) (int, *UnixAddr, error)"
.PP
ReadFromUnix reads a packet from c, copying the payload into b. 
It returns the number of bytes copied into b and the source address of the packet. 
.PP
ReadFromUnix can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. 
.PP
.BR "func (*UnixConn) ReadMsgUnix(" "b" ", " "oob" " []byte) (" "n" ", " "oobn" ", " "flags" " int, " "addr" " *UnixAddr, " "err" " error)"
.PP
ReadMsgUnix reads a packet from c, copying the payload into b and the associated out\-of\-band data into oob. 
It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet, and the source address of the packet. 
.PP
.BR "func (*UnixConn) RemoteAddr() Addr"
.PP
RemoteAddr returns the remote network address. 
.PP
.BR "func (*UnixConn) SetDeadline(" "t" " time.Time) error"
.PP
SetDeadline implements the Conn SetDeadline method. 
.PP
.BR "func (*UnixConn) SetReadBuffer(" "bytes" " int) error"
.PP
SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. 
.PP
.BR "func (*UnixConn) SetReadDeadline(" "t" " time.Time) error"
.PP
SetReadDeadline implements the Conn SetReadDeadline method. 
.PP
.BR "func (*UnixConn) SetWriteBuffer(" "bytes" " int) error"
.PP
SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. 
.PP
.BR "func (*UnixConn) SetWriteDeadline(" "t" " time.Time) error"
.PP
SetWriteDeadline implements the Conn SetWriteDeadline method. 
.PP
.BR "func (*UnixConn) Write(" "b" " []byte) (int, error)"
.PP
Write implements the Conn Write method. 
.PP
.BR "func (*UnixConn) WriteMsgUnix(" "b" ", " "oob" " []byte, " "addr" " *UnixAddr) (" "n" ", " "oobn" " int, " "err" " error)"
.PP
WriteMsgUnix writes a packet to addr via c, copying the payload from b and the associated out\-of\-band data from oob. 
It returns the number of payload and out\-of\-band bytes written. 
.PP
.BR "func (*UnixConn) WriteTo(" "b" " []byte, " "addr" " Addr) (int, error)"
.PP
WriteTo implements the PacketConn WriteTo method. 
.PP
.BR "func (*UnixConn) WriteToUnix(" "b" " []byte, " "addr" " *UnixAddr) (int, error)"
.PP
WriteToUnix writes a packet to addr via c, copying the payload from b. 
.PP
WriteToUnix can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. 
On packet\-oriented connections, write timeouts are rare. 
.SS "UnixListener"
.B type UnixListener struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
UnixListener is a Unix domain socket listener. 
Clients should typically use variables of type Listener instead of assuming Unix domain sockets. 
.PP
.BR "func ListenUnix(" "net" " string, " "laddr" " *UnixAddr) (*UnixListener, error)"
.PP
ListenUnix announces on the Unix domain socket laddr and returns a Unix listener. 
The network net must be "unix" or "unixpacket". 
.PP
.BR "func (*UnixListener) Accept() (Conn, error)"
.PP
Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn. 
.PP
.BR "func (*UnixListener) AcceptUnix() (*UnixConn, error)"
.PP
AcceptUnix accepts the next incoming call and returns the new connection. 
.PP
.BR "func (*UnixListener) Addr() Addr"
.PP
Addr returns the listener's network address. 
.PP
.BR "func (*UnixListener) Close() error"
.PP
Close stops listening on the Unix address. 
Already accepted connections are not closed. 
.PP
.BR "func (*UnixListener) File() (*os.File, error)"
.PP
File returns a copy of the underlying os.File, set to blocking mode. 
It is the caller's responsibility to close f when finished. 
Closing l does not affect f, and closing f does not affect l. 
.PP
The returned os.File's file descriptor is different from the connection's. 
Attempting to change properties of the original using this duplicate may or may not have the desired effect. 
.PP
.BR "func (*UnixListener) SetDeadline(" "t" " time.Time) error"
.PP
SetDeadline sets the deadline associated with the listener. 
A zero time value disables the deadline. 
.SS "UnknownNetworkError"
.B type UnknownNetworkError string
.PP
.PP
.BR "func (UnknownNetworkError) Error() string"
.PP
.BR "func (UnknownNetworkError) Temporary() bool"
.PP
.BR "func (UnknownNetworkError) Timeout() bool"
.SS "byPref"
.B type byPref []*MX
.PP
byPref implements sort.Interface to sort MX records by preference    
.PP
.BR "func (byPref) Len() int"
.PP
.BR "func (byPref) Less(" "i" ", " "j" " int) bool"
.PP
.BR "func (byPref) Swap(" "i" ", " "j" " int)"
.SS "byPriorityWeight"
.B type byPriorityWeight []*SRV
.PP
byPriorityWeight sorts SRV records by ascending priority and weight. 
.PP
.BR "func (byPriorityWeight) Len() int"
.PP
.BR "func (byPriorityWeight) Less(" "i" ", " "j" " int) bool"
.PP
.BR "func (byPriorityWeight) Swap(" "i" ", " "j" " int)"
.SS "conn"
.B type conn struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*conn) Close() error"
.PP
Close closes the connection. 
.PP
.BR "func (*conn) File() (" "f" " *os.File, " "err" " error)"
.PP
File sets the underlying os.File to blocking mode and returns a copy. 
It is the caller's responsibility to close f when finished. 
Closing c does not affect f, and closing f does not affect c. 
.PP
The returned os.File's file descriptor is different from the connection's. 
Attempting to change properties of the original using this duplicate may or may not have the desired effect. 
.PP
.BR "func (*conn) LocalAddr() Addr"
.PP
LocalAddr returns the local network address. 
.PP
.BR "func (*conn) Read(" "b" " []byte) (int, error)"
.PP
Read implements the Conn Read method. 
.PP
.BR "func (*conn) RemoteAddr() Addr"
.PP
RemoteAddr returns the remote network address. 
.PP
.BR "func (*conn) SetDeadline(" "t" " time.Time) error"
.PP
SetDeadline implements the Conn SetDeadline method. 
.PP
.BR "func (*conn) SetReadBuffer(" "bytes" " int) error"
.PP
SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. 
.PP
.BR "func (*conn) SetReadDeadline(" "t" " time.Time) error"
.PP
SetReadDeadline implements the Conn SetReadDeadline method. 
.PP
.BR "func (*conn) SetWriteBuffer(" "bytes" " int) error"
.PP
SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. 
.PP
.BR "func (*conn) SetWriteDeadline(" "t" " time.Time) error"
.PP
SetWriteDeadline implements the Conn SetWriteDeadline method. 
.PP
.BR "func (*conn) Write(" "b" " []byte) (int, error)"
.PP
Write implements the Conn Write method. 
.SS "dnsHeader"
.B type dnsHeader struct {
.RS
.B Id uint16
.sp 0
.B Bits uint16
.sp 0
.B Qdcount, Ancount, Nscount, Arcount uint16
.RE
.B }
.PP
The wire format for the DNS packet header. 
.PP
.BR "func (*dnsHeader) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsMsg"
.B type dnsMsg struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*dnsMsg) Pack() (" "msg" " []byte, " "ok" " bool)"
.PP
.BR "func (*dnsMsg) String() string"
.PP
.BR "func (*dnsMsg) Unpack(" "msg" " []byte) bool"
.PP
.BR "func (*dnsMsg) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsMsgHdr"
.B type dnsMsgHdr struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A manually\-unpacked version of (id, bits). 
This is in its own struct for easy printing. 
.PP
.BR "func (*dnsMsgHdr) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsQuestion"
.B type dnsQuestion struct {
.RS
.B Name string
.sp 0
.B Qtype uint16
.sp 0
.B Qclass uint16
.RE
.B }
.PP
DNS queries. 
.PP
.BR "func (*dnsQuestion) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR"
.B type dnsRR interface {
.RS
.B dnsStruct
.sp 0
.B Header() *dnsRR_Header
.sp 0
.RE
.B }
.PP
.SS "dnsRR_A"
.B type dnsRR_A struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B A uint32
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_A) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_A) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_AAAA"
.B type dnsRR_AAAA struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B AAAA []byte
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_AAAA) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_AAAA) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_CNAME"
.B type dnsRR_CNAME struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Cname string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_CNAME) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_CNAME) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_HINFO"
.B type dnsRR_HINFO struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Cpu string
.sp 0
.B Os string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_HINFO) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_HINFO) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_Header"
.B type dnsRR_Header struct {
.RS
.B Name string
.sp 0
.B Rrtype uint16
.sp 0
.B Class uint16
.sp 0
.B Ttl uint32
.sp 0
.B Rdlength uint16
.RE
.B }
.PP
DNS responses (resource records). 
There are many types of messages, but they all share the same header. 
.PP
.BR "func (*dnsRR_Header) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_Header) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_MB"
.B type dnsRR_MB struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Mb string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_MB) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_MB) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_MG"
.B type dnsRR_MG struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Mg string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_MG) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_MG) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_MINFO"
.B type dnsRR_MINFO struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Rmail string
.sp 0
.B Email string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_MINFO) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_MINFO) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_MR"
.B type dnsRR_MR struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Mr string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_MR) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_MR) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_MX"
.B type dnsRR_MX struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Pref uint16
.sp 0
.B Mx string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_MX) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_MX) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_NS"
.B type dnsRR_NS struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Ns string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_NS) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_NS) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_PTR"
.B type dnsRR_PTR struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Ptr string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_PTR) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_PTR) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_SOA"
.B type dnsRR_SOA struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Ns string
.sp 0
.B Mbox string
.sp 0
.B Serial uint32
.sp 0
.B Refresh uint32
.sp 0
.B Retry uint32
.sp 0
.B Expire uint32
.sp 0
.B Minttl uint32
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_SOA) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_SOA) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_SRV"
.B type dnsRR_SRV struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Priority uint16
.sp 0
.B Weight uint16
.sp 0
.B Port uint16
.sp 0
.B Target string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_SRV) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_SRV) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsRR_TXT"
.B type dnsRR_TXT struct {
.RS
.B Hdr dnsRR_Header
.sp 0
.B Txt string
.RE
.B }
.PP
.PP
.BR "func (*dnsRR_TXT) Header() *dnsRR_Header"
.PP
.BR "func (*dnsRR_TXT) Walk(" "f" " func(v interface{}, name, tag string) bool) bool"
.SS "dnsStruct"
.B type dnsStruct interface {
.RS
.B Walk(f func(v interface{}, name, tag string) (ok bool)) (ok bool)
.sp 0
.RE
.B }
.PP
A dnsStruct describes how to iterate over its fields to emulate reflective marshalling. 
.SS "fdMutex"
.B type fdMutex struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
fdMutex is a specialized synchronization primitive that manages lifetime of an fd and serializes access to Read and Write methods on netFD. 
.PP
.BR "func (*fdMutex) Decref() bool"
.PP
.BR "func (*fdMutex) Incref() bool"
.PP
.BR "func (*fdMutex) IncrefAndClose() bool"
.PP
.BR "func (*fdMutex) RWLock(" "read" " bool) bool"
.PP
.BR "func (*fdMutex) RWUnlock(" "read" " bool) bool"
.SS "ioSrv"
.B type ioSrv struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
ioSrv executes net IO requests. 
.PP
.BR "func (*ioSrv) ExecIO(" "o" " *operation, " "name" " string, " "submit" " func(o *operation) error) (int, error)"
.PP
ExecIO executes a single IO operation o. 
It submits and cancels IO in the current thread for systems where Windows CancelIoEx API is available. 
Alternatively, it passes the request onto runtime netpoll and waits for completion or cancels request. 
.PP
.BR "func (*ioSrv) ProcessRemoteIO()"
.PP
ProcessRemoteIO will execute submit IO requests on behalf of other goroutines, all on a single os thread, so it can cancel them later. 
Results of all operations will be sent back to their requesters via channel supplied in request. 
It is used only when the CancelIoEx API is unavailable. 
.SS "netFD"
.B type netFD struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Network file descriptor. 
.PP
.BR "func (*netFD) Close() error"
.PP
.BR "func (*netFD) Read(" "buf" " []byte) (int, error)"
.PP
.BR "func (*netFD) Write(" "buf" " []byte) (int, error)"
.SS "operation"
.B type operation struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
operation contains superset of data necessary to perform all async IO. 
.PP
.BR "func (*operation) InitBuf(" "buf" " []byte)"
.SS "pipe"
.B type pipe struct {
.RS
.RE
.B }
.PP
.PP
.BR "func (*pipe) Close() error"
.PP
.BR "func (*pipe) LocalAddr() Addr"
.PP
.BR "func (*pipe) RemoteAddr() Addr"
.PP
.BR "func (*pipe) SetDeadline(" "t" " time.Time) error"
.PP
.BR "func (*pipe) SetReadDeadline(" "t" " time.Time) error"
.PP
.BR "func (*pipe) SetWriteDeadline(" "t" " time.Time) error"
.SS "pipeAddr"
.B type pipeAddr int
.PP
.PP
.BR "func (pipeAddr) Network() string"
.PP
.BR "func (pipeAddr) String() string"
.SS "pollDesc"
.B type pollDesc struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*pollDesc) Close()"
.PP
.BR "func (*pollDesc) Evict() bool"
.PP
Evict evicts fd from the pending list, unblocking any I/O running on fd. 
Return value is whether the pollServer should be woken up. 
.PP
.BR "func (*pollDesc) Init(" "fd" " *netFD) error"
.PP
.BR "func (*pollDesc) Lock()"
.PP
.BR "func (*pollDesc) Prepare(" "mode" " int) error"
.PP
.BR "func (*pollDesc) PrepareRead() error"
.PP
.BR "func (*pollDesc) PrepareWrite() error"
.PP
.BR "func (*pollDesc) Unlock()"
.PP
.BR "func (*pollDesc) Wait(" "mode" " int) error"
.PP
.BR "func (*pollDesc) WaitCanceled(" "mode" " int)"
.PP
.BR "func (*pollDesc) WaitCanceledRead()"
.PP
.BR "func (*pollDesc) WaitCanceledWrite()"
.PP
.BR "func (*pollDesc) WaitRead() error"
.PP
.BR "func (*pollDesc) WaitWrite() error"
.PP
.BR "func (*pollDesc) Wakeup()"
.SS "singleflight"
.B type singleflight struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
singleflight represents a class of work and forms a namespace in which units of work can be executed with duplicate suppression. 
.PP
.BR "func (*singleflight) Do(" "key" " string, " "fn" " func() (interface{}, error)) (" "v" " interface{}, " "err" " error, " "shared" " bool)"
.PP
Do executes and returns the results of the given function, making sure that only one execution is in\-flight for a given key at a time. 
If a duplicate comes in, the duplicate caller waits for the original to complete and receives the same results. 
The return value shared indicates whether v was given to multiple callers. 
.SS "temporary"
.B type temporary interface {
.RS
.B Temporary() bool
.sp 0
.RE
.B }
.SS "timeout"
.B type timeout interface {
.RS
.B Timeout() bool
.sp 0
.RE
.B }
.SS "timeoutError"
.B type timeoutError struct {
.RS
.RE
.B }
.PP
.PP
.BR "func (*timeoutError) Error() string"
.PP
.BR "func (*timeoutError) Temporary() bool"
.PP
.BR "func (*timeoutError) Timeout() bool"
.SS "udpHeader"
.B type udpHeader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*udpHeader) Bytes() []byte"
.SH "BUGS"
On every POSIX platform, reads from the "ip4" network using the ReadFrom or ReadFromIP method might not return a complete IPv4 packet, including its header, even if there is space available. 
This can occur even in cases where Read or ReadMsgIP could return a complete packet. 
For this reason, it is recommended that you do not uses these methods if it is important to receive a full packet. 
The Go 1 compatibility guidelines make it impossible for us to change the behavior of these methods; use Read or ReadMsgIP instead.   
.PP
On OpenBSD, listening on the "tcp" network does not listen for both IPv4 and IPv6 connections. 
This is due to the fact that IPv4 traffic will not be routed to an IPv6 socket 
.B \-
two separate sockets are required if both AFs are to be supported. 
See 
.BR inet6 (4)
on OpenBSD for details.   
.SH "SEE ALSO"
.BR inet6 (4)
