.\"    Automatically generated by mango(1)
.TH "cipher" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
cipher \- Package cipher implements standard block cipher modes that can be wrapped
around low-level block cipher implementations.
.SH "SYNOPSIS"
.B import \*(lqcipher\(rq
.sp
.RB "type " AEAD
.sp 0
.RS
.RB "func " NewGCM
.sp 0
.RE
.RB "type " Block
.sp 0
.RB "type " BlockMode
.sp 0
.RS
.RB "func " NewCBCDecrypter
.sp 0
.RB "func " NewCBCEncrypter
.sp 0
.RE
.RB "type " Stream
.sp 0
.RS
.RB "func " NewCFBDecrypter
.sp 0
.RB "func " NewCFBEncrypter
.sp 0
.RB "func " NewCTR
.sp 0
.RB "func " NewOFB
.sp 0
.RE
.RB "type " StreamReader
.sp 0
.RS
.RB "func (StreamReader) " Read
.sp 0
.RE
.RB "type " StreamWriter
.sp 0
.RS
.RB "func (StreamWriter) " Close
.sp 0
.RB "func (StreamWriter) " Write
.sp 0
.RE
.RB "type " cbcDecrypter
.sp 0
.RS
.RB "func (*cbcDecrypter) " BlockSize
.sp 0
.RB "func (*cbcDecrypter) " CryptBlocks
.sp 0
.RB "func (*cbcDecrypter) " SetIV
.sp 0
.RE
.RB "type " cbcEncrypter
.sp 0
.RS
.RB "func (*cbcEncrypter) " BlockSize
.sp 0
.RB "func (*cbcEncrypter) " CryptBlocks
.sp 0
.RB "func (*cbcEncrypter) " SetIV
.sp 0
.RE
.RB "type " cfb
.sp 0
.RS
.RB "func (*cfb) " XORKeyStream
.sp 0
.RE
.RB "type " ctr
.sp 0
.RS
.RB "func (*ctr) " XORKeyStream
.sp 0
.RE
.RB "type " gcm
.sp 0
.RS
.RB "func (*gcm) " NonceSize
.sp 0
.RB "func (*gcm) " Open
.sp 0
.RB "func (*gcm) " Overhead
.sp 0
.RB "func (*gcm) " Seal
.sp 0
.RE
.RB "type " ofb
.sp 0
.RS
.RB "func (*ofb) " XORKeyStream
.sp 0
.RE
.SH "DESCRIPTION"
Package cipher implements standard block cipher modes that can be wrapped around low\-level block cipher implementations. 
See http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html and NIST Special Publication 800\-38A. 
.SH "TYPES"
.SS "AEAD"
.B type AEAD interface {
.RS
.B NonceSize() int
.sp 0
.B Overhead() int
.sp 0
.B Seal(dst, nonce, plaintext, data []byte) []byte
.sp 0
.B Open(dst, nonce, ciphertext, data []byte) ([]byte, error)
.sp 0
.RE
.B }
.PP
AEAD is a cipher mode providing authenticated encryption with associated data. 
.PP
.BR "func NewGCM(" "cipher" " Block) (AEAD, error)"
.PP
NewGCM returns the given 128\-bit, block cipher wrapped in Galois Counter Mode. 
.SS "Block"
.B type Block interface {
.RS
.B BlockSize() int
.sp 0
.B Encrypt(dst, src []byte)
.sp 0
.B Decrypt(dst, src []byte)
.sp 0
.RE
.B }
.PP
A Block represents an implementation of block cipher using a given key. 
It provides the capability to encrypt or decrypt individual blocks. 
The mode implementations extend that capability to streams of blocks. 
.SS "BlockMode"
.B type BlockMode interface {
.RS
.B BlockSize() int
.sp 0
.B CryptBlocks(dst, src []byte)
.sp 0
.RE
.B }
.PP
A BlockMode represents a block cipher running in a block\-based mode (CBC, ECB etc). 
.PP
.BR "func NewCBCDecrypter(" "b" " Block, " "iv" " []byte) BlockMode"
.PP
NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. 
The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data. 
.PP
.BR "func NewCBCEncrypter(" "b" " Block, " "iv" " []byte) BlockMode"
.PP
NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. 
The length of iv must be the same as the Block's block size. 
.SS "Stream"
.B type Stream interface {
.RS
.B XORKeyStream(dst, src []byte)
.sp 0
.RE
.B }
.PP
A Stream represents a stream cipher. 
.PP
.BR "func NewCFBDecrypter(" "block" " Block, " "iv" " []byte) Stream"
.PP
NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode, using the given Block. 
The iv must be the same length as the Block's block size. 
.PP
.BR "func NewCFBEncrypter(" "block" " Block, " "iv" " []byte) Stream"
.PP
NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode, using the given Block. 
The iv must be the same length as the Block's block size. 
.PP
.BR "func NewCTR(" "block" " Block, " "iv" " []byte) Stream"
.PP
NewCTR returns a Stream which encrypts/decrypts using the given Block in counter mode. 
The length of iv must be the same as the Block's block size. 
.PP
.BR "func NewOFB(" "b" " Block, " "iv" " []byte) Stream"
.PP
NewOFB returns a Stream that encrypts or decrypts using the block cipher b in output feedback mode. 
The initialization vector iv's length must be equal to b's block size. 
.SS "StreamReader"
.B type StreamReader struct {
.RS
.B S Stream
.sp 0
.B R io.Reader
.RE
.B }
.PP
StreamReader wraps a Stream into an io.Reader. 
It calls XORKeyStream to process each slice of data which passes through. 
.PP
.BR "func (StreamReader) Read(" "dst" " []byte) (" "n" " int, " "err" " error)"
.SS "StreamWriter"
.B type StreamWriter struct {
.RS
.B S Stream
.sp 0
.B W io.Writer
.sp 0
.B Err error
.RE
.B }
.PP
StreamWriter wraps a Stream into an io.Writer. 
It calls XORKeyStream to process each slice of data which passes through. 
If any Write call returns short then the StreamWriter is out of sync and must be discarded. 
A StreamWriter has no internal buffering; Close does not need to be called to flush write data. 
.PP
.BR "func (StreamWriter) Close() error"
.PP
Close closes the underlying Writer and returns its Close return value, if the Writer is also an io.Closer. 
Otherwise it returns nil. 
.PP
.BR "func (StreamWriter) Write(" "src" " []byte) (" "n" " int, " "err" " error)"
.SS "cbcDecrypter"
.B type cbcDecrypter cbc
.PP
.PP
.BR "func (*cbcDecrypter) BlockSize() int"
.PP
.BR "func (*cbcDecrypter) CryptBlocks(" "dst" ", " "src" " []byte)"
.PP
.BR "func (*cbcDecrypter) SetIV(" "iv" " []byte)"
.SS "cbcEncrypter"
.B type cbcEncrypter cbc
.PP
.PP
.BR "func (*cbcEncrypter) BlockSize() int"
.PP
.BR "func (*cbcEncrypter) CryptBlocks(" "dst" ", " "src" " []byte)"
.PP
.BR "func (*cbcEncrypter) SetIV(" "iv" " []byte)"
.SS "cfb"
.B type cfb struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*cfb) XORKeyStream(" "dst" ", " "src" " []byte)"
.SS "ctr"
.B type ctr struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*ctr) XORKeyStream(" "dst" ", " "src" " []byte)"
.SS "gcm"
.B type gcm struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
gcm represents a Galois Counter Mode with a specific key. 
See http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm\-revised\-spec.pdf 
.PP
.BR "func (*gcm) NonceSize() int"
.PP
.BR "func (*gcm) Open(" "dst" ", " "nonce" ", " "ciphertext" ", " "data" " []byte) ([]byte, error)"
.PP
.BR "func (*gcm) Overhead() int"
.PP
.BR "func (*gcm) Seal(" "dst" ", " "nonce" ", " "plaintext" ", " "data" " []byte) []byte"
.SS "ofb"
.B type ofb struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*ofb) XORKeyStream(" "dst" ", " "src" " []byte)"
