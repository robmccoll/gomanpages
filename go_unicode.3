.\"    Automatically generated by mango(1)
.TH "unicode" 3 "2014-11-26" "version 6.3.0" "Go Packages"
.SH "NAME"
unicode \- Package unicode provides data and functions to test some properties of
Unicode code points.
.SH "SYNOPSIS"
.B import \*(lqunicode\(rq
.sp
.B Constants
.sp 0
.B Variables
.sp 0
.RB "func " In
.sp 0
.RB "func " Is
.sp 0
.RB "func " IsControl
.sp 0
.RB "func " IsDigit
.sp 0
.RB "func " IsGraphic
.sp 0
.RB "func " IsLetter
.sp 0
.RB "func " IsLower
.sp 0
.RB "func " IsMark
.sp 0
.RB "func " IsNumber
.sp 0
.RB "func " IsOneOf
.sp 0
.RB "func " IsPrint
.sp 0
.RB "func " IsPunct
.sp 0
.RB "func " IsSpace
.sp 0
.RB "func " IsSymbol
.sp 0
.RB "func " IsTitle
.sp 0
.RB "func " IsUpper
.sp 0
.RB "func " SimpleFold
.sp 0
.RB "func " To
.sp 0
.RB "func " ToLower
.sp 0
.RB "func " ToTitle
.sp 0
.RB "func " ToUpper
.sp 0
.RB "type " CaseRange
.sp 0
.RB "type " Range16
.sp 0
.RB "type " Range32
.sp 0
.RB "type " RangeTable
.sp 0
.RB "type " SpecialCase
.sp 0
.RS
.RB "func (SpecialCase) " ToLower
.sp 0
.RB "func (SpecialCase) " ToTitle
.sp 0
.RB "func (SpecialCase) " ToUpper
.sp 0
.RE
.RB "type " foldPair
.sp 0
.SH "CONSTANTS"
.PP
.B const (
.RS
.B MaxRune 
.sp 0
.B ReplacementChar 
.sp 0
.B MaxASCII 
.sp 0
.B MaxLatin1 
.sp 0
.RE
.B )
.sp 0
Indices into the Delta arrays inside CaseRanges for case mapping. 
.PP
.B const (
.RS
.B UpperCase 
.sp 0
.B LowerCase 
.sp 0
.B TitleCase 
.sp 0
.B MaxCase 
.sp 0
.RE
.B )
.sp 0
If the Delta field of a CaseRange is UpperLower, it means this CaseRange represents a sequence of the form (say) Upper Lower Upper Lower. 
.PP
.B const 
.B UpperLower 
.sp 0

.sp 0
Version is the Unicode edition from which the tables are derived. 
.PP
.B const 
.B Version 
.sp 0
.SH "VARIABLES"
These variables have type *RangeTable. 
.PP
.B var (
.RS
.B Cc 
.sp 0
.B Cf 
.sp 0
.B Co 
.sp 0
.B Cs 
.sp 0
.B Digit 
.sp 0
.B Nd 
.sp 0
.B Letter 
.sp 0
.B L 
.sp 0
.B Lm 
.sp 0
.B Lo 
.sp 0
.B Lower 
.sp 0
.B Ll 
.sp 0
.B Mark 
.sp 0
.B M 
.sp 0
.B Mc 
.sp 0
.B Me 
.sp 0
.B Mn 
.sp 0
.B Nl 
.sp 0
.B No 
.sp 0
.B Number 
.sp 0
.B N 
.sp 0
.B Other 
.sp 0
.B C 
.sp 0
.B Pc 
.sp 0
.B Pd 
.sp 0
.B Pe 
.sp 0
.B Pf 
.sp 0
.B Pi 
.sp 0
.B Po 
.sp 0
.B Ps 
.sp 0
.B Punct 
.sp 0
.B P 
.sp 0
.B Sc 
.sp 0
.B Sk 
.sp 0
.B Sm 
.sp 0
.B So 
.sp 0
.B Space 
.sp 0
.B Z 
.sp 0
.B Symbol 
.sp 0
.B S 
.sp 0
.B Title 
.sp 0
.B Lt 
.sp 0
.B Upper 
.sp 0
.B Lu 
.sp 0
.B Zl 
.sp 0
.B Zp 
.sp 0
.B Zs 
.sp 0
.RE
.B )
.sp 0
These variables have type *RangeTable. 
.PP
.B var (
.RS
.B Arabic 
.sp 0
.B Armenian 
.sp 0
.B Avestan 
.sp 0
.B Balinese 
.sp 0
.B Bamum 
.sp 0
.B Batak 
.sp 0
.B Bengali 
.sp 0
.B Bopomofo 
.sp 0
.B Brahmi 
.sp 0
.B Braille 
.sp 0
.B Buginese 
.sp 0
.B Buhid 
.sp 0
.B Canadian_Aboriginal 
.sp 0
.B Carian 
.sp 0
.B Chakma 
.sp 0
.B Cham 
.sp 0
.B Cherokee 
.sp 0
.B Common 
.sp 0
.B Coptic 
.sp 0
.B Cuneiform 
.sp 0
.B Cypriot 
.sp 0
.B Cyrillic 
.sp 0
.B Deseret 
.sp 0
.B Devanagari 
.sp 0
.B Egyptian_Hieroglyphs 
.sp 0
.B Ethiopic 
.sp 0
.B Georgian 
.sp 0
.B Glagolitic 
.sp 0
.B Gothic 
.sp 0
.B Greek 
.sp 0
.B Gujarati 
.sp 0
.B Gurmukhi 
.sp 0
.B Han 
.sp 0
.B Hangul 
.sp 0
.B Hanunoo 
.sp 0
.B Hebrew 
.sp 0
.B Hiragana 
.sp 0
.B Imperial_Aramaic 
.sp 0
.B Inherited 
.sp 0
.B Inscriptional_Pahlavi 
.sp 0
.B Inscriptional_Parthian 
.sp 0
.B Javanese 
.sp 0
.B Kaithi 
.sp 0
.B Kannada 
.sp 0
.B Katakana 
.sp 0
.B Kayah_Li 
.sp 0
.B Kharoshthi 
.sp 0
.B Khmer 
.sp 0
.B Lao 
.sp 0
.B Latin 
.sp 0
.B Lepcha 
.sp 0
.B Limbu 
.sp 0
.B Linear_B 
.sp 0
.B Lisu 
.sp 0
.B Lycian 
.sp 0
.B Lydian 
.sp 0
.B Malayalam 
.sp 0
.B Mandaic 
.sp 0
.B Meetei_Mayek 
.sp 0
.B Meroitic_Cursive 
.sp 0
.B Meroitic_Hieroglyphs 
.sp 0
.B Miao 
.sp 0
.B Mongolian 
.sp 0
.B Myanmar 
.sp 0
.B New_Tai_Lue 
.sp 0
.B Nko 
.sp 0
.B Ogham 
.sp 0
.B Ol_Chiki 
.sp 0
.B Old_Italic 
.sp 0
.B Old_Persian 
.sp 0
.B Old_South_Arabian 
.sp 0
.B Old_Turkic 
.sp 0
.B Oriya 
.sp 0
.B Osmanya 
.sp 0
.B Phags_Pa 
.sp 0
.B Phoenician 
.sp 0
.B Rejang 
.sp 0
.B Runic 
.sp 0
.B Samaritan 
.sp 0
.B Saurashtra 
.sp 0
.B Sharada 
.sp 0
.B Shavian 
.sp 0
.B Sinhala 
.sp 0
.B Sora_Sompeng 
.sp 0
.B Sundanese 
.sp 0
.B Syloti_Nagri 
.sp 0
.B Syriac 
.sp 0
.B Tagalog 
.sp 0
.B Tagbanwa 
.sp 0
.B Tai_Le 
.sp 0
.B Tai_Tham 
.sp 0
.B Tai_Viet 
.sp 0
.B Takri 
.sp 0
.B Tamil 
.sp 0
.B Telugu 
.sp 0
.B Thaana 
.sp 0
.B Thai 
.sp 0
.B Tibetan 
.sp 0
.B Tifinagh 
.sp 0
.B Ugaritic 
.sp 0
.B Vai 
.sp 0
.B Yi 
.sp 0
.RE
.B )
.sp 0
These variables have type *RangeTable. 
.PP
.B var (
.RS
.B ASCII_Hex_Digit 
.sp 0
.B Bidi_Control 
.sp 0
.B Dash 
.sp 0
.B Deprecated 
.sp 0
.B Diacritic 
.sp 0
.B Extender 
.sp 0
.B Hex_Digit 
.sp 0
.B Hyphen 
.sp 0
.B IDS_Binary_Operator 
.sp 0
.B IDS_Trinary_Operator 
.sp 0
.B Ideographic 
.sp 0
.B Join_Control 
.sp 0
.B Logical_Order_Exception 
.sp 0
.B Noncharacter_Code_Point 
.sp 0
.B Other_Alphabetic 
.sp 0
.B Other_Default_Ignorable_Code_Point 
.sp 0
.B Other_Grapheme_Extend 
.sp 0
.B Other_ID_Continue 
.sp 0
.B Other_ID_Start 
.sp 0
.B Other_Lowercase 
.sp 0
.B Other_Math 
.sp 0
.B Other_Uppercase 
.sp 0
.B Pattern_Syntax 
.sp 0
.B Pattern_White_Space 
.sp 0
.B Quotation_Mark 
.sp 0
.B Radical 
.sp 0
.B STerm 
.sp 0
.B Soft_Dotted 
.sp 0
.B Terminal_Punctuation 
.sp 0
.B Unified_Ideograph 
.sp 0
.B Variation_Selector 
.sp 0
.B White_Space 
.sp 0
.RE
.B )
.sp 0
CaseRanges is the table describing case mappings for all letters with non\-self mappings. 
.PP
.B var 
.B CaseRanges 
.sp 0

.sp 0
Categories is the set of Unicode category tables. 
.PP
.B var 
.B Categories 
.sp 0

.sp 0
FoldCategory maps a category name to a table of code points outside the category that are equivalent under simple case folding to code points inside the category. 
If there is no entry for a category name, there are no such points. 
.PP
.B var 
.B FoldCategory 
.sp 0

.sp 0
FoldScript maps a script name to a table of code points outside the script that are equivalent under simple case folding to code points inside the script. 
If there is no entry for a script name, there are no such points. 
.PP
.B var 
.B FoldScript 
.sp 0

.sp 0
GraphicRanges defines the set of graphic characters according to Unicode. 
.PP
.B var 
.B GraphicRanges 
.sp 0

.sp 0
PrintRanges defines the set of printable characters according to Go. 
ASCII space, U+0020, is handled separately. 
.PP
.B var 
.B PrintRanges 
.sp 0

.sp 0
Properties is the set of Unicode property tables. 
.PP
.B var 
.B Properties 
.sp 0

.sp 0
Scripts is the set of Unicode script tables. 
.PP
.B var 
.B Scripts 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func In(" "r" " rune, " "ranges" " ...*RangeTable) bool"
.PP
In reports whether the rune is a member of one of the ranges. 
.PP
.BR "func Is(" "rangeTab" " *RangeTable, " "r" " rune) bool"
.PP
Is reports whether the rune is in the specified table of ranges. 
.PP
.BR "func IsControl(" "r" " rune) bool"
.PP
IsControl reports whether the rune is a control character. 
The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them. 
.PP
.BR "func IsDigit(" "r" " rune) bool"
.PP
IsDigit reports whether the rune is a decimal digit. 
.PP
.BR "func IsGraphic(" "r" " rune) bool"
.PP
IsGraphic reports whether the rune is defined as a Graphic by Unicode. 
Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs. 
.PP
.BR "func IsLetter(" "r" " rune) bool"
.PP
IsLetter reports whether the rune is a letter (category L). 
.PP
.BR "func IsLower(" "r" " rune) bool"
.PP
IsLower reports whether the rune is a lower case letter. 
.PP
.BR "func IsMark(" "r" " rune) bool"
.PP
IsMark reports whether the rune is a mark character (category M). 
.PP
.BR "func IsNumber(" "r" " rune) bool"
.PP
IsNumber reports whether the rune is a number (category N). 
.PP
.BR "func IsOneOf(" "ranges" " []*RangeTable, " "r" " rune) bool"
.PP
IsOneOf reports whether the rune is a member of one of the ranges. 
The function "In" provides a nicer signature and should be used in preference to IsOneOf. 
.PP
.BR "func IsPrint(" "r" " rune) bool"
.PP
IsPrint reports whether the rune is defined as printable by Go. 
Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. 
This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020. 
.PP
.BR "func IsPunct(" "r" " rune) bool"
.PP
IsPunct reports whether the rune is a Unicode punctuation character (category P). 
.PP
.BR "func IsSpace(" "r" " rune) bool"
.PP
IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin\-1 space this is 
.PP
.RS
\(fm\et', \(fm\en', \(fm\ev', \(fm\ef', \(fm\er', \(fm \(fm, U+0085 (NEL), U+00A0 (NBSP).
.RE
.PP
Other definitions of spacing characters are set by category Z and property Pattern_White_Space. 
.PP
.BR "func IsSymbol(" "r" " rune) bool"
.PP
IsSymbol reports whether the rune is a symbolic character. 
.PP
.BR "func IsTitle(" "r" " rune) bool"
.PP
IsTitle reports whether the rune is a title case letter. 
.PP
.BR "func IsUpper(" "r" " rune) bool"
.PP
IsUpper reports whether the rune is an upper case letter. 
.PP
.BR "func SimpleFold(" "r" " rune) rune"
.PP
SimpleFold iterates over Unicode code points equivalent under the Unicode\-defined simple case folding. 
Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune > r if one exists, or else the smallest rune >= 0. 
.PP
For example:    
.PP
.RS
SimpleFold('A') = \(fma'
.sp 0
SimpleFold('a') = \(fmA'
.sp 0
.sp
SimpleFold('K') = \(fmk'
.sp 0
SimpleFold('k') = \(fm\eu212A' (Kelvin symbol, â„ª)
.sp 0
SimpleFold('\eu212A') = \(fmK'
.sp 0
.sp
SimpleFold('1') = \(fm1'
.RE
.PP
.BR "func To(" "_case" " int, " "r" " rune) rune"
.PP
To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase. 
.PP
.BR "func ToLower(" "r" " rune) rune"
.PP
ToLower maps the rune to lower case. 
.PP
.BR "func ToTitle(" "r" " rune) rune"
.PP
ToTitle maps the rune to title case. 
.PP
.BR "func ToUpper(" "r" " rune) rune"
.PP
ToUpper maps the rune to upper case. 
.SH "TYPES"
.SS "CaseRange"
.B type CaseRange struct {
.RS
.B Lo uint32
.sp 0
.B Hi uint32
.sp 0
.B Delta d
.RE
.B }
.PP
CaseRange represents a range of Unicode code points for simple (one code point to one code point) case conversion. 
The range runs from Lo to Hi inclusive, with a fixed stride of 1. 
Deltas are the number to add to the code point to reach the code point for a different case for that character. 
They may be negative. 
If zero, it means the character is in the corresponding case. 
There is a special case representing sequences of alternating corresponding Upper and Lower pairs. 
It appears with a fixed Delta of 
.PP
.RS
{UpperLower, UpperLower, UpperLower}
.RE
.PP
The constant UpperLower has an otherwise impossible delta value. 
.SS "Range16"
.B type Range16 struct {
.RS
.B Lo uint16
.sp 0
.B Hi uint16
.sp 0
.B Stride uint16
.RE
.B }
.PP
Range16 represents of a range of 16\-bit Unicode code points. 
The range runs from Lo to Hi inclusive and has the specified stride. 
.SS "Range32"
.B type Range32 struct {
.RS
.B Lo uint32
.sp 0
.B Hi uint32
.sp 0
.B Stride uint32
.RE
.B }
.PP
Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. 
The range runs from Lo to Hi inclusive and has the specified stride. 
Lo and Hi must always be >= 1<<16. 
.SS "RangeTable"
.B type RangeTable struct {
.RS
.B R16 []Range16
.sp 0
.B R32 []Range32
.sp 0
.B LatinOffset int
.RE
.B }
.PP
RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. 
The ranges are listed in two slices to save space: a slice of 16\-bit ranges and a slice of 32\-bit ranges. 
The two slices must be in sorted order and non\-overlapping. 
Also, R32 should contain only values >= 0x10000 (1<<16). 
.SS "SpecialCase"
.B type SpecialCase []CaseRange
.PP
SpecialCase represents language\-specific case mappings such as Turkish. 
Methods of SpecialCase customize (by overriding) the standard mappings. 
.PP
.B var 
.B AzeriCase 
.sp 0

.sp 0
.PP
.B var 
.B TurkishCase 
.sp 0
.PP
.BR "func (SpecialCase) ToLower(" "r" " rune) rune"
.PP
ToLower maps the rune to lower case giving priority to the special mapping. 
.PP
.BR "func (SpecialCase) ToTitle(" "r" " rune) rune"
.PP
ToTitle maps the rune to title case giving priority to the special mapping. 
.PP
.BR "func (SpecialCase) ToUpper(" "r" " rune) rune"
.PP
ToUpper maps the rune to upper case giving priority to the special mapping. 
.SS "foldPair"
.B type foldPair struct {
.RS
.B From uint16
.sp 0
.B To uint16
.RE
.B }
.PP
caseOrbit is defined in tables.go as []foldPair. 
Right now all the entries fit in uint16, so use uint16. 
If that changes, compilation will fail (the constants in the composite literal will not fit in uint16) and the types here can change to uint32. 
.SH "BUGS"
There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.   
