.\"    Automatically generated by mango(1)
.TH "elf" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
elf \- Package elf implements access to ELF object files.
.SH "SYNOPSIS"
.B import \*(lqelf\(rq
.sp
.B Constants
.sp 0
.RB "func " R_INFO
.sp 0
.RB "func " R_INFO32
.sp 0
.RB "func " R_SYM32
.sp 0
.RB "func " R_SYM64
.sp 0
.RB "func " R_TYPE32
.sp 0
.RB "func " R_TYPE64
.sp 0
.RB "func " ST_INFO
.sp 0
.RB "type " Class
.sp 0
.RS
.RB "func (Class) " GoString
.sp 0
.RB "func (Class) " String
.sp 0
.RE
.RB "type " Data
.sp 0
.RS
.RB "func (Data) " GoString
.sp 0
.RB "func (Data) " String
.sp 0
.RE
.RB "type " Dyn32
.sp 0
.RB "type " Dyn64
.sp 0
.RB "type " DynFlag
.sp 0
.RS
.RB "func (DynFlag) " GoString
.sp 0
.RB "func (DynFlag) " String
.sp 0
.RE
.RB "type " DynTag
.sp 0
.RS
.RB "func (DynTag) " GoString
.sp 0
.RB "func (DynTag) " String
.sp 0
.RE
.RB "type " File
.sp 0
.RS
.RB "func " NewFile
.sp 0
.RB "func " Open
.sp 0
.RB "func (*File) " Close
.sp 0
.RB "func (*File) " DWARF
.sp 0
.RB "func (*File) " DynString
.sp 0
.RB "func (*File) " ImportedLibraries
.sp 0
.RB "func (*File) " ImportedSymbols
.sp 0
.RB "func (*File) " Section
.sp 0
.RB "func (*File) " SectionByType
.sp 0
.RB "func (*File) " Symbols
.sp 0
.RE
.RB "type " FileHeader
.sp 0
.RB "type " FormatError
.sp 0
.RS
.RB "func (*FormatError) " Error
.sp 0
.RE
.RB "type " Header32
.sp 0
.RB "type " Header64
.sp 0
.RB "type " ImportedSymbol
.sp 0
.RB "type " Machine
.sp 0
.RS
.RB "func (Machine) " GoString
.sp 0
.RB "func (Machine) " String
.sp 0
.RE
.RB "type " NType
.sp 0
.RS
.RB "func (NType) " GoString
.sp 0
.RB "func (NType) " String
.sp 0
.RE
.RB "type " OSABI
.sp 0
.RS
.RB "func (OSABI) " GoString
.sp 0
.RB "func (OSABI) " String
.sp 0
.RE
.RB "type " Prog
.sp 0
.RS
.RB "func (*Prog) " Open
.sp 0
.RE
.RB "type " Prog32
.sp 0
.RB "type " Prog64
.sp 0
.RB "type " ProgFlag
.sp 0
.RS
.RB "func (ProgFlag) " GoString
.sp 0
.RB "func (ProgFlag) " String
.sp 0
.RE
.RB "type " ProgHeader
.sp 0
.RB "type " ProgType
.sp 0
.RS
.RB "func (ProgType) " GoString
.sp 0
.RB "func (ProgType) " String
.sp 0
.RE
.RB "type " R_386
.sp 0
.RS
.RB "func (R_386) " GoString
.sp 0
.RB "func (R_386) " String
.sp 0
.RE
.RB "type " R_ALPHA
.sp 0
.RS
.RB "func (R_ALPHA) " GoString
.sp 0
.RB "func (R_ALPHA) " String
.sp 0
.RE
.RB "type " R_ARM
.sp 0
.RS
.RB "func (R_ARM) " GoString
.sp 0
.RB "func (R_ARM) " String
.sp 0
.RE
.RB "type " R_PPC
.sp 0
.RS
.RB "func (R_PPC) " GoString
.sp 0
.RB "func (R_PPC) " String
.sp 0
.RE
.RB "type " R_SPARC
.sp 0
.RS
.RB "func (R_SPARC) " GoString
.sp 0
.RB "func (R_SPARC) " String
.sp 0
.RE
.RB "type " R_X86_64
.sp 0
.RS
.RB "func (R_X86_64) " GoString
.sp 0
.RB "func (R_X86_64) " String
.sp 0
.RE
.RB "type " Rel32
.sp 0
.RB "type " Rel64
.sp 0
.RB "type " Rela32
.sp 0
.RB "type " Rela64
.sp 0
.RB "type " Section
.sp 0
.RS
.RB "func (*Section) " Data
.sp 0
.RB "func (*Section) " Open
.sp 0
.RE
.RB "type " Section32
.sp 0
.RB "type " Section64
.sp 0
.RB "type " SectionFlag
.sp 0
.RS
.RB "func (SectionFlag) " GoString
.sp 0
.RB "func (SectionFlag) " String
.sp 0
.RE
.RB "type " SectionHeader
.sp 0
.RB "type " SectionIndex
.sp 0
.RS
.RB "func (SectionIndex) " GoString
.sp 0
.RB "func (SectionIndex) " String
.sp 0
.RE
.RB "type " SectionType
.sp 0
.RS
.RB "func (SectionType) " GoString
.sp 0
.RB "func (SectionType) " String
.sp 0
.RE
.RB "type " Sym32
.sp 0
.RB "type " Sym64
.sp 0
.RB "type " SymBind
.sp 0
.RS
.RB "func " ST_BIND
.sp 0
.RB "func (SymBind) " GoString
.sp 0
.RB "func (SymBind) " String
.sp 0
.RE
.RB "type " SymType
.sp 0
.RS
.RB "func " ST_TYPE
.sp 0
.RB "func (SymType) " GoString
.sp 0
.RB "func (SymType) " String
.sp 0
.RE
.RB "type " SymVis
.sp 0
.RS
.RB "func " ST_VISIBILITY
.sp 0
.RB "func (SymVis) " GoString
.sp 0
.RB "func (SymVis) " String
.sp 0
.RE
.RB "type " Symbol
.sp 0
.RB "type " Type
.sp 0
.RS
.RB "func (Type) " GoString
.sp 0
.RB "func (Type) " String
.sp 0
.RE
.RB "type " Version
.sp 0
.RS
.RB "func (Version) " GoString
.sp 0
.RB "func (Version) " String
.sp 0
.RE
.RB "type " verneed
.sp 0
.SH "CONSTANTS"
Indexes into the Header.Ident array. 
.PP
.B const (
.RS
.B EI_CLASS 
.sp 0
.B EI_DATA 
.sp 0
.B EI_VERSION 
.sp 0
.B EI_OSABI 
.sp 0
.B EI_ABIVERSION 
.sp 0
.B EI_PAD 
.sp 0
.B EI_NIDENT 
.sp 0
.RE
.B )
.sp 0
Magic number for the elf trampoline, chosen wisely to be an immediate value. 
.PP
.B const 
.B ARM_MAGIC_TRAMP_NUMBER 
.sp 0

.sp 0
Initial magic number for ELF files. 
.PP
.B const 
.B ELFMAG 
.sp 0

.sp 0
.PP
.B const 
.B Sym32Size 
.sp 0

.sp 0
.PP
.B const 
.B Sym64Size 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func R_INFO(" "sym" ", " "typ" " uint32) uint64"
.PP
.BR "func R_INFO32(" "sym" ", " "typ" " uint32) uint32"
.PP
.BR "func R_SYM32(" "info" " uint32) uint32"
.PP
.BR "func R_SYM64(" "info" " uint64) uint32"
.PP
.BR "func R_TYPE32(" "info" " uint32) uint32"
.PP
.BR "func R_TYPE64(" "info" " uint64) uint32"
.PP
.BR "func ST_INFO(" "bind" " SymBind, " "typ" " SymType) uint8"
.SH "TYPES"
.SS "Class"
.B type Class byte
.PP
Class is found in Header.Ident[EI_CLASS] and Header.Class. 
.PP
.B const (
.RS
.B ELFCLASSNONE 
.sp 0
.B ELFCLASS32 
.sp 0
.B ELFCLASS64 
.sp 0
.RE
.B )
.PP
.BR "func (Class) GoString() string"
.PP
.BR "func (Class) String() string"
.SS "Data"
.B type Data byte
.PP
Data is found in Header.Ident[EI_DATA] and Header.Data. 
.PP
.B const (
.RS
.B ELFDATANONE 
.sp 0
.B ELFDATA2LSB 
.sp 0
.B ELFDATA2MSB 
.sp 0
.RE
.B )
.PP
.BR "func (Data) GoString() string"
.PP
.BR "func (Data) String() string"
.SS "Dyn32"
.B type Dyn32 struct {
.RS
.B Tag int32
.sp 0
.B Val uint32
.RE
.B }
.PP
ELF32 Dynamic structure. 
The ".dynamic" section contains an array of them. 
.SS "Dyn64"
.B type Dyn64 struct {
.RS
.B Tag int64
.sp 0
.B Val uint64
.RE
.B }
.PP
ELF64 Dynamic structure. 
The ".dynamic" section contains an array of them. 
.SS "DynFlag"
.B type DynFlag int
.PP
DT_FLAGS values. 
.PP
.B const (
.RS
.B DF_ORIGIN 
.sp 0
.B DF_SYMBOLIC 
.sp 0
.B DF_TEXTREL 
.sp 0
.B DF_BIND_NOW 
.sp 0
.B DF_STATIC_TLS 
.sp 0
.RE
.B )
.PP
.BR "func (DynFlag) GoString() string"
.PP
.BR "func (DynFlag) String() string"
.SS "DynTag"
.B type DynTag int
.PP
Dyn.Tag 
.PP
.B const (
.RS
.B DT_NULL 
.sp 0
.B DT_NEEDED 
.sp 0
.B DT_PLTRELSZ 
.sp 0
.B DT_PLTGOT 
.sp 0
.B DT_HASH 
.sp 0
.B DT_STRTAB 
.sp 0
.B DT_SYMTAB 
.sp 0
.B DT_RELA 
.sp 0
.B DT_RELASZ 
.sp 0
.B DT_RELAENT 
.sp 0
.B DT_STRSZ 
.sp 0
.B DT_SYMENT 
.sp 0
.B DT_INIT 
.sp 0
.B DT_FINI 
.sp 0
.B DT_SONAME 
.sp 0
.B DT_RPATH 
.sp 0
.B DT_SYMBOLIC 
.sp 0
.B DT_REL 
.sp 0
.B DT_RELSZ 
.sp 0
.B DT_RELENT 
.sp 0
.B DT_PLTREL 
.sp 0
.B DT_DEBUG 
.sp 0
.B DT_TEXTREL 
.sp 0
.B DT_JMPREL 
.sp 0
.B DT_BIND_NOW 
.sp 0
.B DT_INIT_ARRAY 
.sp 0
.B DT_FINI_ARRAY 
.sp 0
.B DT_INIT_ARRAYSZ 
.sp 0
.B DT_FINI_ARRAYSZ 
.sp 0
.B DT_RUNPATH 
.sp 0
.B DT_FLAGS 
.sp 0
.B DT_ENCODING 
.sp 0
.B DT_PREINIT_ARRAY 
.sp 0
.B DT_PREINIT_ARRAYSZ 
.sp 0
.B DT_LOOS 
.sp 0
.B DT_HIOS 
.sp 0
.B DT_VERSYM 
.sp 0
.B DT_VERNEED 
.sp 0
.B DT_VERNEEDNUM 
.sp 0
.B DT_LOPROC 
.sp 0
.B DT_HIPROC 
.sp 0
.RE
.B )
.PP
.BR "func (DynTag) GoString() string"
.PP
.BR "func (DynTag) String() string"
.SS "File"
.B type File struct {
.RS
.B FileHeader
.sp 0
.B Sections []*Section
.sp 0
.B Progs []*Prog
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A File represents an open ELF file. 
.PP
.BR "func NewFile(" "r" " io.ReaderAt) (*File, error)"
.PP
NewFile creates a new File for accessing an ELF binary in an underlying reader. 
The ELF binary is expected to start at position 0 in the ReaderAt. 
.PP
.BR "func Open(" "name" " string) (*File, error)"
.PP
Open opens the named file using os.Open and prepares it for use as an ELF binary. 
.PP
.BR "func (*File) Close() error"
.PP
Close closes the File. 
If the File was created using NewFile directly instead of Open, Close has no effect. 
.PP
.BR "func (*File) DWARF() (*dwarf.Data, error)"
.PP
.BR "func (*File) DynString(" "tag" " DynTag) ([]string, error)"
.PP
DynString returns the strings listed for the given tag in the file's dynamic section. 
.PP
The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH. 
.PP
.BR "func (*File) ImportedLibraries() ([]string, error)"
.PP
ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. 
.PP
.BR "func (*File) ImportedSymbols() ([]ImportedSymbol, error)"
.PP
ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. 
It does not return weak symbols. 
.PP
.BR "func (*File) Section(" "name" " string) *Section"
.PP
Section returns a section with the given name, or nil if no such section exists. 
.PP
.BR "func (*File) SectionByType(" "typ" " SectionType) *Section"
.PP
SectionByType returns the first section in f with the given type, or nil if there is no such section. 
.PP
.BR "func (*File) Symbols() ([]Symbol, error)"
.PP
Symbols returns the symbol table for f. 
.PP
For compatibility with Go 1.0, Symbols omits the null symbol at index 0. 
After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x\-1], not symtab[x]. 
.SS "FileHeader"
.B type FileHeader struct {
.RS
.B Class Class
.sp 0
.B Data Data
.sp 0
.B Version Version
.sp 0
.B OSABI OSABI
.sp 0
.B ABIVersion uint8
.sp 0
.B ByteOrder binary.ByteOrder
.sp 0
.B Type Type
.sp 0
.B Machine Machine
.sp 0
.B Entry uint64
.RE
.B }
.PP
A FileHeader represents an ELF file header. 
.SS "FormatError"
.B type FormatError struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*FormatError) Error() string"
.SS "Header32"
.B type Header32 struct {
.RS
.B Ident [EI_NIDENT]byte
.sp 0
.B Type uint16
.sp 0
.B Machine uint16
.sp 0
.B Version uint32
.sp 0
.B Entry uint32
.sp 0
.B Phoff uint32
.sp 0
.B Shoff uint32
.sp 0
.B Flags uint32
.sp 0
.B Ehsize uint16
.sp 0
.B Phentsize uint16
.sp 0
.B Phnum uint16
.sp 0
.B Shentsize uint16
.sp 0
.B Shnum uint16
.sp 0
.B Shstrndx uint16
.RE
.B }
.PP
ELF32 File header. 
.SS "Header64"
.B type Header64 struct {
.RS
.B Ident [EI_NIDENT]byte
.sp 0
.B Type uint16
.sp 0
.B Machine uint16
.sp 0
.B Version uint32
.sp 0
.B Entry uint64
.sp 0
.B Phoff uint64
.sp 0
.B Shoff uint64
.sp 0
.B Flags uint32
.sp 0
.B Ehsize uint16
.sp 0
.B Phentsize uint16
.sp 0
.B Phnum uint16
.sp 0
.B Shentsize uint16
.sp 0
.B Shnum uint16
.sp 0
.B Shstrndx uint16
.RE
.B }
.PP
ELF64 file header. 
.SS "ImportedSymbol"
.B type ImportedSymbol struct {
.RS
.B Name string
.sp 0
.B Version string
.sp 0
.B Library string
.RE
.B }
.SS "Machine"
.B type Machine uint16
.PP
Machine is found in Header.Machine. 
.PP
.B const (
.RS
.B EM_NONE 
.sp 0
.B EM_M32 
.sp 0
.B EM_SPARC 
.sp 0
.B EM_386 
.sp 0
.B EM_68K 
.sp 0
.B EM_88K 
.sp 0
.B EM_860 
.sp 0
.B EM_MIPS 
.sp 0
.B EM_S370 
.sp 0
.B EM_MIPS_RS3_LE 
.sp 0
.B EM_PARISC 
.sp 0
.B EM_VPP500 
.sp 0
.B EM_SPARC32PLUS 
.sp 0
.B EM_960 
.sp 0
.B EM_PPC 
.sp 0
.B EM_PPC64 
.sp 0
.B EM_S390 
.sp 0
.B EM_V800 
.sp 0
.B EM_FR20 
.sp 0
.B EM_RH32 
.sp 0
.B EM_RCE 
.sp 0
.B EM_ARM 
.sp 0
.B EM_SH 
.sp 0
.B EM_SPARCV9 
.sp 0
.B EM_TRICORE 
.sp 0
.B EM_ARC 
.sp 0
.B EM_H8_300 
.sp 0
.B EM_H8_300H 
.sp 0
.B EM_H8S 
.sp 0
.B EM_H8_500 
.sp 0
.B EM_IA_64 
.sp 0
.B EM_MIPS_X 
.sp 0
.B EM_COLDFIRE 
.sp 0
.B EM_68HC12 
.sp 0
.B EM_MMA 
.sp 0
.B EM_PCP 
.sp 0
.B EM_NCPU 
.sp 0
.B EM_NDR1 
.sp 0
.B EM_STARCORE 
.sp 0
.B EM_ME16 
.sp 0
.B EM_ST100 
.sp 0
.B EM_TINYJ 
.sp 0
.B EM_X86_64 
.sp 0
.B EM_486 
.sp 0
.B EM_MIPS_RS4_BE 
.sp 0
.B EM_ALPHA_STD 
.sp 0
.B EM_ALPHA 
.sp 0
.RE
.B )
.PP
.BR "func (Machine) GoString() string"
.PP
.BR "func (Machine) String() string"
.SS "NType"
.B type NType int
.PP
NType values; used in core files. 
.PP
.B const (
.RS
.B NT_PRSTATUS 
.sp 0
.B NT_FPREGSET 
.sp 0
.B NT_PRPSINFO 
.sp 0
.RE
.B )
.PP
.BR "func (NType) GoString() string"
.PP
.BR "func (NType) String() string"
.SS "OSABI"
.B type OSABI byte
.PP
OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI. 
.PP
.B const (
.RS
.B ELFOSABI_NONE 
.sp 0
.B ELFOSABI_HPUX 
.sp 0
.B ELFOSABI_NETBSD 
.sp 0
.B ELFOSABI_LINUX 
.sp 0
.B ELFOSABI_HURD 
.sp 0
.B ELFOSABI_86OPEN 
.sp 0
.B ELFOSABI_SOLARIS 
.sp 0
.B ELFOSABI_AIX 
.sp 0
.B ELFOSABI_IRIX 
.sp 0
.B ELFOSABI_FREEBSD 
.sp 0
.B ELFOSABI_TRU64 
.sp 0
.B ELFOSABI_MODESTO 
.sp 0
.B ELFOSABI_OPENBSD 
.sp 0
.B ELFOSABI_OPENVMS 
.sp 0
.B ELFOSABI_NSK 
.sp 0
.B ELFOSABI_ARM 
.sp 0
.B ELFOSABI_STANDALONE 
.sp 0
.RE
.B )
.PP
.BR "func (OSABI) GoString() string"
.PP
.BR "func (OSABI) String() string"
.SS "Prog"
.B type Prog struct {
.RS
.B ProgHeader
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Prog represents a single ELF program header in an ELF binary. 
.PP
.BR "func (*Prog) Open() io.ReadSeeker"
.PP
Open returns a new ReadSeeker reading the ELF program body. 
.SS "Prog32"
.B type Prog32 struct {
.RS
.B Type uint32
.sp 0
.B Off uint32
.sp 0
.B Vaddr uint32
.sp 0
.B Paddr uint32
.sp 0
.B Filesz uint32
.sp 0
.B Memsz uint32
.sp 0
.B Flags uint32
.sp 0
.B Align uint32
.RE
.B }
.PP
ELF32 Program header. 
.SS "Prog64"
.B type Prog64 struct {
.RS
.B Type uint32
.sp 0
.B Flags uint32
.sp 0
.B Off uint64
.sp 0
.B Vaddr uint64
.sp 0
.B Paddr uint64
.sp 0
.B Filesz uint64
.sp 0
.B Memsz uint64
.sp 0
.B Align uint64
.RE
.B }
.PP
ELF64 Program header. 
.SS "ProgFlag"
.B type ProgFlag uint32
.PP
Prog.Flag    
.PP
.B const (
.RS
.B PF_X 
.sp 0
.B PF_W 
.sp 0
.B PF_R 
.sp 0
.B PF_MASKOS 
.sp 0
.B PF_MASKPROC 
.sp 0
.RE
.B )
.PP
.BR "func (ProgFlag) GoString() string"
.PP
.BR "func (ProgFlag) String() string"
.SS "ProgHeader"
.B type ProgHeader struct {
.RS
.B Type ProgType
.sp 0
.B Flags ProgFlag
.sp 0
.B Off uint64
.sp 0
.B Vaddr uint64
.sp 0
.B Paddr uint64
.sp 0
.B Filesz uint64
.sp 0
.B Memsz uint64
.sp 0
.B Align uint64
.RE
.B }
.PP
A ProgHeader represents a single ELF program header. 
.SS "ProgType"
.B type ProgType int
.PP
Prog.Type    
.PP
.B const (
.RS
.B PT_NULL 
.sp 0
.B PT_LOAD 
.sp 0
.B PT_DYNAMIC 
.sp 0
.B PT_INTERP 
.sp 0
.B PT_NOTE 
.sp 0
.B PT_SHLIB 
.sp 0
.B PT_PHDR 
.sp 0
.B PT_TLS 
.sp 0
.B PT_LOOS 
.sp 0
.B PT_HIOS 
.sp 0
.B PT_LOPROC 
.sp 0
.B PT_HIPROC 
.sp 0
.RE
.B )
.PP
.BR "func (ProgType) GoString() string"
.PP
.BR "func (ProgType) String() string"
.SS "R_386"
.B type R_386 int
.PP
Relocation types for 386. 
.PP
.B const (
.RS
.B R_386_NONE 
.sp 0
.B R_386_32 
.sp 0
.B R_386_PC32 
.sp 0
.B R_386_GOT32 
.sp 0
.B R_386_PLT32 
.sp 0
.B R_386_COPY 
.sp 0
.B R_386_GLOB_DAT 
.sp 0
.B R_386_JMP_SLOT 
.sp 0
.B R_386_RELATIVE 
.sp 0
.B R_386_GOTOFF 
.sp 0
.B R_386_GOTPC 
.sp 0
.B R_386_TLS_TPOFF 
.sp 0
.B R_386_TLS_IE 
.sp 0
.B R_386_TLS_GOTIE 
.sp 0
.B R_386_TLS_LE 
.sp 0
.B R_386_TLS_GD 
.sp 0
.B R_386_TLS_LDM 
.sp 0
.B R_386_TLS_GD_32 
.sp 0
.B R_386_TLS_GD_PUSH 
.sp 0
.B R_386_TLS_GD_CALL 
.sp 0
.B R_386_TLS_GD_POP 
.sp 0
.B R_386_TLS_LDM_32 
.sp 0
.B R_386_TLS_LDM_PUSH 
.sp 0
.B R_386_TLS_LDM_CALL 
.sp 0
.B R_386_TLS_LDM_POP 
.sp 0
.B R_386_TLS_LDO_32 
.sp 0
.B R_386_TLS_IE_32 
.sp 0
.B R_386_TLS_LE_32 
.sp 0
.B R_386_TLS_DTPMOD32 
.sp 0
.B R_386_TLS_DTPOFF32 
.sp 0
.B R_386_TLS_TPOFF32 
.sp 0
.RE
.B )
.PP
.BR "func (R_386) GoString() string"
.PP
.BR "func (R_386) String() string"
.SS "R_ALPHA"
.B type R_ALPHA int
.PP
Relocation types for Alpha. 
.PP
.B const (
.RS
.B R_ALPHA_NONE 
.sp 0
.B R_ALPHA_REFLONG 
.sp 0
.B R_ALPHA_REFQUAD 
.sp 0
.B R_ALPHA_GPREL32 
.sp 0
.B R_ALPHA_LITERAL 
.sp 0
.B R_ALPHA_LITUSE 
.sp 0
.B R_ALPHA_GPDISP 
.sp 0
.B R_ALPHA_BRADDR 
.sp 0
.B R_ALPHA_HINT 
.sp 0
.B R_ALPHA_SREL16 
.sp 0
.B R_ALPHA_SREL32 
.sp 0
.B R_ALPHA_SREL64 
.sp 0
.B R_ALPHA_OP_PUSH 
.sp 0
.B R_ALPHA_OP_STORE 
.sp 0
.B R_ALPHA_OP_PSUB 
.sp 0
.B R_ALPHA_OP_PRSHIFT 
.sp 0
.B R_ALPHA_GPVALUE 
.sp 0
.B R_ALPHA_GPRELHIGH 
.sp 0
.B R_ALPHA_GPRELLOW 
.sp 0
.B R_ALPHA_IMMED_GP_16 
.sp 0
.B R_ALPHA_IMMED_GP_HI32 
.sp 0
.B R_ALPHA_IMMED_SCN_HI32 
.sp 0
.B R_ALPHA_IMMED_BR_HI32 
.sp 0
.B R_ALPHA_IMMED_LO32 
.sp 0
.B R_ALPHA_COPY 
.sp 0
.B R_ALPHA_GLOB_DAT 
.sp 0
.B R_ALPHA_JMP_SLOT 
.sp 0
.B R_ALPHA_RELATIVE 
.sp 0
.RE
.B )
.PP
.BR "func (R_ALPHA) GoString() string"
.PP
.BR "func (R_ALPHA) String() string"
.SS "R_ARM"
.B type R_ARM int
.PP
Relocation types for ARM. 
.PP
.B const (
.RS
.B R_ARM_NONE 
.sp 0
.B R_ARM_PC24 
.sp 0
.B R_ARM_ABS32 
.sp 0
.B R_ARM_REL32 
.sp 0
.B R_ARM_PC13 
.sp 0
.B R_ARM_ABS16 
.sp 0
.B R_ARM_ABS12 
.sp 0
.B R_ARM_THM_ABS5 
.sp 0
.B R_ARM_ABS8 
.sp 0
.B R_ARM_SBREL32 
.sp 0
.B R_ARM_THM_PC22 
.sp 0
.B R_ARM_THM_PC8 
.sp 0
.B R_ARM_AMP_VCALL9 
.sp 0
.B R_ARM_SWI24 
.sp 0
.B R_ARM_THM_SWI8 
.sp 0
.B R_ARM_XPC25 
.sp 0
.B R_ARM_THM_XPC22 
.sp 0
.B R_ARM_COPY 
.sp 0
.B R_ARM_GLOB_DAT 
.sp 0
.B R_ARM_JUMP_SLOT 
.sp 0
.B R_ARM_RELATIVE 
.sp 0
.B R_ARM_GOTOFF 
.sp 0
.B R_ARM_GOTPC 
.sp 0
.B R_ARM_GOT32 
.sp 0
.B R_ARM_PLT32 
.sp 0
.B R_ARM_GNU_VTENTRY 
.sp 0
.B R_ARM_GNU_VTINHERIT 
.sp 0
.B R_ARM_RSBREL32 
.sp 0
.B R_ARM_THM_RPC22 
.sp 0
.B R_ARM_RREL32 
.sp 0
.B R_ARM_RABS32 
.sp 0
.B R_ARM_RPC24 
.sp 0
.B R_ARM_RBASE 
.sp 0
.RE
.B )
.PP
.BR "func (R_ARM) GoString() string"
.PP
.BR "func (R_ARM) String() string"
.SS "R_PPC"
.B type R_PPC int
.PP
Relocation types for PowerPC. 
.PP
.B const (
.RS
.B R_PPC_NONE 
.sp 0
.B R_PPC_ADDR32 
.sp 0
.B R_PPC_ADDR24 
.sp 0
.B R_PPC_ADDR16 
.sp 0
.B R_PPC_ADDR16_LO 
.sp 0
.B R_PPC_ADDR16_HI 
.sp 0
.B R_PPC_ADDR16_HA 
.sp 0
.B R_PPC_ADDR14 
.sp 0
.B R_PPC_ADDR14_BRTAKEN 
.sp 0
.B R_PPC_ADDR14_BRNTAKEN 
.sp 0
.B R_PPC_REL24 
.sp 0
.B R_PPC_REL14 
.sp 0
.B R_PPC_REL14_BRTAKEN 
.sp 0
.B R_PPC_REL14_BRNTAKEN 
.sp 0
.B R_PPC_GOT16 
.sp 0
.B R_PPC_GOT16_LO 
.sp 0
.B R_PPC_GOT16_HI 
.sp 0
.B R_PPC_GOT16_HA 
.sp 0
.B R_PPC_PLTREL24 
.sp 0
.B R_PPC_COPY 
.sp 0
.B R_PPC_GLOB_DAT 
.sp 0
.B R_PPC_JMP_SLOT 
.sp 0
.B R_PPC_RELATIVE 
.sp 0
.B R_PPC_LOCAL24PC 
.sp 0
.B R_PPC_UADDR32 
.sp 0
.B R_PPC_UADDR16 
.sp 0
.B R_PPC_REL32 
.sp 0
.B R_PPC_PLT32 
.sp 0
.B R_PPC_PLTREL32 
.sp 0
.B R_PPC_PLT16_LO 
.sp 0
.B R_PPC_PLT16_HI 
.sp 0
.B R_PPC_PLT16_HA 
.sp 0
.B R_PPC_SDAREL16 
.sp 0
.B R_PPC_SECTOFF 
.sp 0
.B R_PPC_SECTOFF_LO 
.sp 0
.B R_PPC_SECTOFF_HI 
.sp 0
.B R_PPC_SECTOFF_HA 
.sp 0
.B R_PPC_TLS 
.sp 0
.B R_PPC_DTPMOD32 
.sp 0
.B R_PPC_TPREL16 
.sp 0
.B R_PPC_TPREL16_LO 
.sp 0
.B R_PPC_TPREL16_HI 
.sp 0
.B R_PPC_TPREL16_HA 
.sp 0
.B R_PPC_TPREL32 
.sp 0
.B R_PPC_DTPREL16 
.sp 0
.B R_PPC_DTPREL16_LO 
.sp 0
.B R_PPC_DTPREL16_HI 
.sp 0
.B R_PPC_DTPREL16_HA 
.sp 0
.B R_PPC_DTPREL32 
.sp 0
.B R_PPC_GOT_TLSGD16 
.sp 0
.B R_PPC_GOT_TLSGD16_LO 
.sp 0
.B R_PPC_GOT_TLSGD16_HI 
.sp 0
.B R_PPC_GOT_TLSGD16_HA 
.sp 0
.B R_PPC_GOT_TLSLD16 
.sp 0
.B R_PPC_GOT_TLSLD16_LO 
.sp 0
.B R_PPC_GOT_TLSLD16_HI 
.sp 0
.B R_PPC_GOT_TLSLD16_HA 
.sp 0
.B R_PPC_GOT_TPREL16 
.sp 0
.B R_PPC_GOT_TPREL16_LO 
.sp 0
.B R_PPC_GOT_TPREL16_HI 
.sp 0
.B R_PPC_GOT_TPREL16_HA 
.sp 0
.B R_PPC_EMB_NADDR32 
.sp 0
.B R_PPC_EMB_NADDR16 
.sp 0
.B R_PPC_EMB_NADDR16_LO 
.sp 0
.B R_PPC_EMB_NADDR16_HI 
.sp 0
.B R_PPC_EMB_NADDR16_HA 
.sp 0
.B R_PPC_EMB_SDAI16 
.sp 0
.B R_PPC_EMB_SDA2I16 
.sp 0
.B R_PPC_EMB_SDA2REL 
.sp 0
.B R_PPC_EMB_SDA21 
.sp 0
.B R_PPC_EMB_MRKREF 
.sp 0
.B R_PPC_EMB_RELSEC16 
.sp 0
.B R_PPC_EMB_RELST_LO 
.sp 0
.B R_PPC_EMB_RELST_HI 
.sp 0
.B R_PPC_EMB_RELST_HA 
.sp 0
.B R_PPC_EMB_BIT_FLD 
.sp 0
.B R_PPC_EMB_RELSDA 
.sp 0
.RE
.B )
.PP
.BR "func (R_PPC) GoString() string"
.PP
.BR "func (R_PPC) String() string"
.SS "R_SPARC"
.B type R_SPARC int
.PP
Relocation types for SPARC. 
.PP
.B const (
.RS
.B R_SPARC_NONE 
.sp 0
.B R_SPARC_8 
.sp 0
.B R_SPARC_16 
.sp 0
.B R_SPARC_32 
.sp 0
.B R_SPARC_DISP8 
.sp 0
.B R_SPARC_DISP16 
.sp 0
.B R_SPARC_DISP32 
.sp 0
.B R_SPARC_WDISP30 
.sp 0
.B R_SPARC_WDISP22 
.sp 0
.B R_SPARC_HI22 
.sp 0
.B R_SPARC_22 
.sp 0
.B R_SPARC_13 
.sp 0
.B R_SPARC_LO10 
.sp 0
.B R_SPARC_GOT10 
.sp 0
.B R_SPARC_GOT13 
.sp 0
.B R_SPARC_GOT22 
.sp 0
.B R_SPARC_PC10 
.sp 0
.B R_SPARC_PC22 
.sp 0
.B R_SPARC_WPLT30 
.sp 0
.B R_SPARC_COPY 
.sp 0
.B R_SPARC_GLOB_DAT 
.sp 0
.B R_SPARC_JMP_SLOT 
.sp 0
.B R_SPARC_RELATIVE 
.sp 0
.B R_SPARC_UA32 
.sp 0
.B R_SPARC_PLT32 
.sp 0
.B R_SPARC_HIPLT22 
.sp 0
.B R_SPARC_LOPLT10 
.sp 0
.B R_SPARC_PCPLT32 
.sp 0
.B R_SPARC_PCPLT22 
.sp 0
.B R_SPARC_PCPLT10 
.sp 0
.B R_SPARC_10 
.sp 0
.B R_SPARC_11 
.sp 0
.B R_SPARC_64 
.sp 0
.B R_SPARC_OLO10 
.sp 0
.B R_SPARC_HH22 
.sp 0
.B R_SPARC_HM10 
.sp 0
.B R_SPARC_LM22 
.sp 0
.B R_SPARC_PC_HH22 
.sp 0
.B R_SPARC_PC_HM10 
.sp 0
.B R_SPARC_PC_LM22 
.sp 0
.B R_SPARC_WDISP16 
.sp 0
.B R_SPARC_WDISP19 
.sp 0
.B R_SPARC_GLOB_JMP 
.sp 0
.B R_SPARC_7 
.sp 0
.B R_SPARC_5 
.sp 0
.B R_SPARC_6 
.sp 0
.B R_SPARC_DISP64 
.sp 0
.B R_SPARC_PLT64 
.sp 0
.B R_SPARC_HIX22 
.sp 0
.B R_SPARC_LOX10 
.sp 0
.B R_SPARC_H44 
.sp 0
.B R_SPARC_M44 
.sp 0
.B R_SPARC_L44 
.sp 0
.B R_SPARC_REGISTER 
.sp 0
.B R_SPARC_UA64 
.sp 0
.B R_SPARC_UA16 
.sp 0
.RE
.B )
.PP
.BR "func (R_SPARC) GoString() string"
.PP
.BR "func (R_SPARC) String() string"
.SS "R_X86_64"
.B type R_X86_64 int
.PP
Relocation types for x86\-64. 
.PP
.B const (
.RS
.B R_X86_64_NONE 
.sp 0
.B R_X86_64_64 
.sp 0
.B R_X86_64_PC32 
.sp 0
.B R_X86_64_GOT32 
.sp 0
.B R_X86_64_PLT32 
.sp 0
.B R_X86_64_COPY 
.sp 0
.B R_X86_64_GLOB_DAT 
.sp 0
.B R_X86_64_JMP_SLOT 
.sp 0
.B R_X86_64_RELATIVE 
.sp 0
.B R_X86_64_GOTPCREL 
.sp 0
.B R_X86_64_32 
.sp 0
.B R_X86_64_32S 
.sp 0
.B R_X86_64_16 
.sp 0
.B R_X86_64_PC16 
.sp 0
.B R_X86_64_8 
.sp 0
.B R_X86_64_PC8 
.sp 0
.B R_X86_64_DTPMOD64 
.sp 0
.B R_X86_64_DTPOFF64 
.sp 0
.B R_X86_64_TPOFF64 
.sp 0
.B R_X86_64_TLSGD 
.sp 0
.B R_X86_64_TLSLD 
.sp 0
.B R_X86_64_DTPOFF32 
.sp 0
.B R_X86_64_GOTTPOFF 
.sp 0
.B R_X86_64_TPOFF32 
.sp 0
.RE
.B )
.PP
.BR "func (R_X86_64) GoString() string"
.PP
.BR "func (R_X86_64) String() string"
.SS "Rel32"
.B type Rel32 struct {
.RS
.B Off uint32
.sp 0
.B Info uint32
.RE
.B }
.PP
ELF32 Relocations that don't need an addend field. 
.SS "Rel64"
.B type Rel64 struct {
.RS
.B Off uint64
.sp 0
.B Info uint64
.RE
.B }
.PP
ELF64 relocations that don't need an addend field. 
.SS "Rela32"
.B type Rela32 struct {
.RS
.B Off uint32
.sp 0
.B Info uint32
.sp 0
.B Addend int32
.RE
.B }
.PP
ELF32 Relocations that need an addend field. 
.SS "Rela64"
.B type Rela64 struct {
.RS
.B Off uint64
.sp 0
.B Info uint64
.sp 0
.B Addend int64
.RE
.B }
.PP
ELF64 relocations that need an addend field. 
.SS "Section"
.B type Section struct {
.RS
.B SectionHeader
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Section represents a single section in an ELF file. 
.PP
.BR "func (*Section) Data() ([]byte, error)"
.PP
Data reads and returns the contents of the ELF section. 
.PP
.BR "func (*Section) Open() io.ReadSeeker"
.PP
Open returns a new ReadSeeker reading the ELF section. 
.SS "Section32"
.B type Section32 struct {
.RS
.B Name uint32
.sp 0
.B Type uint32
.sp 0
.B Flags uint32
.sp 0
.B Addr uint32
.sp 0
.B Off uint32
.sp 0
.B Size uint32
.sp 0
.B Link uint32
.sp 0
.B Info uint32
.sp 0
.B Addralign uint32
.sp 0
.B Entsize uint32
.RE
.B }
.PP
ELF32 Section header. 
.SS "Section64"
.B type Section64 struct {
.RS
.B Name uint32
.sp 0
.B Type uint32
.sp 0
.B Flags uint64
.sp 0
.B Addr uint64
.sp 0
.B Off uint64
.sp 0
.B Size uint64
.sp 0
.B Link uint32
.sp 0
.B Info uint32
.sp 0
.B Addralign uint64
.sp 0
.B Entsize uint64
.RE
.B }
.PP
ELF64 Section header. 
.SS "SectionFlag"
.B type SectionFlag uint32
.PP
Section flags. 
.PP
.B const (
.RS
.B SHF_WRITE 
.sp 0
.B SHF_ALLOC 
.sp 0
.B SHF_EXECINSTR 
.sp 0
.B SHF_MERGE 
.sp 0
.B SHF_STRINGS 
.sp 0
.B SHF_INFO_LINK 
.sp 0
.B SHF_LINK_ORDER 
.sp 0
.B SHF_OS_NONCONFORMING 
.sp 0
.B SHF_GROUP 
.sp 0
.B SHF_TLS 
.sp 0
.B SHF_MASKOS 
.sp 0
.B SHF_MASKPROC 
.sp 0
.RE
.B )
.PP
.BR "func (SectionFlag) GoString() string"
.PP
.BR "func (SectionFlag) String() string"
.SS "SectionHeader"
.B type SectionHeader struct {
.RS
.B Name string
.sp 0
.B Type SectionType
.sp 0
.B Flags SectionFlag
.sp 0
.B Addr uint64
.sp 0
.B Offset uint64
.sp 0
.B Size uint64
.sp 0
.B Link uint32
.sp 0
.B Info uint32
.sp 0
.B Addralign uint64
.sp 0
.B Entsize uint64
.RE
.B }
.PP
A SectionHeader represents a single ELF section header. 
.SS "SectionIndex"
.B type SectionIndex int
.PP
Special section indices. 
.PP
.B const (
.RS
.B SHN_UNDEF 
.sp 0
.B SHN_LORESERVE 
.sp 0
.B SHN_LOPROC 
.sp 0
.B SHN_HIPROC 
.sp 0
.B SHN_LOOS 
.sp 0
.B SHN_HIOS 
.sp 0
.B SHN_ABS 
.sp 0
.B SHN_COMMON 
.sp 0
.B SHN_XINDEX 
.sp 0
.B SHN_HIRESERVE 
.sp 0
.RE
.B )
.PP
.BR "func (SectionIndex) GoString() string"
.PP
.BR "func (SectionIndex) String() string"
.SS "SectionType"
.B type SectionType uint32
.PP
Section type. 
.PP
.B const (
.RS
.B SHT_NULL 
.sp 0
.B SHT_PROGBITS 
.sp 0
.B SHT_SYMTAB 
.sp 0
.B SHT_STRTAB 
.sp 0
.B SHT_RELA 
.sp 0
.B SHT_HASH 
.sp 0
.B SHT_DYNAMIC 
.sp 0
.B SHT_NOTE 
.sp 0
.B SHT_NOBITS 
.sp 0
.B SHT_REL 
.sp 0
.B SHT_SHLIB 
.sp 0
.B SHT_DYNSYM 
.sp 0
.B SHT_INIT_ARRAY 
.sp 0
.B SHT_FINI_ARRAY 
.sp 0
.B SHT_PREINIT_ARRAY 
.sp 0
.B SHT_GROUP 
.sp 0
.B SHT_SYMTAB_SHNDX 
.sp 0
.B SHT_LOOS 
.sp 0
.B SHT_GNU_ATTRIBUTES 
.sp 0
.B SHT_GNU_HASH 
.sp 0
.B SHT_GNU_LIBLIST 
.sp 0
.B SHT_GNU_VERDEF 
.sp 0
.B SHT_GNU_VERNEED 
.sp 0
.B SHT_GNU_VERSYM 
.sp 0
.B SHT_HIOS 
.sp 0
.B SHT_LOPROC 
.sp 0
.B SHT_HIPROC 
.sp 0
.B SHT_LOUSER 
.sp 0
.B SHT_HIUSER 
.sp 0
.RE
.B )
.PP
.BR "func (SectionType) GoString() string"
.PP
.BR "func (SectionType) String() string"
.SS "Sym32"
.B type Sym32 struct {
.RS
.B Name uint32
.sp 0
.B Value uint32
.sp 0
.B Size uint32
.sp 0
.B Info uint8
.sp 0
.B Other uint8
.sp 0
.B Shndx uint16
.RE
.B }
.PP
ELF32 Symbol. 
.SS "Sym64"
.B type Sym64 struct {
.RS
.B Name uint32
.sp 0
.B Info uint8
.sp 0
.B Other uint8
.sp 0
.B Shndx uint16
.sp 0
.B Value uint64
.sp 0
.B Size uint64
.RE
.B }
.PP
ELF64 symbol table entries. 
.SS "SymBind"
.B type SymBind int
.PP
Symbol Binding 
.B \-
ELFNN_ST_BIND 
.B \-
st_info    
.PP
.B const (
.RS
.B STB_LOCAL 
.sp 0
.B STB_GLOBAL 
.sp 0
.B STB_WEAK 
.sp 0
.B STB_LOOS 
.sp 0
.B STB_HIOS 
.sp 0
.B STB_LOPROC 
.sp 0
.B STB_HIPROC 
.sp 0
.RE
.B )
.PP
.BR "func ST_BIND(" "info" " uint8) SymBind"
.PP
.BR "func (SymBind) GoString() string"
.PP
.BR "func (SymBind) String() string"
.SS "SymType"
.B type SymType int
.PP
Symbol type 
.B \-
ELFNN_ST_TYPE 
.B \-
st_info    
.PP
.B const (
.RS
.B STT_NOTYPE 
.sp 0
.B STT_OBJECT 
.sp 0
.B STT_FUNC 
.sp 0
.B STT_SECTION 
.sp 0
.B STT_FILE 
.sp 0
.B STT_COMMON 
.sp 0
.B STT_TLS 
.sp 0
.B STT_LOOS 
.sp 0
.B STT_HIOS 
.sp 0
.B STT_LOPROC 
.sp 0
.B STT_HIPROC 
.sp 0
.RE
.B )
.PP
.BR "func ST_TYPE(" "info" " uint8) SymType"
.PP
.BR "func (SymType) GoString() string"
.PP
.BR "func (SymType) String() string"
.SS "SymVis"
.B type SymVis int
.PP
Symbol visibility 
.B \-
ELFNN_ST_VISIBILITY 
.B \-
st_other    
.PP
.B const (
.RS
.B STV_DEFAULT 
.sp 0
.B STV_INTERNAL 
.sp 0
.B STV_HIDDEN 
.sp 0
.B STV_PROTECTED 
.sp 0
.RE
.B )
.PP
.BR "func ST_VISIBILITY(" "other" " uint8) SymVis"
.PP
.BR "func (SymVis) GoString() string"
.PP
.BR "func (SymVis) String() string"
.SS "Symbol"
.B type Symbol struct {
.RS
.B Name string
.sp 0
.B Info, Other byte
.sp 0
.B Section SectionIndex
.sp 0
.B Value, Size uint64
.RE
.B }
.PP
A Symbol represents an entry in an ELF symbol table section. 
.SS "Type"
.B type Type uint16
.PP
Type is found in Header.Type. 
.PP
.B const (
.RS
.B ET_NONE 
.sp 0
.B ET_REL 
.sp 0
.B ET_EXEC 
.sp 0
.B ET_DYN 
.sp 0
.B ET_CORE 
.sp 0
.B ET_LOOS 
.sp 0
.B ET_HIOS 
.sp 0
.B ET_LOPROC 
.sp 0
.B ET_HIPROC 
.sp 0
.RE
.B )
.PP
.BR "func (Type) GoString() string"
.PP
.BR "func (Type) String() string"
.SS "Version"
.B type Version byte
.PP
Version is found in Header.Ident[EI_VERSION] and Header.Version. 
.PP
.B const (
.RS
.B EV_NONE 
.sp 0
.B EV_CURRENT 
.sp 0
.RE
.B )
.PP
.BR "func (Version) GoString() string"
.PP
.BR "func (Version) String() string"
.SS "verneed"
.B type verneed struct {
.RS
.B File string
.sp 0
.B Name string
.RE
.B }
