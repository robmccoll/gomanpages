.\"    Automatically generated by mango(1)
.TH "image" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
image \- Package image implements a basic 2-D image library.
.SH "SYNOPSIS"
.B import \*(lqimage\(rq
.sp
.B Variables
.sp 0
.RB "func " RegisterFormat
.sp 0
.RB "type " Alpha
.sp 0
.RS
.RB "func " NewAlpha
.sp 0
.RB "func (*Alpha) " At
.sp 0
.RB "func (*Alpha) " Bounds
.sp 0
.RB "func (*Alpha) " ColorModel
.sp 0
.RB "func (*Alpha) " Opaque
.sp 0
.RB "func (*Alpha) " PixOffset
.sp 0
.RB "func (*Alpha) " Set
.sp 0
.RB "func (*Alpha) " SetAlpha
.sp 0
.RB "func (*Alpha) " SubImage
.sp 0
.RE
.RB "type " Alpha16
.sp 0
.RS
.RB "func " NewAlpha16
.sp 0
.RB "func (*Alpha16) " At
.sp 0
.RB "func (*Alpha16) " Bounds
.sp 0
.RB "func (*Alpha16) " ColorModel
.sp 0
.RB "func (*Alpha16) " Opaque
.sp 0
.RB "func (*Alpha16) " PixOffset
.sp 0
.RB "func (*Alpha16) " Set
.sp 0
.RB "func (*Alpha16) " SetAlpha16
.sp 0
.RB "func (*Alpha16) " SubImage
.sp 0
.RE
.RB "type " Config
.sp 0
.RS
.RB "func " DecodeConfig
.sp 0
.RE
.RB "type " Gray
.sp 0
.RS
.RB "func " NewGray
.sp 0
.RB "func (*Gray) " At
.sp 0
.RB "func (*Gray) " Bounds
.sp 0
.RB "func (*Gray) " ColorModel
.sp 0
.RB "func (*Gray) " Opaque
.sp 0
.RB "func (*Gray) " PixOffset
.sp 0
.RB "func (*Gray) " Set
.sp 0
.RB "func (*Gray) " SetGray
.sp 0
.RB "func (*Gray) " SubImage
.sp 0
.RE
.RB "type " Gray16
.sp 0
.RS
.RB "func " NewGray16
.sp 0
.RB "func (*Gray16) " At
.sp 0
.RB "func (*Gray16) " Bounds
.sp 0
.RB "func (*Gray16) " ColorModel
.sp 0
.RB "func (*Gray16) " Opaque
.sp 0
.RB "func (*Gray16) " PixOffset
.sp 0
.RB "func (*Gray16) " Set
.sp 0
.RB "func (*Gray16) " SetGray16
.sp 0
.RB "func (*Gray16) " SubImage
.sp 0
.RE
.RB "type " Image
.sp 0
.RS
.RB "func " Decode
.sp 0
.RE
.RB "type " NRGBA
.sp 0
.RS
.RB "func " NewNRGBA
.sp 0
.RB "func (*NRGBA) " At
.sp 0
.RB "func (*NRGBA) " Bounds
.sp 0
.RB "func (*NRGBA) " ColorModel
.sp 0
.RB "func (*NRGBA) " Opaque
.sp 0
.RB "func (*NRGBA) " PixOffset
.sp 0
.RB "func (*NRGBA) " Set
.sp 0
.RB "func (*NRGBA) " SetNRGBA
.sp 0
.RB "func (*NRGBA) " SubImage
.sp 0
.RE
.RB "type " NRGBA64
.sp 0
.RS
.RB "func " NewNRGBA64
.sp 0
.RB "func (*NRGBA64) " At
.sp 0
.RB "func (*NRGBA64) " Bounds
.sp 0
.RB "func (*NRGBA64) " ColorModel
.sp 0
.RB "func (*NRGBA64) " Opaque
.sp 0
.RB "func (*NRGBA64) " PixOffset
.sp 0
.RB "func (*NRGBA64) " Set
.sp 0
.RB "func (*NRGBA64) " SetNRGBA64
.sp 0
.RB "func (*NRGBA64) " SubImage
.sp 0
.RE
.RB "type " Paletted
.sp 0
.RS
.RB "func " NewPaletted
.sp 0
.RB "func (*Paletted) " At
.sp 0
.RB "func (*Paletted) " Bounds
.sp 0
.RB "func (*Paletted) " ColorIndexAt
.sp 0
.RB "func (*Paletted) " ColorModel
.sp 0
.RB "func (*Paletted) " Opaque
.sp 0
.RB "func (*Paletted) " PixOffset
.sp 0
.RB "func (*Paletted) " Set
.sp 0
.RB "func (*Paletted) " SetColorIndex
.sp 0
.RB "func (*Paletted) " SubImage
.sp 0
.RE
.RB "type " PalettedImage
.sp 0
.RB "type " Point
.sp 0
.RS
.RB "func " Pt
.sp 0
.RB "func (Point) " Add
.sp 0
.RB "func (Point) " Div
.sp 0
.RB "func (Point) " Eq
.sp 0
.RB "func (Point) " In
.sp 0
.RB "func (Point) " Mod
.sp 0
.RB "func (Point) " Mul
.sp 0
.RB "func (Point) " String
.sp 0
.RB "func (Point) " Sub
.sp 0
.RE
.RB "type " RGBA
.sp 0
.RS
.RB "func " NewRGBA
.sp 0
.RB "func (*RGBA) " At
.sp 0
.RB "func (*RGBA) " Bounds
.sp 0
.RB "func (*RGBA) " ColorModel
.sp 0
.RB "func (*RGBA) " Opaque
.sp 0
.RB "func (*RGBA) " PixOffset
.sp 0
.RB "func (*RGBA) " Set
.sp 0
.RB "func (*RGBA) " SetRGBA
.sp 0
.RB "func (*RGBA) " SubImage
.sp 0
.RE
.RB "type " RGBA64
.sp 0
.RS
.RB "func " NewRGBA64
.sp 0
.RB "func (*RGBA64) " At
.sp 0
.RB "func (*RGBA64) " Bounds
.sp 0
.RB "func (*RGBA64) " ColorModel
.sp 0
.RB "func (*RGBA64) " Opaque
.sp 0
.RB "func (*RGBA64) " PixOffset
.sp 0
.RB "func (*RGBA64) " Set
.sp 0
.RB "func (*RGBA64) " SetRGBA64
.sp 0
.RB "func (*RGBA64) " SubImage
.sp 0
.RE
.RB "type " Rectangle
.sp 0
.RS
.RB "func " Rect
.sp 0
.RB "func (Rectangle) " Add
.sp 0
.RB "func (Rectangle) " Canon
.sp 0
.RB "func (Rectangle) " Dx
.sp 0
.RB "func (Rectangle) " Dy
.sp 0
.RB "func (Rectangle) " Empty
.sp 0
.RB "func (Rectangle) " Eq
.sp 0
.RB "func (Rectangle) " In
.sp 0
.RB "func (Rectangle) " Inset
.sp 0
.RB "func (Rectangle) " Intersect
.sp 0
.RB "func (Rectangle) " Overlaps
.sp 0
.RB "func (Rectangle) " Size
.sp 0
.RB "func (Rectangle) " String
.sp 0
.RB "func (Rectangle) " Sub
.sp 0
.RB "func (Rectangle) " Union
.sp 0
.RE
.RB "type " Uniform
.sp 0
.RS
.RB "func " NewUniform
.sp 0
.RB "func (*Uniform) " At
.sp 0
.RB "func (*Uniform) " Bounds
.sp 0
.RB "func (*Uniform) " ColorModel
.sp 0
.RB "func (*Uniform) " Convert
.sp 0
.RB "func (*Uniform) " Opaque
.sp 0
.RB "func (*Uniform) " RGBA
.sp 0
.RE
.RB "type " YCbCr
.sp 0
.RS
.RB "func " NewYCbCr
.sp 0
.RB "func (*YCbCr) " At
.sp 0
.RB "func (*YCbCr) " Bounds
.sp 0
.RB "func (*YCbCr) " COffset
.sp 0
.RB "func (*YCbCr) " ColorModel
.sp 0
.RB "func (*YCbCr) " Opaque
.sp 0
.RB "func (*YCbCr) " SubImage
.sp 0
.RB "func (*YCbCr) " YOffset
.sp 0
.RE
.RB "type " YCbCrSubsampleRatio
.sp 0
.RS
.RB "func (YCbCrSubsampleRatio) " String
.sp 0
.RE
.RB "type " reader
.sp 0
.RS
.RE
.SH "DESCRIPTION"
The fundamental interface is called Image. 
An Image contains colors, which are described in the image/color package. 
.PP
Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. 
Decoding any particular image format requires the prior registration of a decoder function. 
Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have 
.PP
.RS
import _ "image/png"
.RE
.PP
in a program's main package. 
The _ means to import a package purely for its initialization side effects. 
.PP
See "The Go image package" for more details: http://golang.org/doc/articles/image_package.html 
.SH "VARIABLES"
.PP
.B var (
.RS
.B Black 
.sp 0
.B White 
.sp 0
.B Transparent 
.sp 0
.B Opaque 
.sp 0
.RE
.B )
.sp 0
ErrFormat indicates that decoding encountered an unknown format. 
.PP
.B var 
.B ErrFormat 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func RegisterFormat(" "name" ", " "magic" " string, " "decode" " func(io.Reader) (Image, error), " "decodeConfig" " func(io.Reader) (Config, error))"
.PP
RegisterFormat registers an image format for use by Decode. 
Name is the name of the format, like "jpeg" or "png". 
Magic is the magic prefix that identifies the format's encoding. 
The magic string can contain "?" wildcards that each match any one byte. 
Decode is the function that decodes the encoded image. 
DecodeConfig is the function that decodes just its configuration. 
.SH "TYPES"
.SS "Alpha"
.B type Alpha struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
Alpha is an in\-memory image whose At method returns color.Alpha values. 
.PP
.BR "func NewAlpha(" "r" " Rectangle) *Alpha"
.PP
NewAlpha returns a new Alpha with the given bounds. 
.PP
.BR "func (*Alpha) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*Alpha) Bounds() Rectangle"
.PP
.BR "func (*Alpha) ColorModel() color.Model"
.PP
.BR "func (*Alpha) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*Alpha) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*Alpha) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*Alpha) SetAlpha(" "x" ", " "y" " int, " "c" " color.Alpha)"
.PP
.BR "func (*Alpha) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "Alpha16"
.B type Alpha16 struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
Alpha16 is an in\-memory image whose At method returns color.Alpha64 values. 
.PP
.BR "func NewAlpha16(" "r" " Rectangle) *Alpha16"
.PP
NewAlpha16 returns a new Alpha16 with the given bounds. 
.PP
.BR "func (*Alpha16) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*Alpha16) Bounds() Rectangle"
.PP
.BR "func (*Alpha16) ColorModel() color.Model"
.PP
.BR "func (*Alpha16) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*Alpha16) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*Alpha16) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*Alpha16) SetAlpha16(" "x" ", " "y" " int, " "c" " color.Alpha16)"
.PP
.BR "func (*Alpha16) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "Config"
.B type Config struct {
.RS
.B ColorModel color.Model
.sp 0
.B Width, Height int
.RE
.B }
.PP
Config holds an image's color model and dimensions. 
.PP
.BR "func DecodeConfig(" "r" " io.Reader) (Config, string, error)"
.PP
DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. 
The string returned is the format name used during format registration. 
Format registration is typically done by an init function in the codec\-specific package. 
.SS "Gray"
.B type Gray struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
Gray is an in\-memory image whose At method returns color.Gray values. 
.PP
.BR "func NewGray(" "r" " Rectangle) *Gray"
.PP
NewGray returns a new Gray with the given bounds. 
.PP
.BR "func (*Gray) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*Gray) Bounds() Rectangle"
.PP
.BR "func (*Gray) ColorModel() color.Model"
.PP
.BR "func (*Gray) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*Gray) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*Gray) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*Gray) SetGray(" "x" ", " "y" " int, " "c" " color.Gray)"
.PP
.BR "func (*Gray) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "Gray16"
.B type Gray16 struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
Gray16 is an in\-memory image whose At method returns color.Gray16 values. 
.PP
.BR "func NewGray16(" "r" " Rectangle) *Gray16"
.PP
NewGray16 returns a new Gray16 with the given bounds. 
.PP
.BR "func (*Gray16) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*Gray16) Bounds() Rectangle"
.PP
.BR "func (*Gray16) ColorModel() color.Model"
.PP
.BR "func (*Gray16) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*Gray16) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*Gray16) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*Gray16) SetGray16(" "x" ", " "y" " int, " "c" " color.Gray16)"
.PP
.BR "func (*Gray16) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "Image"
.B type Image interface {
.RS
.B ColorModel() color.Model
.sp 0
.B Bounds() Rectangle
.sp 0
.B At(x, y int) color.Color
.sp 0
.RE
.B }
.PP
Image is a finite rectangular grid of color.Color values taken from a color model. 
.PP
.BR "func Decode(" "r" " io.Reader) (Image, string, error)"
.PP
Decode decodes an image that has been encoded in a registered format. 
The string returned is the format name used during format registration. 
Format registration is typically done by an init function in the codec\- specific package. 
.SS "NRGBA"
.B type NRGBA struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
NRGBA is an in\-memory image whose At method returns color.NRGBA values. 
.PP
.BR "func NewNRGBA(" "r" " Rectangle) *NRGBA"
.PP
NewNRGBA returns a new NRGBA with the given bounds. 
.PP
.BR "func (*NRGBA) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*NRGBA) Bounds() Rectangle"
.PP
.BR "func (*NRGBA) ColorModel() color.Model"
.PP
.BR "func (*NRGBA) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*NRGBA) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*NRGBA) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*NRGBA) SetNRGBA(" "x" ", " "y" " int, " "c" " color.NRGBA)"
.PP
.BR "func (*NRGBA) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "NRGBA64"
.B type NRGBA64 struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
NRGBA64 is an in\-memory image whose At method returns color.NRGBA64 values. 
.PP
.BR "func NewNRGBA64(" "r" " Rectangle) *NRGBA64"
.PP
NewNRGBA64 returns a new NRGBA64 with the given bounds. 
.PP
.BR "func (*NRGBA64) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*NRGBA64) Bounds() Rectangle"
.PP
.BR "func (*NRGBA64) ColorModel() color.Model"
.PP
.BR "func (*NRGBA64) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*NRGBA64) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*NRGBA64) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*NRGBA64) SetNRGBA64(" "x" ", " "y" " int, " "c" " color.NRGBA64)"
.PP
.BR "func (*NRGBA64) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "Paletted"
.B type Paletted struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.sp 0
.B Palette color.Palette
.RE
.B }
.PP
Paletted is an in\-memory image of uint8 indices into a given palette. 
.PP
.BR "func NewPaletted(" "r" " Rectangle, " "p" " color.Palette) *Paletted"
.PP
NewPaletted returns a new Paletted with the given width, height and palette. 
.PP
.BR "func (*Paletted) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*Paletted) Bounds() Rectangle"
.PP
.BR "func (*Paletted) ColorIndexAt(" "x" ", " "y" " int) uint8"
.PP
.BR "func (*Paletted) ColorModel() color.Model"
.PP
.BR "func (*Paletted) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*Paletted) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*Paletted) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*Paletted) SetColorIndex(" "x" ", " "y" " int, " "index" " uint8)"
.PP
.BR "func (*Paletted) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "PalettedImage"
.B type PalettedImage interface {
.RS
.B ColorIndexAt(x, y int) uint8
.sp 0
.B Image
.sp 0
.RE
.B }
.PP
PalettedImage is an image whose colors may come from a limited palette. 
If m is a PalettedImage and m.ColorModel() returns a PalettedColorModel p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. 
If m's color model is not a PalettedColorModel, then ColorIndexAt's behavior is undefined. 
.SS "Point"
.B type Point struct {
.RS
.B X, Y int
.RE
.B }
.PP
A Point is an X, Y coordinate pair. 
The axes increase right and down. 
ZP is the zero Point. 
.PP
.B var 
.B ZP 
.sp 0
.PP
.BR "func Pt(" "X" ", " "Y" " int) Point"
.PP
Pt is shorthand for Point{X, Y}. 
.PP
.BR "func (Point) Add(" "q" " Point) Point"
.PP
Add returns the vector p+q. 
.PP
.BR "func (Point) Div(" "k" " int) Point"
.PP
Div returns the vector p/k. 
.PP
.BR "func (Point) Eq(" "q" " Point) bool"
.PP
Eq reports whether p and q are equal. 
.PP
.BR "func (Point) In(" "r" " Rectangle) bool"
.PP
In reports whether p is in r. 
.PP
.BR "func (Point) Mod(" "r" " Rectangle) Point"
.PP
Mod returns the point q in r such that p.X\-q.X is a multiple of r's width and p.Y\-q.Y is a multiple of r's height. 
.PP
.BR "func (Point) Mul(" "k" " int) Point"
.PP
Mul returns the vector p*k. 
.PP
.BR "func (Point) String() string"
.PP
String returns a string representation of p like "(3,4)". 
.PP
.BR "func (Point) Sub(" "q" " Point) Point"
.PP
Sub returns the vector p\-q. 
.SS "RGBA"
.B type RGBA struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
RGBA is an in\-memory image whose At method returns color.RGBA values. 
.PP
.BR "func NewRGBA(" "r" " Rectangle) *RGBA"
.PP
NewRGBA returns a new RGBA with the given bounds. 
.PP
.BR "func (*RGBA) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*RGBA) Bounds() Rectangle"
.PP
.BR "func (*RGBA) ColorModel() color.Model"
.PP
.BR "func (*RGBA) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*RGBA) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*RGBA) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*RGBA) SetRGBA(" "x" ", " "y" " int, " "c" " color.RGBA)"
.PP
.BR "func (*RGBA) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "RGBA64"
.B type RGBA64 struct {
.RS
.B Pix []uint8
.sp 0
.B Stride int
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
RGBA64 is an in\-memory image whose At method returns color.RGBA64 values. 
.PP
.BR "func NewRGBA64(" "r" " Rectangle) *RGBA64"
.PP
NewRGBA64 returns a new RGBA64 with the given bounds. 
.PP
.BR "func (*RGBA64) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*RGBA64) Bounds() Rectangle"
.PP
.BR "func (*RGBA64) ColorModel() color.Model"
.PP
.BR "func (*RGBA64) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*RGBA64) PixOffset(" "x" ", " "y" " int) int"
.PP
PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). 
.PP
.BR "func (*RGBA64) Set(" "x" ", " "y" " int, " "c" " color.Color)"
.PP
.BR "func (*RGBA64) SetRGBA64(" "x" ", " "y" " int, " "c" " color.RGBA64)"
.PP
.BR "func (*RGBA64) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.SS "Rectangle"
.B type Rectangle struct {
.RS
.B Min, Max Point
.RE
.B }
.PP
A Rectangle contains the points with Min.X <= X < Max.X, Min.Y <= Y < Max.Y. 
It is well\-formed if Min.X <= Max.X and likewise for Y. 
Points are always well\-formed. 
A rectangle's methods always return well\-formed outputs for well\-formed inputs. 
ZR is the zero Rectangle. 
.PP
.B var 
.B ZR 
.sp 0
.PP
.BR "func Rect(" "x0" ", " "y0" ", " "x1" ", " "y1" " int) Rectangle"
.PP
Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. 
.PP
.BR "func (Rectangle) Add(" "p" " Point) Rectangle"
.PP
Add returns the rectangle r translated by p. 
.PP
.BR "func (Rectangle) Canon() Rectangle"
.PP
Canon returns the canonical version of r. 
The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well\-formed. 
.PP
.BR "func (Rectangle) Dx() int"
.PP
Dx returns r's width. 
.PP
.BR "func (Rectangle) Dy() int"
.PP
Dy returns r's height. 
.PP
.BR "func (Rectangle) Empty() bool"
.PP
Empty reports whether the rectangle contains no points. 
.PP
.BR "func (Rectangle) Eq(" "s" " Rectangle) bool"
.PP
Eq reports whether r and s are equal. 
.PP
.BR "func (Rectangle) In(" "s" " Rectangle) bool"
.PP
In reports whether every point in r is in s. 
.PP
.BR "func (Rectangle) Inset(" "n" " int) Rectangle"
.PP
Inset returns the rectangle r inset by n, which may be negative. 
If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned. 
.PP
.BR "func (Rectangle) Intersect(" "s" " Rectangle) Rectangle"
.PP
Intersect returns the largest rectangle contained by both r and s. 
If the two rectangles do not overlap then the zero rectangle will be returned. 
.PP
.BR "func (Rectangle) Overlaps(" "s" " Rectangle) bool"
.PP
Overlaps reports whether r and s have a non\-empty intersection. 
.PP
.BR "func (Rectangle) Size() Point"
.PP
Size returns r's width and height. 
.PP
.BR "func (Rectangle) String() string"
.PP
String returns a string representation of r like "(3,4)\-(6,5)". 
.PP
.BR "func (Rectangle) Sub(" "p" " Point) Rectangle"
.PP
Sub returns the rectangle r translated by 
.B \-p.
.PP
.BR "func (Rectangle) Union(" "s" " Rectangle) Rectangle"
.PP
Union returns the smallest rectangle that contains both r and s. 
.SS "Uniform"
.B type Uniform struct {
.RS
.B C color.Color
.RE
.B }
.PP
Uniform is an infinite\-sized Image of uniform color. 
It implements the color.Color, color.Model, and Image interfaces. 
.PP
.BR "func NewUniform(" "c" " color.Color) *Uniform"
.PP
.BR "func (*Uniform) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*Uniform) Bounds() Rectangle"
.PP
.BR "func (*Uniform) ColorModel() color.Model"
.PP
.BR "func (*Uniform) Convert(color.Color) color.Color"
.PP
.BR "func (*Uniform) Opaque() bool"
.PP
Opaque scans the entire image and reports whether it is fully opaque. 
.PP
.BR "func (*Uniform) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "YCbCr"
.B type YCbCr struct {
.RS
.B Y, Cb, Cr []uint8
.sp 0
.B YStride int
.sp 0
.B CStride int
.sp 0
.B SubsampleRatio YCbCrSubsampleRatio
.sp 0
.B Rect Rectangle
.RE
.B }
.PP
YCbCr is an in\-memory image of Y'CbCr colors. 
There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. 
YStride is the Y slice index delta between vertically adjacent pixels. 
CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. 
It is not an absolute requirement, but YStride and 
.BR len (Y)
are typically multiples of 8, and: 
.PP
.RS
For 4:4:4, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/1.
.sp 0
For 4:2:2, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/2.
.sp 0
For 4:2:0, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/4.
.sp 0
For 4:4:0, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/2.
.RE
.PP
.BR "func NewYCbCr(" "r" " Rectangle, " "subsampleRatio" " YCbCrSubsampleRatio) *YCbCr"
.PP
NewYCbCr returns a new YCbCr with the given bounds and subsample ratio. 
.PP
.BR "func (*YCbCr) At(" "x" ", " "y" " int) color.Color"
.PP
.BR "func (*YCbCr) Bounds() Rectangle"
.PP
.BR "func (*YCbCr) COffset(" "x" ", " "y" " int) int"
.PP
COffset returns the index of the first element of Cb or Cr that corresponds to the pixel at (x, y). 
.PP
.BR "func (*YCbCr) ColorModel() color.Model"
.PP
.BR "func (*YCbCr) Opaque() bool"
.PP
.BR "func (*YCbCr) SubImage(" "r" " Rectangle) Image"
.PP
SubImage returns an image representing the portion of the image p visible through r. 
The returned value shares pixels with the original image. 
.PP
.BR "func (*YCbCr) YOffset(" "x" ", " "y" " int) int"
.PP
YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y). 
.SS "YCbCrSubsampleRatio"
.B type YCbCrSubsampleRatio int
.PP
YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image. 
.PP
.B const (
.RS
.B YCbCrSubsampleRatio444 
.sp 0
.B YCbCrSubsampleRatio422 
.sp 0
.B YCbCrSubsampleRatio420 
.sp 0
.B YCbCrSubsampleRatio440 
.sp 0
.RE
.B )
.PP
.BR "func (YCbCrSubsampleRatio) String() string"
.SS "reader"
.B type reader interface {
.RS
.B io.Reader
.sp 0
.B Peek(int) ([]byte, error)
.sp 0
.RE
.B }
.PP
A reader is an io.Reader that can also peek ahead. 
