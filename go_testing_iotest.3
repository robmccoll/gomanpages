.\"    Automatically generated by mango(1)
.TH "iotest" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
iotest \- Package iotest implements Readers and Writers useful mainly for testing.
.SH "SYNOPSIS"
.B import \*(lqiotest\(rq
.sp
.B Variables
.sp 0
.RB "func " DataErrReader
.sp 0
.RB "func " HalfReader
.sp 0
.RB "func " NewReadLogger
.sp 0
.RB "func " NewWriteLogger
.sp 0
.RB "func " OneByteReader
.sp 0
.RB "func " TimeoutReader
.sp 0
.RB "func " TruncateWriter
.sp 0
.RB "type " dataErrReader
.sp 0
.RS
.RB "func (*dataErrReader) " Read
.sp 0
.RE
.RB "type " halfReader
.sp 0
.RS
.RB "func (*halfReader) " Read
.sp 0
.RE
.RB "type " oneByteReader
.sp 0
.RS
.RB "func (*oneByteReader) " Read
.sp 0
.RE
.RB "type " readLogger
.sp 0
.RS
.RB "func (*readLogger) " Read
.sp 0
.RE
.RB "type " timeoutReader
.sp 0
.RS
.RB "func (*timeoutReader) " Read
.sp 0
.RE
.RB "type " truncateWriter
.sp 0
.RS
.RB "func (*truncateWriter) " Write
.sp 0
.RE
.RB "type " writeLogger
.sp 0
.RS
.RB "func (*writeLogger) " Write
.sp 0
.RE
.SH "VARIABLES"
.PP
.B var 
.B ErrTimeout 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func DataErrReader(" "r" " io.Reader) io.Reader"
.PP
DataErrReader changes the way errors are handled by a Reader. 
Normally, a Reader returns an error (typically EOF) from the first Read call after the last piece of data is read. 
DataErrReader wraps a Reader and changes its behavior so the final error is returned along with the final data, instead of in the first call after the final data. 
.PP
.BR "func HalfReader(" "r" " io.Reader) io.Reader"
.PP
HalfReader returns a Reader that implements Read by reading half as many requested bytes from r. 
.PP
.BR "func NewReadLogger(" "prefix" " string, " "r" " io.Reader) io.Reader"
.PP
NewReadLogger returns a reader that behaves like r except that it logs (using log.Print) each read to standard error, printing the prefix and the hexadecimal data written. 
.PP
.BR "func NewWriteLogger(" "prefix" " string, " "w" " io.Writer) io.Writer"
.PP
NewWriteLogger returns a writer that behaves like w except that it logs (using log.Printf) each write to standard error, printing the prefix and the hexadecimal data written. 
.PP
.BR "func OneByteReader(" "r" " io.Reader) io.Reader"
.PP
OneByteReader returns a Reader that implements each non\-empty Read by reading one byte from r. 
.PP
.BR "func TimeoutReader(" "r" " io.Reader) io.Reader"
.PP
TimeoutReader returns ErrTimeout on the second read with no data. 
Subsequent calls to read succeed. 
.PP
.BR "func TruncateWriter(" "w" " io.Writer, " "n" " int64) io.Writer"
.PP
TruncateWriter returns a Writer that writes to w but stops silently after n bytes. 
.SH "TYPES"
.SS "dataErrReader"
.B type dataErrReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*dataErrReader) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "halfReader"
.B type halfReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*halfReader) Read(" "p" " []byte) (int, error)"
.SS "oneByteReader"
.B type oneByteReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*oneByteReader) Read(" "p" " []byte) (int, error)"
.SS "readLogger"
.B type readLogger struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*readLogger) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "timeoutReader"
.B type timeoutReader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*timeoutReader) Read(" "p" " []byte) (int, error)"
.SS "truncateWriter"
.B type truncateWriter struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*truncateWriter) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
.SS "writeLogger"
.B type writeLogger struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*writeLogger) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
