.\"    Automatically generated by mango(1)
.TH "crc32" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
crc32 \- Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32,
checksum.
.SH "SYNOPSIS"
.B import \*(lqcrc32\(rq
.sp
.B Constants
.sp 0
.B Variables
.sp 0
.RB "func " Checksum
.sp 0
.RB "func " ChecksumIEEE
.sp 0
.RB "func " New
.sp 0
.RB "func " NewIEEE
.sp 0
.RB "func " Update
.sp 0
.RB "type " Table
.sp 0
.RS
.RB "func " MakeTable
.sp 0
.RE
.RB "type " digest
.sp 0
.RS
.RB "func (*digest) " BlockSize
.sp 0
.RB "func (*digest) " Reset
.sp 0
.RB "func (*digest) " Size
.sp 0
.RB "func (*digest) " Sum
.sp 0
.RB "func (*digest) " Sum32
.sp 0
.RB "func (*digest) " Write
.sp 0
.RE
.SH "DESCRIPTION"
Package crc32 implements the 32\-bit cyclic redundancy check, or CRC\-32, checksum. 
See http://en.wikipedia.org/wiki/Cyclic_redundancy_check for information. 
.SH "CONSTANTS"
Predefined polynomials. 
.PP
.B const (
.RS
.B IEEE 
.sp 0
.B Castagnoli 
.sp 0
.B Koopman 
.sp 0
.RE
.B )
.sp 0
The size of a CRC\-32 checksum in bytes. 
.PP
.B const 
.B Size 
.sp 0
.SH "VARIABLES"
IEEETable is the table for the IEEE polynomial. 
.PP
.B var 
.B IEEETable 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func Checksum(" "data" " []byte, " "tab" " *Table) uint32"
.PP
Checksum returns the CRC\-32 checksum of data using the polynomial represented by the Table. 
.PP
.BR "func ChecksumIEEE(" "data" " []byte) uint32"
.PP
ChecksumIEEE returns the CRC\-32 checksum of data using the IEEE polynomial. 
.PP
.BR "func New(" "tab" " *Table) hash.Hash32"
.PP
New creates a new hash.Hash32 computing the CRC\-32 checksum using the polynomial represented by the Table. 
.PP
.BR "func NewIEEE() hash.Hash32"
.PP
NewIEEE creates a new hash.Hash32 computing the CRC\-32 checksum using the IEEE polynomial. 
.PP
.BR "func Update(" "crc" " uint32, " "tab" " *Table, " "p" " []byte) uint32"
.PP
Update returns the result of adding the bytes in p to the crc. 
.SH "TYPES"
.SS "Table"
.B type Table []uint32
.PP
Table is a 256\-word table representing the polynomial for efficient processing. 
castagnoliTable points to a lazily initialized Table for the Castagnoli polynomial. 
MakeTable will always return this value when asked to make a Castagnoli table so we can compare against it to find when the caller is using this polynomial. 
.PP
.B var 
.B 
.sp 0
.PP
.BR "func MakeTable(" "poly" " uint32) *Table"
.PP
MakeTable returns the Table constructed from the specified polynomial. 
.SS "digest"
.B type digest struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
digest represents the partial evaluation of a checksum. 
.PP
.BR "func (*digest) BlockSize() int"
.PP
.BR "func (*digest) Reset()"
.PP
.BR "func (*digest) Size() int"
.PP
.BR "func (*digest) Sum(" "in" " []byte) []byte"
.PP
.BR "func (*digest) Sum32() uint32"
.PP
.BR "func (*digest) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
