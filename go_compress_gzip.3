.\"    Automatically generated by mango(1)
.TH "gzip" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
gzip \- Package gzip implements reading and writing of gzip format compressed files,
as specified in RFC 1952.
.SH "SYNOPSIS"
.B import \*(lqgzip\(rq
.sp
.B Constants
.sp 0
.B Variables
.sp 0
.RB "type " Header
.sp 0
.RB "type " Reader
.sp 0
.RS
.RB "func " NewReader
.sp 0
.RB "func (*Reader) " Close
.sp 0
.RB "func (*Reader) " Read
.sp 0
.RB "func (*Reader) " Reset
.sp 0
.RE
.RB "type " Writer
.sp 0
.RS
.RB "func " NewWriter
.sp 0
.RB "func " NewWriterLevel
.sp 0
.RB "func (*Writer) " Close
.sp 0
.RB "func (*Writer) " Flush
.sp 0
.RB "func (*Writer) " Reset
.sp 0
.RB "func (*Writer) " Write
.sp 0
.RE
.SH "CONSTANTS"
These constants are copied from the flate package, so that code that imports "compress/gzip" does not also have to import "compress/flate". 
.PP
.B const (
.RS
.B NoCompression 
.sp 0
.B BestSpeed 
.sp 0
.B BestCompression 
.sp 0
.B DefaultCompression 
.sp 0
.RE
.B )
.SH "VARIABLES"
.PP
.B var (
.RS
.B ErrChecksum 
.sp 0
.B ErrHeader 
.sp 0
.RE
.B )
.SH "TYPES"
.SS "Header"
.B type Header struct {
.RS
.B Comment string
.sp 0
.B Extra []byte
.sp 0
.B ModTime time.Time
.sp 0
.B Name string
.sp 0
.B OS byte
.RE
.B }
.PP
The gzip file stores a header giving metadata about the compressed file. 
That header is exposed as the fields of the Writer and Reader structs. 
.SS "Reader"
.B type Reader struct {
.RS
.B Header
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Reader is an io.Reader that can be read to retrieve uncompressed data from a gzip\-format compressed file. 
.PP
In general, a gzip file can be a concatenation of gzip files, each with its own header. 
Reads from the Reader return the concatenation of the uncompressed data of each. 
Only the first header is recorded in the Reader fields. 
.PP
Gzip files store a length and checksum of the uncompressed data. 
The Reader will return a ErrChecksum when Read reaches the end of the uncompressed data if it does not have the expected length or checksum. 
Clients should treat data returned by Read as tentative until they receive the io.EOF marking the end of the data. 
.PP
.BR "func NewReader(" "r" " io.Reader) (*Reader, error)"
.PP
NewReader creates a new Reader reading the given reader. 
The implementation buffers input and may read more data than necessary from r. 
It is the caller's responsibility to call Close on the Reader when done. 
.PP
.BR "func (*Reader) Close() error"
.PP
Close closes the Reader. 
It does not close the underlying io.Reader. 
.PP
.BR "func (*Reader) Read(" "p" " []byte) (" "n" " int, " "err" " error)"
.PP
.BR "func (*Reader) Reset(" "r" " io.Reader) error"
.PP
Reset discards the Reader z's state and makes it equivalent to the result of its original state from NewReader, but reading from r instead. 
This permits reusing a Reader rather than allocating a new one. 
.SS "Writer"
.B type Writer struct {
.RS
.B Header
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Writer is an io.WriteCloser. 
Writes to a Writer are compressed and written to w. 
.PP
.BR "func NewWriter(" "w" " io.Writer) *Writer"
.PP
NewWriter returns a new Writer. 
Writes to the returned writer are compressed and written to w. 
.PP
It is the caller's responsibility to call Close on the WriteCloser when done. 
Writes may be buffered and not flushed until Close. 
.PP
Callers that wish to set the fields in Writer.Header must do so before the first call to Write or Close. 
The Comment and Name header fields are UTF\-8 strings in Go, but the underlying format requires NUL\-terminated ISO 8859\-1 (Latin\-1). 
NUL or non\-Latin\-1 runes in those strings will lead to an error on Write. 
.PP
.BR "func NewWriterLevel(" "w" " io.Writer, " "level" " int) (*Writer, error)"
.PP
NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression. 
.PP
The compression level can be DefaultCompression, NoCompression, or any integer value between BestSpeed and BestCompression inclusive. 
The error returned will be nil if the level is valid. 
.PP
.BR "func (*Writer) Close() error"
.PP
Close closes the Writer, flushing any unwritten data to the underlying io.Writer, but does not close the underlying io.Writer. 
.PP
.BR "func (*Writer) Flush() error"
.PP
Flush flushes any pending compressed data to the underlying writer. 
.PP
It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. 
Flush does not return until the data has been written. 
If the underlying writer returns an error, Flush returns that error. 
.PP
In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH. 
.PP
.BR "func (*Writer) Reset(" "w" " io.Writer)"
.PP
Reset discards the Writer z's state and makes it equivalent to the result of its original state from NewWriter or NewWriterLevel, but writing to w instead. 
This permits reusing a Writer rather than allocating a new one. 
.PP
.BR "func (*Writer) Write(" "p" " []byte) (int, error)"
.PP
Write writes a compressed form of p to the underlying io.Writer. 
The compressed bytes are not necessarily flushed until the Writer is closed. 
