.\"    Automatically generated by mango(1)
.TH "ast" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
ast \- Package ast declares the types used to represent syntax trees for Go
packages.
.SH "SYNOPSIS"
.B import \*(lqast\(rq
.sp
.RB "func " FileExports
.sp 0
.RB "func " FilterDecl
.sp 0
.RB "func " FilterFile
.sp 0
.RB "func " FilterPackage
.sp 0
.RB "func " Fprint
.sp 0
.RB "func " Inspect
.sp 0
.RB "func " IsExported
.sp 0
.RB "func " NotNilFilter
.sp 0
.RB "func " PackageExports
.sp 0
.RB "func " Print
.sp 0
.RB "func " SortImports
.sp 0
.RB "func " Walk
.sp 0
.RB "type " ArrayType
.sp 0
.RS
.RB "func (*ArrayType) " End
.sp 0
.RB "func (*ArrayType) " Pos
.sp 0
.RE
.RB "type " AssignStmt
.sp 0
.RS
.RB "func (*AssignStmt) " End
.sp 0
.RB "func (*AssignStmt) " Pos
.sp 0
.RE
.RB "type " BadDecl
.sp 0
.RS
.RB "func (*BadDecl) " End
.sp 0
.RB "func (*BadDecl) " Pos
.sp 0
.RE
.RB "type " BadExpr
.sp 0
.RS
.RB "func (*BadExpr) " End
.sp 0
.RB "func (*BadExpr) " Pos
.sp 0
.RE
.RB "type " BadStmt
.sp 0
.RS
.RB "func (*BadStmt) " End
.sp 0
.RB "func (*BadStmt) " Pos
.sp 0
.RE
.RB "type " BasicLit
.sp 0
.RS
.RB "func (*BasicLit) " End
.sp 0
.RB "func (*BasicLit) " Pos
.sp 0
.RE
.RB "type " BinaryExpr
.sp 0
.RS
.RB "func (*BinaryExpr) " End
.sp 0
.RB "func (*BinaryExpr) " Pos
.sp 0
.RE
.RB "type " BlockStmt
.sp 0
.RS
.RB "func (*BlockStmt) " End
.sp 0
.RB "func (*BlockStmt) " Pos
.sp 0
.RE
.RB "type " BranchStmt
.sp 0
.RS
.RB "func (*BranchStmt) " End
.sp 0
.RB "func (*BranchStmt) " Pos
.sp 0
.RE
.RB "type " CallExpr
.sp 0
.RS
.RB "func (*CallExpr) " End
.sp 0
.RB "func (*CallExpr) " Pos
.sp 0
.RE
.RB "type " CaseClause
.sp 0
.RS
.RB "func (*CaseClause) " End
.sp 0
.RB "func (*CaseClause) " Pos
.sp 0
.RE
.RB "type " ChanDir
.sp 0
.RB "type " ChanType
.sp 0
.RS
.RB "func (*ChanType) " End
.sp 0
.RB "func (*ChanType) " Pos
.sp 0
.RE
.RB "type " CommClause
.sp 0
.RS
.RB "func (*CommClause) " End
.sp 0
.RB "func (*CommClause) " Pos
.sp 0
.RE
.RB "type " Comment
.sp 0
.RS
.RB "func (*Comment) " End
.sp 0
.RB "func (*Comment) " Pos
.sp 0
.RE
.RB "type " CommentGroup
.sp 0
.RS
.RB "func (*CommentGroup) " End
.sp 0
.RB "func (*CommentGroup) " Pos
.sp 0
.RB "func (*CommentGroup) " Text
.sp 0
.RE
.RB "type " CommentMap
.sp 0
.RS
.RB "func " NewCommentMap
.sp 0
.RB "func (CommentMap) " Comments
.sp 0
.RB "func (CommentMap) " Filter
.sp 0
.RB "func (CommentMap) " String
.sp 0
.RB "func (CommentMap) " Update
.sp 0
.RE
.RB "type " CompositeLit
.sp 0
.RS
.RB "func (*CompositeLit) " End
.sp 0
.RB "func (*CompositeLit) " Pos
.sp 0
.RE
.RB "type " Decl
.sp 0
.RB "type " DeclStmt
.sp 0
.RS
.RB "func (*DeclStmt) " End
.sp 0
.RB "func (*DeclStmt) " Pos
.sp 0
.RE
.RB "type " DeferStmt
.sp 0
.RS
.RB "func (*DeferStmt) " End
.sp 0
.RB "func (*DeferStmt) " Pos
.sp 0
.RE
.RB "type " Ellipsis
.sp 0
.RS
.RB "func (*Ellipsis) " End
.sp 0
.RB "func (*Ellipsis) " Pos
.sp 0
.RE
.RB "type " EmptyStmt
.sp 0
.RS
.RB "func (*EmptyStmt) " End
.sp 0
.RB "func (*EmptyStmt) " Pos
.sp 0
.RE
.RB "type " Expr
.sp 0
.RB "type " ExprStmt
.sp 0
.RS
.RB "func (*ExprStmt) " End
.sp 0
.RB "func (*ExprStmt) " Pos
.sp 0
.RE
.RB "type " Field
.sp 0
.RS
.RB "func (*Field) " End
.sp 0
.RB "func (*Field) " Pos
.sp 0
.RE
.RB "type " FieldFilter
.sp 0
.RB "type " FieldList
.sp 0
.RS
.RB "func (*FieldList) " End
.sp 0
.RB "func (*FieldList) " NumFields
.sp 0
.RB "func (*FieldList) " Pos
.sp 0
.RE
.RB "type " File
.sp 0
.RS
.RB "func " MergePackageFiles
.sp 0
.RB "func (*File) " End
.sp 0
.RB "func (*File) " Pos
.sp 0
.RE
.RB "type " Filter
.sp 0
.RB "type " ForStmt
.sp 0
.RS
.RB "func (*ForStmt) " End
.sp 0
.RB "func (*ForStmt) " Pos
.sp 0
.RE
.RB "type " FuncDecl
.sp 0
.RS
.RB "func (*FuncDecl) " End
.sp 0
.RB "func (*FuncDecl) " Pos
.sp 0
.RE
.RB "type " FuncLit
.sp 0
.RS
.RB "func (*FuncLit) " End
.sp 0
.RB "func (*FuncLit) " Pos
.sp 0
.RE
.RB "type " FuncType
.sp 0
.RS
.RB "func (*FuncType) " End
.sp 0
.RB "func (*FuncType) " Pos
.sp 0
.RE
.RB "type " GenDecl
.sp 0
.RS
.RB "func (*GenDecl) " End
.sp 0
.RB "func (*GenDecl) " Pos
.sp 0
.RE
.RB "type " GoStmt
.sp 0
.RS
.RB "func (*GoStmt) " End
.sp 0
.RB "func (*GoStmt) " Pos
.sp 0
.RE
.RB "type " Ident
.sp 0
.RS
.RB "func " NewIdent
.sp 0
.RB "func (*Ident) " End
.sp 0
.RB "func (*Ident) " IsExported
.sp 0
.RB "func (*Ident) " Pos
.sp 0
.RB "func (*Ident) " String
.sp 0
.RE
.RB "type " IfStmt
.sp 0
.RS
.RB "func (*IfStmt) " End
.sp 0
.RB "func (*IfStmt) " Pos
.sp 0
.RE
.RB "type " ImportSpec
.sp 0
.RS
.RB "func (*ImportSpec) " End
.sp 0
.RB "func (*ImportSpec) " Pos
.sp 0
.RE
.RB "type " Importer
.sp 0
.RB "type " IncDecStmt
.sp 0
.RS
.RB "func (*IncDecStmt) " End
.sp 0
.RB "func (*IncDecStmt) " Pos
.sp 0
.RE
.RB "type " IndexExpr
.sp 0
.RS
.RB "func (*IndexExpr) " End
.sp 0
.RB "func (*IndexExpr) " Pos
.sp 0
.RE
.RB "type " InterfaceType
.sp 0
.RS
.RB "func (*InterfaceType) " End
.sp 0
.RB "func (*InterfaceType) " Pos
.sp 0
.RE
.RB "type " KeyValueExpr
.sp 0
.RS
.RB "func (*KeyValueExpr) " End
.sp 0
.RB "func (*KeyValueExpr) " Pos
.sp 0
.RE
.RB "type " LabeledStmt
.sp 0
.RS
.RB "func (*LabeledStmt) " End
.sp 0
.RB "func (*LabeledStmt) " Pos
.sp 0
.RE
.RB "type " MapType
.sp 0
.RS
.RB "func (*MapType) " End
.sp 0
.RB "func (*MapType) " Pos
.sp 0
.RE
.RB "type " MergeMode
.sp 0
.RB "type " Node
.sp 0
.RB "type " ObjKind
.sp 0
.RS
.RB "func (ObjKind) " String
.sp 0
.RE
.RB "type " Object
.sp 0
.RS
.RB "func " NewObj
.sp 0
.RB "func (*Object) " Pos
.sp 0
.RE
.RB "type " Package
.sp 0
.RS
.RB "func " NewPackage
.sp 0
.RB "func (*Package) " End
.sp 0
.RB "func (*Package) " Pos
.sp 0
.RE
.RB "type " ParenExpr
.sp 0
.RS
.RB "func (*ParenExpr) " End
.sp 0
.RB "func (*ParenExpr) " Pos
.sp 0
.RE
.RB "type " RangeStmt
.sp 0
.RS
.RB "func (*RangeStmt) " End
.sp 0
.RB "func (*RangeStmt) " Pos
.sp 0
.RE
.RB "type " ReturnStmt
.sp 0
.RS
.RB "func (*ReturnStmt) " End
.sp 0
.RB "func (*ReturnStmt) " Pos
.sp 0
.RE
.RB "type " Scope
.sp 0
.RS
.RB "func " NewScope
.sp 0
.RB "func (*Scope) " Insert
.sp 0
.RB "func (*Scope) " Lookup
.sp 0
.RB "func (*Scope) " String
.sp 0
.RE
.RB "type " SelectStmt
.sp 0
.RS
.RB "func (*SelectStmt) " End
.sp 0
.RB "func (*SelectStmt) " Pos
.sp 0
.RE
.RB "type " SelectorExpr
.sp 0
.RS
.RB "func (*SelectorExpr) " End
.sp 0
.RB "func (*SelectorExpr) " Pos
.sp 0
.RE
.RB "type " SendStmt
.sp 0
.RS
.RB "func (*SendStmt) " End
.sp 0
.RB "func (*SendStmt) " Pos
.sp 0
.RE
.RB "type " SliceExpr
.sp 0
.RS
.RB "func (*SliceExpr) " End
.sp 0
.RB "func (*SliceExpr) " Pos
.sp 0
.RE
.RB "type " Spec
.sp 0
.RB "type " StarExpr
.sp 0
.RS
.RB "func (*StarExpr) " End
.sp 0
.RB "func (*StarExpr) " Pos
.sp 0
.RE
.RB "type " Stmt
.sp 0
.RB "type " StructType
.sp 0
.RS
.RB "func (*StructType) " End
.sp 0
.RB "func (*StructType) " Pos
.sp 0
.RE
.RB "type " SwitchStmt
.sp 0
.RS
.RB "func (*SwitchStmt) " End
.sp 0
.RB "func (*SwitchStmt) " Pos
.sp 0
.RE
.RB "type " TypeAssertExpr
.sp 0
.RS
.RB "func (*TypeAssertExpr) " End
.sp 0
.RB "func (*TypeAssertExpr) " Pos
.sp 0
.RE
.RB "type " TypeSpec
.sp 0
.RS
.RB "func (*TypeSpec) " End
.sp 0
.RB "func (*TypeSpec) " Pos
.sp 0
.RE
.RB "type " TypeSwitchStmt
.sp 0
.RS
.RB "func (*TypeSwitchStmt) " End
.sp 0
.RB "func (*TypeSwitchStmt) " Pos
.sp 0
.RE
.RB "type " UnaryExpr
.sp 0
.RS
.RB "func (*UnaryExpr) " End
.sp 0
.RB "func (*UnaryExpr) " Pos
.sp 0
.RE
.RB "type " ValueSpec
.sp 0
.RS
.RB "func (*ValueSpec) " End
.sp 0
.RB "func (*ValueSpec) " Pos
.sp 0
.RE
.RB "type " Visitor
.sp 0
.RB "type " byCommentPos
.sp 0
.RS
.RB "func (byCommentPos) " Len
.sp 0
.RB "func (byCommentPos) " Less
.sp 0
.RB "func (byCommentPos) " Swap
.sp 0
.RE
.RB "type " byImportSpec
.sp 0
.RS
.RB "func (byImportSpec) " Len
.sp 0
.RB "func (byImportSpec) " Less
.sp 0
.RB "func (byImportSpec) " Swap
.sp 0
.RE
.RB "type " byInterval
.sp 0
.RS
.RB "func (byInterval) " Len
.sp 0
.RB "func (byInterval) " Less
.sp 0
.RB "func (byInterval) " Swap
.sp 0
.RE
.RB "type " byPos
.sp 0
.RS
.RB "func (byPos) " Len
.sp 0
.RB "func (byPos) " Less
.sp 0
.RB "func (byPos) " Swap
.sp 0
.RE
.RB "type " inspector
.sp 0
.RS
.RB "func (inspector) " Visit
.sp 0
.RE
.RB "type " posSpan
.sp 0
.RB "type " printer
.sp 0
.RS
.RB "func (*printer) " Write
.sp 0
.RE
.SH "FUNCTIONS"
.PP
.BR "func FileExports(" "src" " *File) bool"
.PP
FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top\-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. 
Non\-exported fields and methods of exported types are stripped. 
The File.Comments list is not changed. 
.PP
FileExports returns true if there are exported declarations; it returns false otherwise. 
.PP
.BR "func FilterDecl(" "decl" " Decl, " "f" " Filter) bool"
.PP
FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. 
.PP
FilterDecl returns true if there are any declared names left after filtering; it returns false otherwise. 
.PP
.BR "func FilterFile(" "src" " *File, " "f" " Filter) bool"
.PP
FilterFile trims the AST for a Go file in place by removing all names from top\-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. 
If the declaration is empty afterwards, the declaration is removed from the AST. 
The File.Comments list is not changed. 
.PP
FilterFile returns true if there are any top\-level declarations left after filtering; it returns false otherwise. 
.PP
.BR "func FilterPackage(" "pkg" " *Package, " "f" " Filter) bool"
.PP
FilterPackage trims the AST for a Go package in place by removing all names from top\-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. 
If the declaration is empty afterwards, the declaration is removed from the AST. 
The pkg.Files list is not changed, so that file names and top\-level package comments don't get lost. 
.PP
FilterPackage returns true if there are any top\-level declarations left after filtering; it returns false otherwise. 
.PP
.BR "func Fprint(" "w" " io.Writer, " "fset" " *token.FileSet, " "x" " interface{}, " "f" " FieldFilter) (" "err" " error)"
.PP
Fprint prints the (sub\-)tree starting at AST node x to w. 
If fset != nil, position information is interpreted relative to that file set. 
Otherwise positions are printed as integer values (file set specific offsets). 
.PP
A non\-nil FieldFilter f may be provided to control the output: struct fields for which f(fieldname, fieldvalue) is true are printed; all others are filtered from the output. 
Unexported struct fields are never printed. 
.PP
.BR "func Inspect(" "node" " Node, " "f" " func(Node) bool)"
.PP
Inspect traverses an AST in depth\-first order: It starts by calling f(node); node must not be nil. 
If f returns true, Inspect invokes f for all the non\-nil children of node, recursively. 
.PP
.BR "func IsExported(" "name" " string) bool"
.PP
IsExported reports whether name is an exported Go symbol (that is, whether it begins with an upper\-case letter). 
.PP
.BR "func NotNilFilter(" "_" " string, " "v" " reflect.Value) bool"
.PP
NotNilFilter returns true for field values that are not nil; it returns false otherwise. 
.PP
.BR "func PackageExports(" "pkg" " *Package) bool"
.PP
PackageExports trims the AST for a Go package in place such that only exported nodes remain. 
The pkg.Files list is not changed, so that file names and top\-level package comments don't get lost. 
.PP
PackageExports returns true if there are exported declarations; it returns false otherwise. 
.PP
.BR "func Print(" "fset" " *token.FileSet, " "x" " interface{}) error"
.PP
Print prints x to standard output, skipping nil fields. 
Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter). 
.PP
.BR "func SortImports(" "fset" " *token.FileSet, " "f" " *File)"
.PP
SortImports sorts runs of consecutive import lines in import blocks in f. 
It also removes duplicate imports when it is possible to do so without data loss. 
.PP
.BR "func Walk(" "v" " Visitor, " "node" " Node)"
.PP
Walk traverses an AST in depth\-first order: It starts by calling v.Visit(node); node must not be nil. 
If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non\-nil children of node, followed by a call of w.Visit(nil). 
.SH "TYPES"
.SS "ArrayType"
.B type ArrayType struct {
.RS
.B Lbrack token.Pos
.sp 0
.B Len Expr
.sp 0
.B Elt Expr
.RE
.B }
.PP
An ArrayType node represents an array or slice type. 
.PP
.BR "func (*ArrayType) End() token.Pos"
.PP
.BR "func (*ArrayType) Pos() token.Pos"
.SS "AssignStmt"
.B type AssignStmt struct {
.RS
.B Lhs []Expr
.sp 0
.B TokPos token.Pos
.sp 0
.B Tok token.Token
.sp 0
.B Rhs []Expr
.RE
.B }
.PP
An AssignStmt node represents an assignment or a short variable declaration. 
.PP
.BR "func (*AssignStmt) End() token.Pos"
.PP
.BR "func (*AssignStmt) Pos() token.Pos"
.SS "BadDecl"
.B type BadDecl struct {
.RS
.B From, To token.Pos
.RE
.B }
.PP
A BadDecl node is a placeholder for declarations containing syntax errors for which no correct declaration nodes can be created. 
.PP
.BR "func (*BadDecl) End() token.Pos"
.PP
.BR "func (*BadDecl) Pos() token.Pos"
.PP
Pos and End implementations for declaration nodes. 
.SS "BadExpr"
.B type BadExpr struct {
.RS
.B From, To token.Pos
.RE
.B }
.PP
A BadExpr node is a placeholder for expressions containing syntax errors for which no correct expression nodes can be created. 
.PP
.BR "func (*BadExpr) End() token.Pos"
.PP
.BR "func (*BadExpr) Pos() token.Pos"
.PP
Pos and End implementations for expression/type nodes. 
.SS "BadStmt"
.B type BadStmt struct {
.RS
.B From, To token.Pos
.RE
.B }
.PP
A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created. 
.PP
.BR "func (*BadStmt) End() token.Pos"
.PP
.BR "func (*BadStmt) Pos() token.Pos"
.PP
Pos and End implementations for statement nodes. 
.SS "BasicLit"
.B type BasicLit struct {
.RS
.B ValuePos token.Pos
.sp 0
.B Kind token.Token
.sp 0
.B Value string
.RE
.B }
.PP
A BasicLit node represents a literal of basic type. 
.PP
.BR "func (*BasicLit) End() token.Pos"
.PP
.BR "func (*BasicLit) Pos() token.Pos"
.SS "BinaryExpr"
.B type BinaryExpr struct {
.RS
.B X Expr
.sp 0
.B OpPos token.Pos
.sp 0
.B Op token.Token
.sp 0
.B Y Expr
.RE
.B }
.PP
A BinaryExpr node represents a binary expression. 
.PP
.BR "func (*BinaryExpr) End() token.Pos"
.PP
.BR "func (*BinaryExpr) Pos() token.Pos"
.SS "BlockStmt"
.B type BlockStmt struct {
.RS
.B Lbrace token.Pos
.sp 0
.B List []Stmt
.sp 0
.B Rbrace token.Pos
.RE
.B }
.PP
A BlockStmt node represents a braced statement list. 
.PP
.BR "func (*BlockStmt) End() token.Pos"
.PP
.BR "func (*BlockStmt) Pos() token.Pos"
.SS "BranchStmt"
.B type BranchStmt struct {
.RS
.B TokPos token.Pos
.sp 0
.B Tok token.Token
.sp 0
.B Label *Ident
.RE
.B }
.PP
A BranchStmt node represents a break, continue, goto, or fallthrough statement. 
.PP
.BR "func (*BranchStmt) End() token.Pos"
.PP
.BR "func (*BranchStmt) Pos() token.Pos"
.SS "CallExpr"
.B type CallExpr struct {
.RS
.B Fun Expr
.sp 0
.B Lparen token.Pos
.sp 0
.B Args []Expr
.sp 0
.B Ellipsis token.Pos
.sp 0
.B Rparen token.Pos
.RE
.B }
.PP
A CallExpr node represents an expression followed by an argument list. 
.PP
.BR "func (*CallExpr) End() token.Pos"
.PP
.BR "func (*CallExpr) Pos() token.Pos"
.SS "CaseClause"
.B type CaseClause struct {
.RS
.B Case token.Pos
.sp 0
.B List []Expr
.sp 0
.B Colon token.Pos
.sp 0
.B Body []Stmt
.RE
.B }
.PP
A CaseClause represents a case of an expression or type switch statement. 
.PP
.BR "func (*CaseClause) End() token.Pos"
.PP
.BR "func (*CaseClause) Pos() token.Pos"
.SS "ChanDir"
.B type ChanDir int
.PP
The direction of a channel type is indicated by one of the following constants. 
.PP
.B const (
.RS
.B SEND 
.sp 0
.B RECV 
.sp 0
.RE
.B )
.SS "ChanType"
.B type ChanType struct {
.RS
.B Begin token.Pos
.sp 0
.B Arrow token.Pos
.sp 0
.B Dir ChanDir
.sp 0
.B Value Expr
.RE
.B }
.PP
A ChanType node represents a channel type. 
.PP
.BR "func (*ChanType) End() token.Pos"
.PP
.BR "func (*ChanType) Pos() token.Pos"
.SS "CommClause"
.B type CommClause struct {
.RS
.B Case token.Pos
.sp 0
.B Comm Stmt
.sp 0
.B Colon token.Pos
.sp 0
.B Body []Stmt
.RE
.B }
.PP
A CommClause node represents a case of a select statement. 
.PP
.BR "func (*CommClause) End() token.Pos"
.PP
.BR "func (*CommClause) Pos() token.Pos"
.SS "Comment"
.B type Comment struct {
.RS
.B Slash token.Pos
.sp 0
.B Text string
.RE
.B }
.PP
A Comment node represents a single //\-style or /*\-style comment. 
.PP
.BR "func (*Comment) End() token.Pos"
.PP
.BR "func (*Comment) Pos() token.Pos"
.SS "CommentGroup"
.B type CommentGroup struct {
.RS
.B List []*Comment
.RE
.B }
.PP
A CommentGroup represents a sequence of comments with no other tokens and no empty lines between. 
.PP
.BR "func (*CommentGroup) End() token.Pos"
.PP
.BR "func (*CommentGroup) Pos() token.Pos"
.PP
.BR "func (*CommentGroup) Text() string"
.PP
Text returns the text of the comment. 
Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. 
Multiple empty lines are reduced to one, and trailing space on lines is trimmed. 
Unless the result is empty, it is newline\-terminated. 
.SS "CommentMap"
.B type CommentMap map[Node][]*CommentGroup
.PP
A CommentMap maps an AST node to a list of comment groups associated with it. 
See NewCommentMap for a description of the association. 
.PP
.BR "func NewCommentMap(" "fset" " *token.FileSet, " "node" " Node, " "comments" " []*CommentGroup) CommentMap"
.PP
NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node. 
.PP
A comment group g is associated with a node n if:    
.PP
.B \-
g starts on the same line as n ends 
.B \-
g starts on the line immediately following n, and there is 
.PP
.RS
at least one empty line after g and before the next node
.RE
.PP
.B \-
g starts before n and is not associated to the node before n 
.PP
.RS
via the previous rules
.sp 0
.sp
.RE
.PP
NewCommentMap tries to associate a comment group to the "largest" node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment. 
.PP
.BR "func (CommentMap) Comments() []*CommentGroup"
.PP
Comments returns the list of comment groups in the comment map. 
The result is sorted is source order. 
.PP
.BR "func (CommentMap) Filter(" "node" " Node) CommentMap"
.PP
Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node. 
.PP
.BR "func (CommentMap) String() string"
.PP
.BR "func (CommentMap) Update(" "old" ", " "new" " Node) Node"
.PP
Update replaces an old node in the comment map with the new node and returns the new node. 
Comments that were associated with the old node are associated with the new node. 
.SS "CompositeLit"
.B type CompositeLit struct {
.RS
.B Type Expr
.sp 0
.B Lbrace token.Pos
.sp 0
.B Elts []Expr
.sp 0
.B Rbrace token.Pos
.RE
.B }
.PP
A CompositeLit node represents a composite literal. 
.PP
.BR "func (*CompositeLit) End() token.Pos"
.PP
.BR "func (*CompositeLit) Pos() token.Pos"
.SS "Decl"
.B type Decl interface {
.RS
.B Node
.sp 0
.B 
.sp 0
.sp 0
.B //contains unexported methods.
.RE
.B }
.PP
All declaration nodes implement the Decl interface. 
.SS "DeclStmt"
.B type DeclStmt struct {
.RS
.B Decl Decl
.RE
.B }
.PP
A DeclStmt node represents a declaration in a statement list. 
.PP
.BR "func (*DeclStmt) End() token.Pos"
.PP
.BR "func (*DeclStmt) Pos() token.Pos"
.SS "DeferStmt"
.B type DeferStmt struct {
.RS
.B Defer token.Pos
.sp 0
.B Call *CallExpr
.RE
.B }
.PP
A DeferStmt node represents a defer statement. 
.PP
.BR "func (*DeferStmt) End() token.Pos"
.PP
.BR "func (*DeferStmt) Pos() token.Pos"
.SS "Ellipsis"
.B type Ellipsis struct {
.RS
.B Ellipsis token.Pos
.sp 0
.B Elt Expr
.RE
.B }
.PP
An Ellipsis node stands for the "..." type in a parameter list or the "..." length in an array type. 
.PP
.BR "func (*Ellipsis) End() token.Pos"
.PP
.BR "func (*Ellipsis) Pos() token.Pos"
.SS "EmptyStmt"
.B type EmptyStmt struct {
.RS
.B Semicolon token.Pos
.RE
.B }
.PP
An EmptyStmt node represents an empty statement. 
The "position" of the empty statement is the position of the immediately preceding semicolon. 
.PP
.BR "func (*EmptyStmt) End() token.Pos"
.PP
.BR "func (*EmptyStmt) Pos() token.Pos"
.SS "Expr"
.B type Expr interface {
.RS
.B Node
.sp 0
.B 
.sp 0
.sp 0
.B //contains unexported methods.
.RE
.B }
.PP
All expression nodes implement the Expr interface. 
.SS "ExprStmt"
.B type ExprStmt struct {
.RS
.B X Expr
.RE
.B }
.PP
An ExprStmt node represents a (stand\-alone) expression in a statement list. 
.PP
.BR "func (*ExprStmt) End() token.Pos"
.PP
.BR "func (*ExprStmt) Pos() token.Pos"
.SS "Field"
.B type Field struct {
.RS
.B Doc *CommentGroup
.sp 0
.B Names []*Ident
.sp 0
.B Type Expr
.sp 0
.B Tag *BasicLit
.sp 0
.B Comment *CommentGroup
.RE
.B }
.PP
A Field represents a Field declaration list in a struct type, a method list in an interface type, or a parameter/result declaration in a signature. 
.PP
.BR "func (*Field) End() token.Pos"
.PP
.BR "func (*Field) Pos() token.Pos"
.SS "FieldFilter"
.B type FieldFilter func(name string, value reflect.Value) bool
.PP
A FieldFilter may be provided to Fprint to control the output. 
.SS "FieldList"
.B type FieldList struct {
.RS
.B Opening token.Pos
.sp 0
.B List []*Field
.sp 0
.B Closing token.Pos
.RE
.B }
.PP
A FieldList represents a list of Fields, enclosed by parentheses or braces. 
.PP
.BR "func (*FieldList) End() token.Pos"
.PP
.BR "func (*FieldList) NumFields() int"
.PP
NumFields returns the number of (named and anonymous fields) in a FieldList. 
.PP
.BR "func (*FieldList) Pos() token.Pos"
.SS "File"
.B type File struct {
.RS
.B Doc *CommentGroup
.sp 0
.B Package token.Pos
.sp 0
.B Name *Ident
.sp 0
.B Decls []Decl
.sp 0
.B Scope *Scope
.sp 0
.B Imports []*ImportSpec
.sp 0
.B Unresolved []*Ident
.sp 0
.B Comments []*CommentGroup
.RE
.B }
.PP
A File node represents a Go source file. 
.PP
The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields. 
.PP
.BR "func MergePackageFiles(" "pkg" " *Package, " "mode" " MergeMode) *File"
.PP
MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. 
The mode flags control merging behavior. 
.PP
.BR "func (*File) End() token.Pos"
.PP
.BR "func (*File) Pos() token.Pos"
.SS "Filter"
.B type Filter func(string) bool
.SS "ForStmt"
.B type ForStmt struct {
.RS
.B For token.Pos
.sp 0
.B Init Stmt
.sp 0
.B Cond Expr
.sp 0
.B Post Stmt
.sp 0
.B Body *BlockStmt
.RE
.B }
.PP
A ForStmt represents a for statement. 
.PP
.BR "func (*ForStmt) End() token.Pos"
.PP
.BR "func (*ForStmt) Pos() token.Pos"
.SS "FuncDecl"
.B type FuncDecl struct {
.RS
.B Doc *CommentGroup
.sp 0
.B Recv *FieldList
.sp 0
.B Name *Ident
.sp 0
.B Type *FuncType
.sp 0
.B Body *BlockStmt
.RE
.B }
.PP
A FuncDecl node represents a function declaration. 
.PP
.BR "func (*FuncDecl) End() token.Pos"
.PP
.BR "func (*FuncDecl) Pos() token.Pos"
.SS "FuncLit"
.B type FuncLit struct {
.RS
.B Type *FuncType
.sp 0
.B Body *BlockStmt
.RE
.B }
.PP
A FuncLit node represents a function literal. 
.PP
.BR "func (*FuncLit) End() token.Pos"
.PP
.BR "func (*FuncLit) Pos() token.Pos"
.SS "FuncType"
.B type FuncType struct {
.RS
.B Func token.Pos
.sp 0
.B Params *FieldList
.sp 0
.B Results *FieldList
.RE
.B }
.PP
A FuncType node represents a function type. 
.PP
.BR "func (*FuncType) End() token.Pos"
.PP
.BR "func (*FuncType) Pos() token.Pos"
.SS "GenDecl"
.B type GenDecl struct {
.RS
.B Doc *CommentGroup
.sp 0
.B TokPos token.Pos
.sp 0
.B Tok token.Token
.sp 0
.B Lparen token.Pos
.sp 0
.B Specs []Spec
.sp 0
.B Rparen token.Pos
.RE
.B }
.PP
A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. 
A valid Lparen position (Lparen.Line > 0) indicates a parenthesized declaration. 
.PP
Relationship between Tok value and Specs element type:    
.PP
.RS
token.IMPORT  *ImportSpec
.sp 0
token.CONST   *ValueSpec
.sp 0
token.TYPE    *TypeSpec
.sp 0
token.VAR     *ValueSpec
.RE
.PP
.BR "func (*GenDecl) End() token.Pos"
.PP
.BR "func (*GenDecl) Pos() token.Pos"
.SS "GoStmt"
.B type GoStmt struct {
.RS
.B Go token.Pos
.sp 0
.B Call *CallExpr
.RE
.B }
.PP
A GoStmt node represents a go statement. 
.PP
.BR "func (*GoStmt) End() token.Pos"
.PP
.BR "func (*GoStmt) Pos() token.Pos"
.SS "Ident"
.B type Ident struct {
.RS
.B NamePos token.Pos
.sp 0
.B Name string
.sp 0
.B Obj *Object
.RE
.B }
.PP
An Ident node represents an identifier. 
.PP
.BR "func NewIdent(" "name" " string) *Ident"
.PP
NewIdent creates a new Ident without position. 
Useful for ASTs generated by code other than the Go parser. 
.PP
.BR "func (*Ident) End() token.Pos"
.PP
.BR "func (*Ident) IsExported() bool"
.PP
IsExported reports whether id is an exported Go symbol (that is, whether it begins with an uppercase letter). 
.PP
.BR "func (*Ident) Pos() token.Pos"
.PP
.BR "func (*Ident) String() string"
.SS "IfStmt"
.B type IfStmt struct {
.RS
.B If token.Pos
.sp 0
.B Init Stmt
.sp 0
.B Cond Expr
.sp 0
.B Body *BlockStmt
.sp 0
.B Else Stmt
.RE
.B }
.PP
An IfStmt node represents an if statement. 
.PP
.BR "func (*IfStmt) End() token.Pos"
.PP
.BR "func (*IfStmt) Pos() token.Pos"
.SS "ImportSpec"
.B type ImportSpec struct {
.RS
.B Doc *CommentGroup
.sp 0
.B Name *Ident
.sp 0
.B Path *BasicLit
.sp 0
.B Comment *CommentGroup
.sp 0
.B EndPos token.Pos
.RE
.B }
.PP
An ImportSpec node represents a single package import. 
.PP
.BR "func (*ImportSpec) End() token.Pos"
.PP
.BR "func (*ImportSpec) Pos() token.Pos"
.PP
Pos and End implementations for spec nodes. 
.SS "Importer"
.B type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)
.PP
An Importer resolves import paths to package Objects. 
The imports map records the packages already imported, indexed by package id (canonical import path). 
An Importer must determine the canonical import path and check the map to see if it is already present in the imports map. 
If so, the Importer can return the map entry. 
Otherwise, the Importer should load the package data for the given path into a new *Object (pkg), record pkg in the imports map, and then return pkg. 
.SS "IncDecStmt"
.B type IncDecStmt struct {
.RS
.B X Expr
.sp 0
.B TokPos token.Pos
.sp 0
.B Tok token.Token
.RE
.B }
.PP
An IncDecStmt node represents an increment or decrement statement. 
.PP
.BR "func (*IncDecStmt) End() token.Pos"
.PP
.BR "func (*IncDecStmt) Pos() token.Pos"
.SS "IndexExpr"
.B type IndexExpr struct {
.RS
.B X Expr
.sp 0
.B Lbrack token.Pos
.sp 0
.B Index Expr
.sp 0
.B Rbrack token.Pos
.RE
.B }
.PP
An IndexExpr node represents an expression followed by an index. 
.PP
.BR "func (*IndexExpr) End() token.Pos"
.PP
.BR "func (*IndexExpr) Pos() token.Pos"
.SS "InterfaceType"
.B type InterfaceType struct {
.RS
.B Interface token.Pos
.sp 0
.B Methods *FieldList
.sp 0
.B Incomplete bool
.RE
.B }
.PP
An InterfaceType node represents an interface type. 
.PP
.BR "func (*InterfaceType) End() token.Pos"
.PP
.BR "func (*InterfaceType) Pos() token.Pos"
.SS "KeyValueExpr"
.B type KeyValueExpr struct {
.RS
.B Key Expr
.sp 0
.B Colon token.Pos
.sp 0
.B Value Expr
.RE
.B }
.PP
A KeyValueExpr node represents (key : value) pairs in composite literals. 
.PP
.BR "func (*KeyValueExpr) End() token.Pos"
.PP
.BR "func (*KeyValueExpr) Pos() token.Pos"
.SS "LabeledStmt"
.B type LabeledStmt struct {
.RS
.B Label *Ident
.sp 0
.B Colon token.Pos
.sp 0
.B Stmt Stmt
.RE
.B }
.PP
A LabeledStmt node represents a labeled statement. 
.PP
.BR "func (*LabeledStmt) End() token.Pos"
.PP
.BR "func (*LabeledStmt) Pos() token.Pos"
.SS "MapType"
.B type MapType struct {
.RS
.B Map token.Pos
.sp 0
.B Key Expr
.sp 0
.B Value Expr
.RE
.B }
.PP
A MapType node represents a map type. 
.PP
.BR "func (*MapType) End() token.Pos"
.PP
.BR "func (*MapType) Pos() token.Pos"
.SS "MergeMode"
.B type MergeMode uint
.PP
The MergeMode flags control the behavior of MergePackageFiles. 
.PP
.B const (
.RS
.B FilterFuncDuplicates 
.sp 0
.B FilterUnassociatedComments 
.sp 0
.B FilterImportDuplicates 
.sp 0
.RE
.B )
.SS "Node"
.B type Node interface {
.RS
.B Pos() token.Pos
.sp 0
.B End() token.Pos
.sp 0
.RE
.B }
.PP
All node types implement the Node interface. 
.SS "ObjKind"
.B type ObjKind int
.PP
ObjKind describes what an object represents. 
The list of possible Object kinds. 
.PP
.B const (
.RS
.B Bad 
.sp 0
.B Pkg 
.sp 0
.B Con 
.sp 0
.B Typ 
.sp 0
.B Var 
.sp 0
.B Fun 
.sp 0
.B Lbl 
.sp 0
.RE
.B )
.PP
.BR "func (ObjKind) String() string"
.SS "Object"
.B type Object struct {
.RS
.B Kind ObjKind
.sp 0
.B Name string
.sp 0
.B Decl interface{}
.sp 0
.B Data interface{}
.sp 0
.B Type interface{}
.RE
.B }
.PP
An Object describes a named language entity such as a package, constant, type, variable, function (incl. 
methods), or label. 
.PP
The Data fields contains object\-specific data: 
.PP
.RS
Kind    Data type         Data value
.sp 0
Pkg	*types.Package    package scope
.sp 0
Con     int               iota for the respective declaration
.sp 0
Con     != nil            constant value
.sp 0
Typ     *Scope            (used as method scope during type checking \- transient)
.RE
.PP
.BR "func NewObj(" "kind" " ObjKind, " "name" " string) *Object"
.PP
NewObj creates a new object of a given kind and name. 
.PP
.BR "func (*Object) Pos() token.Pos"
.PP
Pos computes the source position of the declaration of an object name. 
The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct). 
.SS "Package"
.B type Package struct {
.RS
.B Name string
.sp 0
.B Scope *Scope
.sp 0
.B Imports map[string]*Object
.sp 0
.B Files map[string]*File
.RE
.B }
.PP
A Package node represents a set of source files collectively building a Go package. 
.PP
.BR "func NewPackage(" "fset" " *token.FileSet, " "files" " map[string]*File, " "importer" " Importer, " "universe" " *Scope) (*Package, error)"
.PP
NewPackage creates a new Package node from a set of File nodes. 
It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. 
If a non\-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. 
Any remaining unresolved identifiers are reported as undeclared. 
If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. 
The result is a package node and a scanner.ErrorList if there were errors. 
.PP
.BR "func (*Package) End() token.Pos"
.PP
.BR "func (*Package) Pos() token.Pos"
.SS "ParenExpr"
.B type ParenExpr struct {
.RS
.B Lparen token.Pos
.sp 0
.B X Expr
.sp 0
.B Rparen token.Pos
.RE
.B }
.PP
A ParenExpr node represents a parenthesized expression. 
.PP
.BR "func (*ParenExpr) End() token.Pos"
.PP
.BR "func (*ParenExpr) Pos() token.Pos"
.SS "RangeStmt"
.B type RangeStmt struct {
.RS
.B For token.Pos
.sp 0
.B Key, Value Expr
.sp 0
.B TokPos token.Pos
.sp 0
.B Tok token.Token
.sp 0
.B X Expr
.sp 0
.B Body *BlockStmt
.RE
.B }
.PP
A RangeStmt represents a for statement with a range clause. 
.PP
.BR "func (*RangeStmt) End() token.Pos"
.PP
.BR "func (*RangeStmt) Pos() token.Pos"
.SS "ReturnStmt"
.B type ReturnStmt struct {
.RS
.B Return token.Pos
.sp 0
.B Results []Expr
.RE
.B }
.PP
A ReturnStmt node represents a return statement. 
.PP
.BR "func (*ReturnStmt) End() token.Pos"
.PP
.BR "func (*ReturnStmt) Pos() token.Pos"
.SS "Scope"
.B type Scope struct {
.RS
.B Outer *Scope
.sp 0
.B Objects map[string]*Object
.RE
.B }
.PP
A Scope maintains the set of named language entities declared in the scope and a link to the immediately surrounding (outer) scope. 
.PP
.BR "func NewScope(" "outer" " *Scope) *Scope"
.PP
NewScope creates a new scope nested in the outer scope. 
.PP
.BR "func (*Scope) Insert(" "obj" " *Object) (" "alt" " *Object)"
.PP
Insert attempts to insert a named object obj into the scope s. 
If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. 
Otherwise it inserts obj and returns nil." 
.PP
.BR "func (*Scope) Lookup(" "name" " string) *Object"
.PP
Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. 
Outer scopes are ignored. 
.PP
.BR "func (*Scope) String() string"
.PP
Debugging support    
.SS "SelectStmt"
.B type SelectStmt struct {
.RS
.B Select token.Pos
.sp 0
.B Body *BlockStmt
.RE
.B }
.PP
An SelectStmt node represents a select statement. 
.PP
.BR "func (*SelectStmt) End() token.Pos"
.PP
.BR "func (*SelectStmt) Pos() token.Pos"
.SS "SelectorExpr"
.B type SelectorExpr struct {
.RS
.B X Expr
.sp 0
.B Sel *Ident
.RE
.B }
.PP
A SelectorExpr node represents an expression followed by a selector. 
.PP
.BR "func (*SelectorExpr) End() token.Pos"
.PP
.BR "func (*SelectorExpr) Pos() token.Pos"
.SS "SendStmt"
.B type SendStmt struct {
.RS
.B Chan Expr
.sp 0
.B Arrow token.Pos
.sp 0
.B Value Expr
.RE
.B }
.PP
A SendStmt node represents a send statement. 
.PP
.BR "func (*SendStmt) End() token.Pos"
.PP
.BR "func (*SendStmt) Pos() token.Pos"
.SS "SliceExpr"
.B type SliceExpr struct {
.RS
.B X Expr
.sp 0
.B Lbrack token.Pos
.sp 0
.B Low Expr
.sp 0
.B High Expr
.sp 0
.B Max Expr
.sp 0
.B Slice3 bool
.sp 0
.B Rbrack token.Pos
.RE
.B }
.PP
An SliceExpr node represents an expression followed by slice indices. 
.PP
.BR "func (*SliceExpr) End() token.Pos"
.PP
.BR "func (*SliceExpr) Pos() token.Pos"
.SS "Spec"
.B type Spec interface {
.RS
.B Node
.sp 0
.B 
.sp 0
.sp 0
.B //contains unexported methods.
.RE
.B }
.PP
The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec. 
.SS "StarExpr"
.B type StarExpr struct {
.RS
.B Star token.Pos
.sp 0
.B X Expr
.RE
.B }
.PP
A StarExpr node represents an expression of the form "*" Expression. 
Semantically it could be a unary "*" expression, or a pointer type. 
.PP
.BR "func (*StarExpr) End() token.Pos"
.PP
.BR "func (*StarExpr) Pos() token.Pos"
.SS "Stmt"
.B type Stmt interface {
.RS
.B Node
.sp 0
.B 
.sp 0
.sp 0
.B //contains unexported methods.
.RE
.B }
.PP
All statement nodes implement the Stmt interface. 
.SS "StructType"
.B type StructType struct {
.RS
.B Struct token.Pos
.sp 0
.B Fields *FieldList
.sp 0
.B Incomplete bool
.RE
.B }
.PP
A StructType node represents a struct type. 
.PP
.BR "func (*StructType) End() token.Pos"
.PP
.BR "func (*StructType) Pos() token.Pos"
.SS "SwitchStmt"
.B type SwitchStmt struct {
.RS
.B Switch token.Pos
.sp 0
.B Init Stmt
.sp 0
.B Tag Expr
.sp 0
.B Body *BlockStmt
.RE
.B }
.PP
A SwitchStmt node represents an expression switch statement. 
.PP
.BR "func (*SwitchStmt) End() token.Pos"
.PP
.BR "func (*SwitchStmt) Pos() token.Pos"
.SS "TypeAssertExpr"
.B type TypeAssertExpr struct {
.RS
.B X Expr
.sp 0
.B Lparen token.Pos
.sp 0
.B Type Expr
.sp 0
.B Rparen token.Pos
.RE
.B }
.PP
A TypeAssertExpr node represents an expression followed by a type assertion. 
.PP
.BR "func (*TypeAssertExpr) End() token.Pos"
.PP
.BR "func (*TypeAssertExpr) Pos() token.Pos"
.SS "TypeSpec"
.B type TypeSpec struct {
.RS
.B Doc *CommentGroup
.sp 0
.B Name *Ident
.sp 0
.B Type Expr
.sp 0
.B Comment *CommentGroup
.RE
.B }
.PP
A TypeSpec node represents a type declaration (TypeSpec production). 
.PP
.BR "func (*TypeSpec) End() token.Pos"
.PP
.BR "func (*TypeSpec) Pos() token.Pos"
.SS "TypeSwitchStmt"
.B type TypeSwitchStmt struct {
.RS
.B Switch token.Pos
.sp 0
.B Init Stmt
.sp 0
.B Assign Stmt
.sp 0
.B Body *BlockStmt
.RE
.B }
.PP
An TypeSwitchStmt node represents a type switch statement. 
.PP
.BR "func (*TypeSwitchStmt) End() token.Pos"
.PP
.BR "func (*TypeSwitchStmt) Pos() token.Pos"
.SS "UnaryExpr"
.B type UnaryExpr struct {
.RS
.B OpPos token.Pos
.sp 0
.B Op token.Token
.sp 0
.B X Expr
.RE
.B }
.PP
A UnaryExpr node represents a unary expression. 
Unary "*" expressions are represented via StarExpr nodes. 
.PP
.BR "func (*UnaryExpr) End() token.Pos"
.PP
.BR "func (*UnaryExpr) Pos() token.Pos"
.SS "ValueSpec"
.B type ValueSpec struct {
.RS
.B Doc *CommentGroup
.sp 0
.B Names []*Ident
.sp 0
.B Type Expr
.sp 0
.B Values []Expr
.sp 0
.B Comment *CommentGroup
.RE
.B }
.PP
A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production). 
.PP
.BR "func (*ValueSpec) End() token.Pos"
.PP
.BR "func (*ValueSpec) Pos() token.Pos"
.SS "Visitor"
.B type Visitor interface {
.RS
.B Visit(node Node) (w Visitor)
.sp 0
.RE
.B }
.PP
A Visitor's Visit method is invoked for each node encountered by Walk. 
If the result visitor w is not nil, Walk visits each of the children of node with the visitor w, followed by a call of w.Visit(nil). 
.SS "byCommentPos"
.B type byCommentPos []*CommentGroup
.PP
.PP
.BR "func (byCommentPos) Len() int"
.PP
.BR "func (byCommentPos) Less(" "i" ", " "j" " int) bool"
.PP
.BR "func (byCommentPos) Swap(" "i" ", " "j" " int)"
.SS "byImportSpec"
.B type byImportSpec []Spec
.PP
.PP
.BR "func (byImportSpec) Len() int"
.PP
.BR "func (byImportSpec) Less(" "i" ", " "j" " int) bool"
.PP
.BR "func (byImportSpec) Swap(" "i" ", " "j" " int)"
.SS "byInterval"
.B type byInterval []Node
.PP
.PP
.BR "func (byInterval) Len() int"
.PP
.BR "func (byInterval) Less(" "i" ", " "j" " int) bool"
.PP
.BR "func (byInterval) Swap(" "i" ", " "j" " int)"
.SS "byPos"
.B type byPos []*CommentGroup
.PP
.PP
.BR "func (byPos) Len() int"
.PP
.BR "func (byPos) Less(" "i" ", " "j" " int) bool"
.PP
.BR "func (byPos) Swap(" "i" ", " "j" " int)"
.SS "inspector"
.B type inspector func(Node) bool
.PP
.PP
.BR "func (inspector) Visit(" "node" " Node) Visitor"
.SS "posSpan"
.B type posSpan struct {
.RS
.B Start token.Pos
.sp 0
.B End token.Pos
.RE
.B }
.SS "printer"
.B type printer struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*printer) Write(" "data" " []byte) (" "n" " int, " "err" " error)"
