.\"    Automatically generated by mango(1)
.TH "color" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
color \- Package color implements a basic color library.
.SH "SYNOPSIS"
.B import \*(lqcolor\(rq
.sp
.B Variables
.sp 0
.RB "func " RGBToYCbCr
.sp 0
.RB "func " YCbCrToRGB
.sp 0
.RB "type " Alpha
.sp 0
.RS
.RB "func (Alpha) " RGBA
.sp 0
.RE
.RB "type " Alpha16
.sp 0
.RS
.RB "func (Alpha16) " RGBA
.sp 0
.RE
.RB "type " Color
.sp 0
.RS
.RE
.RB "type " Gray
.sp 0
.RS
.RB "func (Gray) " RGBA
.sp 0
.RE
.RB "type " Gray16
.sp 0
.RS
.RB "func (Gray16) " RGBA
.sp 0
.RE
.RB "type " Model
.sp 0
.RS
.RB "func " ModelFunc
.sp 0
.RE
.RB "type " NRGBA
.sp 0
.RS
.RB "func (NRGBA) " RGBA
.sp 0
.RE
.RB "type " NRGBA64
.sp 0
.RS
.RB "func (NRGBA64) " RGBA
.sp 0
.RE
.RB "type " Palette
.sp 0
.RS
.RB "func (Palette) " Convert
.sp 0
.RB "func (Palette) " Index
.sp 0
.RE
.RB "type " RGBA
.sp 0
.RS
.RB "func (RGBA) " RGBA
.sp 0
.RE
.RB "type " RGBA64
.sp 0
.RS
.RB "func (RGBA64) " RGBA
.sp 0
.RE
.RB "type " YCbCr
.sp 0
.RS
.RB "func (YCbCr) " RGBA
.sp 0
.RE
.RB "type " modelFunc
.sp 0
.RS
.RB "func (*modelFunc) " Convert
.sp 0
.RE
.SH "VARIABLES"
Standard colors. 
.PP
.B var (
.RS
.B Black 
.sp 0
.B White 
.sp 0
.B Transparent 
.sp 0
.B Opaque 
.sp 0
.RE
.B )
.SH "FUNCTIONS"
.PP
.BR "func RGBToYCbCr(" "r" ", " "g" ", " "b" " uint8) (uint8, uint8, uint8)"
.PP
RGBToYCbCr converts an RGB triple to a Y'CbCr triple. 
.PP
.BR "func YCbCrToRGB(" "y" ", " "cb" ", " "cr" " uint8) (uint8, uint8, uint8)"
.PP
YCbCrToRGB converts a Y'CbCr triple to an RGB triple. 
.SH "TYPES"
.SS "Alpha"
.B type Alpha struct {
.RS
.B A uint8
.RE
.B }
.PP
Alpha represents an 8\-bit alpha color. 
.PP
.BR "func (Alpha) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "Alpha16"
.B type Alpha16 struct {
.RS
.B A uint16
.RE
.B }
.PP
Alpha16 represents a 16\-bit alpha color. 
.PP
.BR "func (Alpha16) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "Color"
.B type Color interface {
.RS
.B RGBA() (r, g, b, a uint32)
.sp 0
.RE
.B }
.PP
Color can convert itself to alpha\-premultiplied 16\-bits per channel RGBA. 
The conversion may be lossy. 
.SS "Gray"
.B type Gray struct {
.RS
.B Y uint8
.RE
.B }
.PP
Gray represents an 8\-bit grayscale color. 
.PP
.BR "func (Gray) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "Gray16"
.B type Gray16 struct {
.RS
.B Y uint16
.RE
.B }
.PP
Gray16 represents a 16\-bit grayscale color. 
.PP
.BR "func (Gray16) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "Model"
.B type Model interface {
.RS
.B Convert(c Color) Color
.sp 0
.RE
.B }
.PP
Model can convert any Color to one from its own color model. 
The conversion may be lossy. 
Models for the standard color types. 
.PP
.B var (
.RS
.B RGBAModel 
.sp 0
.B RGBA64Model 
.sp 0
.B NRGBAModel 
.sp 0
.B NRGBA64Model 
.sp 0
.B AlphaModel 
.sp 0
.B Alpha16Model 
.sp 0
.B GrayModel 
.sp 0
.B Gray16Model 
.sp 0
.RE
.B )
.sp 0
YCbCrModel is the Model for Y'CbCr colors. 
.PP
.B var 
.B YCbCrModel 
.sp 0
.PP
.BR "func ModelFunc(" "f" " func(Color) Color) Model"
.PP
ModelFunc returns a Model that invokes f to implement the conversion. 
.SS "NRGBA"
.B type NRGBA struct {
.RS
.B R, G, B, A uint8
.RE
.B }
.PP
NRGBA represents a non\-alpha\-premultiplied 32\-bit color. 
.PP
.BR "func (NRGBA) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "NRGBA64"
.B type NRGBA64 struct {
.RS
.B R, G, B, A uint16
.RE
.B }
.PP
NRGBA64 represents a non\-alpha\-premultiplied 64\-bit color, having 16 bits for each of red, green, blue and alpha. 
.PP
.BR "func (NRGBA64) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "Palette"
.B type Palette []Color
.PP
Palette is a palette of colors. 
.PP
.BR "func (Palette) Convert(" "c" " Color) Color"
.PP
Convert returns the palette color closest to c in Euclidean R,G,B space. 
.PP
.BR "func (Palette) Index(" "c" " Color) int"
.PP
Index returns the index of the palette color closest to c in Euclidean R,G,B space. 
.SS "RGBA"
.B type RGBA struct {
.RS
.B R, G, B, A uint8
.RE
.B }
.PP
RGBA represents a traditional 32\-bit alpha\-premultiplied color, having 8 bits for each of red, green, blue and alpha. 
.PP
.BR "func (RGBA) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "RGBA64"
.B type RGBA64 struct {
.RS
.B R, G, B, A uint16
.RE
.B }
.PP
RGBA64 represents a 64\-bit alpha\-premultiplied color, having 16 bits for each of red, green, blue and alpha. 
.PP
.BR "func (RGBA64) RGBA() (" "r" ", " "g" ", " "b" ", " "a" " uint32)"
.SS "YCbCr"
.B type YCbCr struct {
.RS
.B Y, Cb, Cr uint8
.RE
.B }
.PP
YCbCr represents a fully opaque 24\-bit Y'CbCr color, having 8 bits each for one luma and two chroma components. 
.PP
JPEG, VP8, the MPEG family and other codecs use this color model. 
Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction. 
.PP
Conversion between RGB and Y'CbCr is lossy and there are multiple, slightly different formulae for converting between the two. 
This package follows the JFIF specification at http://www.w3.org/Graphics/JPEG/jfif3.pdf. 
.PP
.BR "func (YCbCr) RGBA() (uint32, uint32, uint32, uint32)"
.SS "modelFunc"
.B type modelFunc struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*modelFunc) Convert(" "c" " Color) Color"
