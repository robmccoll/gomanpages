.\"    Automatically generated by mango(1)
.TH "reflect" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
reflect \- Package reflect implements run-time reflection, allowing a program to
manipulate objects with arbitrary types.
.SH "SYNOPSIS"
.B import \*(lqreflect\(rq
.sp
.RB "func " Copy
.sp 0
.RB "func " DeepEqual
.sp 0
.RB "func " Select
.sp 0
.RB "type " ChanDir
.sp 0
.RS
.RB "func (ChanDir) " String
.sp 0
.RE
.RB "type " Kind
.sp 0
.RS
.RB "func (Kind) " String
.sp 0
.RE
.RB "type " Method
.sp 0
.RB "type " SelectCase
.sp 0
.RB "type " SelectDir
.sp 0
.RB "type " SliceHeader
.sp 0
.RB "type " StringHeader
.sp 0
.RB "type " StructField
.sp 0
.RB "type " StructTag
.sp 0
.RS
.RB "func (StructTag) " Get
.sp 0
.RE
.RB "type " Type
.sp 0
.RS
.RB "func " ChanOf
.sp 0
.RB "func " MapOf
.sp 0
.RB "func " PtrTo
.sp 0
.RB "func " SliceOf
.sp 0
.RB "func " TypeOf
.sp 0
.RE
.RB "type " Value
.sp 0
.RS
.RB "func " Append
.sp 0
.RB "func " AppendSlice
.sp 0
.RB "func " Indirect
.sp 0
.RB "func " MakeChan
.sp 0
.RB "func " MakeFunc
.sp 0
.RB "func " MakeMap
.sp 0
.RB "func " MakeSlice
.sp 0
.RB "func " New
.sp 0
.RB "func " NewAt
.sp 0
.RB "func " ValueOf
.sp 0
.RB "func " Zero
.sp 0
.RB "func (Value) " Addr
.sp 0
.RB "func (Value) " Bool
.sp 0
.RB "func (Value) " Bytes
.sp 0
.RB "func (Value) " Call
.sp 0
.RB "func (Value) " CallSlice
.sp 0
.RB "func (Value) " CanAddr
.sp 0
.RB "func (Value) " CanInterface
.sp 0
.RB "func (Value) " CanSet
.sp 0
.RB "func (Value) " Cap
.sp 0
.RB "func (Value) " Close
.sp 0
.RB "func (Value) " Complex
.sp 0
.RB "func (Value) " Convert
.sp 0
.RB "func (Value) " Elem
.sp 0
.RB "func (Value) " Field
.sp 0
.RB "func (Value) " FieldByIndex
.sp 0
.RB "func (Value) " FieldByName
.sp 0
.RB "func (Value) " FieldByNameFunc
.sp 0
.RB "func (Value) " Float
.sp 0
.RB "func (Value) " Index
.sp 0
.RB "func (Value) " Int
.sp 0
.RB "func (Value) " Interface
.sp 0
.RB "func (Value) " InterfaceData
.sp 0
.RB "func (Value) " IsNil
.sp 0
.RB "func (Value) " IsValid
.sp 0
.RB "func (Value) " Kind
.sp 0
.RB "func (Value) " Len
.sp 0
.RB "func (Value) " MapIndex
.sp 0
.RB "func (Value) " MapKeys
.sp 0
.RB "func (Value) " Method
.sp 0
.RB "func (Value) " MethodByName
.sp 0
.RB "func (Value) " NumField
.sp 0
.RB "func (Value) " NumMethod
.sp 0
.RB "func (Value) " OverflowComplex
.sp 0
.RB "func (Value) " OverflowFloat
.sp 0
.RB "func (Value) " OverflowInt
.sp 0
.RB "func (Value) " OverflowUint
.sp 0
.RB "func (Value) " Pointer
.sp 0
.RB "func (Value) " Recv
.sp 0
.RB "func (Value) " Send
.sp 0
.RB "func (Value) " Set
.sp 0
.RB "func (Value) " SetBool
.sp 0
.RB "func (Value) " SetBytes
.sp 0
.RB "func (Value) " SetCap
.sp 0
.RB "func (Value) " SetComplex
.sp 0
.RB "func (Value) " SetFloat
.sp 0
.RB "func (Value) " SetInt
.sp 0
.RB "func (Value) " SetLen
.sp 0
.RB "func (Value) " SetMapIndex
.sp 0
.RB "func (Value) " SetPointer
.sp 0
.RB "func (Value) " SetString
.sp 0
.RB "func (Value) " SetUint
.sp 0
.RB "func (Value) " Slice
.sp 0
.RB "func (Value) " Slice3
.sp 0
.RB "func (Value) " String
.sp 0
.RB "func (Value) " TryRecv
.sp 0
.RB "func (Value) " TrySend
.sp 0
.RB "func (Value) " Type
.sp 0
.RB "func (Value) " Uint
.sp 0
.RB "func (Value) " UnsafeAddr
.sp 0
.RE
.RB "type " ValueError
.sp 0
.RS
.RB "func (*ValueError) " Error
.sp 0
.RE
.RB "type " arrayType
.sp 0
.RS
.RB "func (*arrayType) " Align
.sp 0
.RB "func (*arrayType) " AssignableTo
.sp 0
.RB "func (*arrayType) " Bits
.sp 0
.RB "func (*arrayType) " ChanDir
.sp 0
.RB "func (*arrayType) " ConvertibleTo
.sp 0
.RB "func (*arrayType) " Elem
.sp 0
.RB "func (*arrayType) " Field
.sp 0
.RB "func (*arrayType) " FieldAlign
.sp 0
.RB "func (*arrayType) " FieldByIndex
.sp 0
.RB "func (*arrayType) " FieldByName
.sp 0
.RB "func (*arrayType) " FieldByNameFunc
.sp 0
.RB "func (*arrayType) " Implements
.sp 0
.RB "func (*arrayType) " In
.sp 0
.RB "func (*arrayType) " IsVariadic
.sp 0
.RB "func (*arrayType) " Key
.sp 0
.RB "func (*arrayType) " Kind
.sp 0
.RB "func (*arrayType) " Len
.sp 0
.RB "func (*arrayType) " Method
.sp 0
.RB "func (*arrayType) " MethodByName
.sp 0
.RB "func (*arrayType) " Name
.sp 0
.RB "func (*arrayType) " NumField
.sp 0
.RB "func (*arrayType) " NumIn
.sp 0
.RB "func (*arrayType) " NumMethod
.sp 0
.RB "func (*arrayType) " NumOut
.sp 0
.RB "func (*arrayType) " Out
.sp 0
.RB "func (*arrayType) " PkgPath
.sp 0
.RB "func (*arrayType) " Size
.sp 0
.RB "func (*arrayType) " String
.sp 0
.RE
.RB "type " chanType
.sp 0
.RS
.RB "func (*chanType) " Align
.sp 0
.RB "func (*chanType) " AssignableTo
.sp 0
.RB "func (*chanType) " Bits
.sp 0
.RB "func (*chanType) " ChanDir
.sp 0
.RB "func (*chanType) " ConvertibleTo
.sp 0
.RB "func (*chanType) " Elem
.sp 0
.RB "func (*chanType) " Field
.sp 0
.RB "func (*chanType) " FieldAlign
.sp 0
.RB "func (*chanType) " FieldByIndex
.sp 0
.RB "func (*chanType) " FieldByName
.sp 0
.RB "func (*chanType) " FieldByNameFunc
.sp 0
.RB "func (*chanType) " Implements
.sp 0
.RB "func (*chanType) " In
.sp 0
.RB "func (*chanType) " IsVariadic
.sp 0
.RB "func (*chanType) " Key
.sp 0
.RB "func (*chanType) " Kind
.sp 0
.RB "func (*chanType) " Len
.sp 0
.RB "func (*chanType) " Method
.sp 0
.RB "func (*chanType) " MethodByName
.sp 0
.RB "func (*chanType) " Name
.sp 0
.RB "func (*chanType) " NumField
.sp 0
.RB "func (*chanType) " NumIn
.sp 0
.RB "func (*chanType) " NumMethod
.sp 0
.RB "func (*chanType) " NumOut
.sp 0
.RB "func (*chanType) " Out
.sp 0
.RB "func (*chanType) " PkgPath
.sp 0
.RB "func (*chanType) " Size
.sp 0
.RB "func (*chanType) " String
.sp 0
.RE
.RB "type " funcType
.sp 0
.RS
.RB "func (*funcType) " Align
.sp 0
.RB "func (*funcType) " AssignableTo
.sp 0
.RB "func (*funcType) " Bits
.sp 0
.RB "func (*funcType) " ChanDir
.sp 0
.RB "func (*funcType) " ConvertibleTo
.sp 0
.RB "func (*funcType) " Elem
.sp 0
.RB "func (*funcType) " Field
.sp 0
.RB "func (*funcType) " FieldAlign
.sp 0
.RB "func (*funcType) " FieldByIndex
.sp 0
.RB "func (*funcType) " FieldByName
.sp 0
.RB "func (*funcType) " FieldByNameFunc
.sp 0
.RB "func (*funcType) " Implements
.sp 0
.RB "func (*funcType) " In
.sp 0
.RB "func (*funcType) " IsVariadic
.sp 0
.RB "func (*funcType) " Key
.sp 0
.RB "func (*funcType) " Kind
.sp 0
.RB "func (*funcType) " Len
.sp 0
.RB "func (*funcType) " Method
.sp 0
.RB "func (*funcType) " MethodByName
.sp 0
.RB "func (*funcType) " Name
.sp 0
.RB "func (*funcType) " NumField
.sp 0
.RB "func (*funcType) " NumIn
.sp 0
.RB "func (*funcType) " NumMethod
.sp 0
.RB "func (*funcType) " NumOut
.sp 0
.RB "func (*funcType) " Out
.sp 0
.RB "func (*funcType) " PkgPath
.sp 0
.RB "func (*funcType) " Size
.sp 0
.RB "func (*funcType) " String
.sp 0
.RE
.RB "type " interfaceType
.sp 0
.RS
.RB "func (*interfaceType) " Align
.sp 0
.RB "func (*interfaceType) " AssignableTo
.sp 0
.RB "func (*interfaceType) " Bits
.sp 0
.RB "func (*interfaceType) " ChanDir
.sp 0
.RB "func (*interfaceType) " ConvertibleTo
.sp 0
.RB "func (*interfaceType) " Elem
.sp 0
.RB "func (*interfaceType) " Field
.sp 0
.RB "func (*interfaceType) " FieldAlign
.sp 0
.RB "func (*interfaceType) " FieldByIndex
.sp 0
.RB "func (*interfaceType) " FieldByName
.sp 0
.RB "func (*interfaceType) " FieldByNameFunc
.sp 0
.RB "func (*interfaceType) " Implements
.sp 0
.RB "func (*interfaceType) " In
.sp 0
.RB "func (*interfaceType) " IsVariadic
.sp 0
.RB "func (*interfaceType) " Key
.sp 0
.RB "func (*interfaceType) " Kind
.sp 0
.RB "func (*interfaceType) " Len
.sp 0
.RB "func (*interfaceType) " Method
.sp 0
.RB "func (*interfaceType) " MethodByName
.sp 0
.RB "func (*interfaceType) " Name
.sp 0
.RB "func (*interfaceType) " NumField
.sp 0
.RB "func (*interfaceType) " NumIn
.sp 0
.RB "func (*interfaceType) " NumMethod
.sp 0
.RB "func (*interfaceType) " NumOut
.sp 0
.RB "func (*interfaceType) " Out
.sp 0
.RB "func (*interfaceType) " PkgPath
.sp 0
.RB "func (*interfaceType) " Size
.sp 0
.RB "func (*interfaceType) " String
.sp 0
.RE
.RB "type " mapType
.sp 0
.RS
.RB "func (*mapType) " Align
.sp 0
.RB "func (*mapType) " AssignableTo
.sp 0
.RB "func (*mapType) " Bits
.sp 0
.RB "func (*mapType) " ChanDir
.sp 0
.RB "func (*mapType) " ConvertibleTo
.sp 0
.RB "func (*mapType) " Elem
.sp 0
.RB "func (*mapType) " Field
.sp 0
.RB "func (*mapType) " FieldAlign
.sp 0
.RB "func (*mapType) " FieldByIndex
.sp 0
.RB "func (*mapType) " FieldByName
.sp 0
.RB "func (*mapType) " FieldByNameFunc
.sp 0
.RB "func (*mapType) " Implements
.sp 0
.RB "func (*mapType) " In
.sp 0
.RB "func (*mapType) " IsVariadic
.sp 0
.RB "func (*mapType) " Key
.sp 0
.RB "func (*mapType) " Kind
.sp 0
.RB "func (*mapType) " Len
.sp 0
.RB "func (*mapType) " Method
.sp 0
.RB "func (*mapType) " MethodByName
.sp 0
.RB "func (*mapType) " Name
.sp 0
.RB "func (*mapType) " NumField
.sp 0
.RB "func (*mapType) " NumIn
.sp 0
.RB "func (*mapType) " NumMethod
.sp 0
.RB "func (*mapType) " NumOut
.sp 0
.RB "func (*mapType) " Out
.sp 0
.RB "func (*mapType) " PkgPath
.sp 0
.RB "func (*mapType) " Size
.sp 0
.RB "func (*mapType) " String
.sp 0
.RE
.RB "type " ptrType
.sp 0
.RS
.RB "func (*ptrType) " Align
.sp 0
.RB "func (*ptrType) " AssignableTo
.sp 0
.RB "func (*ptrType) " Bits
.sp 0
.RB "func (*ptrType) " ChanDir
.sp 0
.RB "func (*ptrType) " ConvertibleTo
.sp 0
.RB "func (*ptrType) " Elem
.sp 0
.RB "func (*ptrType) " Field
.sp 0
.RB "func (*ptrType) " FieldAlign
.sp 0
.RB "func (*ptrType) " FieldByIndex
.sp 0
.RB "func (*ptrType) " FieldByName
.sp 0
.RB "func (*ptrType) " FieldByNameFunc
.sp 0
.RB "func (*ptrType) " Implements
.sp 0
.RB "func (*ptrType) " In
.sp 0
.RB "func (*ptrType) " IsVariadic
.sp 0
.RB "func (*ptrType) " Key
.sp 0
.RB "func (*ptrType) " Kind
.sp 0
.RB "func (*ptrType) " Len
.sp 0
.RB "func (*ptrType) " Method
.sp 0
.RB "func (*ptrType) " MethodByName
.sp 0
.RB "func (*ptrType) " Name
.sp 0
.RB "func (*ptrType) " NumField
.sp 0
.RB "func (*ptrType) " NumIn
.sp 0
.RB "func (*ptrType) " NumMethod
.sp 0
.RB "func (*ptrType) " NumOut
.sp 0
.RB "func (*ptrType) " Out
.sp 0
.RB "func (*ptrType) " PkgPath
.sp 0
.RB "func (*ptrType) " Size
.sp 0
.RB "func (*ptrType) " String
.sp 0
.RE
.RB "type " rtype
.sp 0
.RS
.RB "func (*rtype) " Align
.sp 0
.RB "func (*rtype) " AssignableTo
.sp 0
.RB "func (*rtype) " Bits
.sp 0
.RB "func (*rtype) " ChanDir
.sp 0
.RB "func (*rtype) " ConvertibleTo
.sp 0
.RB "func (*rtype) " Elem
.sp 0
.RB "func (*rtype) " Field
.sp 0
.RB "func (*rtype) " FieldAlign
.sp 0
.RB "func (*rtype) " FieldByIndex
.sp 0
.RB "func (*rtype) " FieldByName
.sp 0
.RB "func (*rtype) " FieldByNameFunc
.sp 0
.RB "func (*rtype) " Implements
.sp 0
.RB "func (*rtype) " In
.sp 0
.RB "func (*rtype) " IsVariadic
.sp 0
.RB "func (*rtype) " Key
.sp 0
.RB "func (*rtype) " Kind
.sp 0
.RB "func (*rtype) " Len
.sp 0
.RB "func (*rtype) " Method
.sp 0
.RB "func (*rtype) " MethodByName
.sp 0
.RB "func (*rtype) " Name
.sp 0
.RB "func (*rtype) " NumField
.sp 0
.RB "func (*rtype) " NumIn
.sp 0
.RB "func (*rtype) " NumMethod
.sp 0
.RB "func (*rtype) " NumOut
.sp 0
.RB "func (*rtype) " Out
.sp 0
.RB "func (*rtype) " PkgPath
.sp 0
.RB "func (*rtype) " Size
.sp 0
.RB "func (*rtype) " String
.sp 0
.RE
.RB "type " sliceHeader
.sp 0
.RB "type " sliceType
.sp 0
.RS
.RB "func (*sliceType) " Align
.sp 0
.RB "func (*sliceType) " AssignableTo
.sp 0
.RB "func (*sliceType) " Bits
.sp 0
.RB "func (*sliceType) " ChanDir
.sp 0
.RB "func (*sliceType) " ConvertibleTo
.sp 0
.RB "func (*sliceType) " Elem
.sp 0
.RB "func (*sliceType) " Field
.sp 0
.RB "func (*sliceType) " FieldAlign
.sp 0
.RB "func (*sliceType) " FieldByIndex
.sp 0
.RB "func (*sliceType) " FieldByName
.sp 0
.RB "func (*sliceType) " FieldByNameFunc
.sp 0
.RB "func (*sliceType) " Implements
.sp 0
.RB "func (*sliceType) " In
.sp 0
.RB "func (*sliceType) " IsVariadic
.sp 0
.RB "func (*sliceType) " Key
.sp 0
.RB "func (*sliceType) " Kind
.sp 0
.RB "func (*sliceType) " Len
.sp 0
.RB "func (*sliceType) " Method
.sp 0
.RB "func (*sliceType) " MethodByName
.sp 0
.RB "func (*sliceType) " Name
.sp 0
.RB "func (*sliceType) " NumField
.sp 0
.RB "func (*sliceType) " NumIn
.sp 0
.RB "func (*sliceType) " NumMethod
.sp 0
.RB "func (*sliceType) " NumOut
.sp 0
.RB "func (*sliceType) " Out
.sp 0
.RB "func (*sliceType) " PkgPath
.sp 0
.RB "func (*sliceType) " Size
.sp 0
.RB "func (*sliceType) " String
.sp 0
.RE
.RB "type " stringHeader
.sp 0
.RB "type " structType
.sp 0
.RS
.RB "func (*structType) " Align
.sp 0
.RB "func (*structType) " AssignableTo
.sp 0
.RB "func (*structType) " Bits
.sp 0
.RB "func (*structType) " ChanDir
.sp 0
.RB "func (*structType) " ConvertibleTo
.sp 0
.RB "func (*structType) " Elem
.sp 0
.RB "func (*structType) " Field
.sp 0
.RB "func (*structType) " FieldAlign
.sp 0
.RB "func (*structType) " FieldByIndex
.sp 0
.RB "func (*structType) " FieldByName
.sp 0
.RB "func (*structType) " FieldByNameFunc
.sp 0
.RB "func (*structType) " Implements
.sp 0
.RB "func (*structType) " In
.sp 0
.RB "func (*structType) " IsVariadic
.sp 0
.RB "func (*structType) " Key
.sp 0
.RB "func (*structType) " Kind
.sp 0
.RB "func (*structType) " Len
.sp 0
.RB "func (*structType) " Method
.sp 0
.RB "func (*structType) " MethodByName
.sp 0
.RB "func (*structType) " Name
.sp 0
.RB "func (*structType) " NumField
.sp 0
.RB "func (*structType) " NumIn
.sp 0
.RB "func (*structType) " NumMethod
.sp 0
.RB "func (*structType) " NumOut
.sp 0
.RB "func (*structType) " Out
.sp 0
.RB "func (*structType) " PkgPath
.sp 0
.RB "func (*structType) " Size
.sp 0
.RB "func (*structType) " String
.sp 0
.RE
.RB "type " uncommonType
.sp 0
.RS
.RB "func (*uncommonType) " Method
.sp 0
.RB "func (*uncommonType) " MethodByName
.sp 0
.RB "func (*uncommonType) " Name
.sp 0
.RB "func (*uncommonType) " NumMethod
.sp 0
.RB "func (*uncommonType) " PkgPath
.sp 0
.RE
.SH "DESCRIPTION"
Package reflect implements run\-time reflection, allowing a program to manipulate objects with arbitrary types. 
The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type. 
.PP
A call to ValueOf returns a Value representing the run\-time data. 
Zero takes a Type and returns a Value representing a zero value for that type. 
.PP
See "The Laws of Reflection" for an introduction to reflection in Go: http://golang.org/doc/articles/laws_of_reflection.html 
.SH "FUNCTIONS"
.PP
.BR "func Copy(" "dst" ", " "src" " Value) int"
.PP
Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. 
It returns the number of elements copied. 
Dst and src each must have kind Slice or Array, and dst and src must have the same element type. 
.PP
.BR "func DeepEqual(" "a1" ", " "a2" " interface{}) bool"
.PP
DeepEqual tests for deep equality. 
It uses normal == equality where possible but will scan elements of arrays, slices, maps, and fields of structs. 
In maps, keys are compared with == but elements use deep equality. 
DeepEqual correctly handles recursive types. 
Functions are equal only if they are both nil. 
An empty slice is not equal to a nil slice. 
.PP
.BR "func Select(" "cases" " []SelectCase) (" "chosen" " int, " "recv" " Value, " "recvOK" " bool)"
.PP
Select executes a select operation described by the list of cases. 
Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo\-random choice, and then executes that case. 
It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed). 
.SH "TYPES"
.SS "ChanDir"
.B type ChanDir int
.PP
ChanDir represents a channel type's direction. 
.PP
.B const (
.RS
.B RecvDir 
.sp 0
.B SendDir 
.sp 0
.B BothDir 
.sp 0
.RE
.B )
.PP
.BR "func (ChanDir) String() string"
.SS "Kind"
.B type Kind uint
.PP
A Kind represents the specific kind of type that a Type represents. 
The zero Kind is not a valid kind. 
.PP
.B const (
.RS
.B Invalid 
.sp 0
.B Bool 
.sp 0
.B Int 
.sp 0
.B Int8 
.sp 0
.B Int16 
.sp 0
.B Int32 
.sp 0
.B Int64 
.sp 0
.B Uint 
.sp 0
.B Uint8 
.sp 0
.B Uint16 
.sp 0
.B Uint32 
.sp 0
.B Uint64 
.sp 0
.B Uintptr 
.sp 0
.B Float32 
.sp 0
.B Float64 
.sp 0
.B Complex64 
.sp 0
.B Complex128 
.sp 0
.B Array 
.sp 0
.B Chan 
.sp 0
.B Func 
.sp 0
.B Interface 
.sp 0
.B Map 
.sp 0
.B Ptr 
.sp 0
.B Slice 
.sp 0
.B String 
.sp 0
.B Struct 
.sp 0
.B UnsafePointer 
.sp 0
.RE
.B )
.PP
.BR "func (Kind) String() string"
.SS "Method"
.B type Method struct {
.RS
.B Name string
.sp 0
.B PkgPath string
.sp 0
.B Type Type
.sp 0
.B Func Value
.sp 0
.B Index int
.RE
.B }
.PP
Method represents a single method. 
.SS "SelectCase"
.B type SelectCase struct {
.RS
.B Dir SelectDir
.sp 0
.B Chan Value
.sp 0
.B Send Value
.RE
.B }
.PP
A SelectCase describes a single case in a select operation. 
The kind of case depends on Dir, the communication direction. 
.PP
If Dir is SelectDefault, the case represents a default case. 
Chan and Send must be zero Values. 
.PP
If Dir is SelectSend, the case represents a send operation. 
Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. 
As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non\-zero. 
.PP
If Dir is SelectRecv, the case represents a receive operation. 
Normally Chan's underlying value must be a channel and Send must be a zero Value. 
If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. 
When a receive operation is selected, the received Value is returned by Select. 
.SS "SelectDir"
.B type SelectDir int
.PP
A SelectDir describes the communication direction of a select case. 
.PP
.B const (
.RS
.B 
.sp 0
.B SelectSend 
.sp 0
.B SelectRecv 
.sp 0
.B SelectDefault 
.sp 0
.RE
.B )
.SS "SliceHeader"
.B type SliceHeader struct {
.RS
.B Data uintptr
.sp 0
.B Len int
.sp 0
.B Cap int
.RE
.B }
.PP
SliceHeader is the runtime representation of a slice. 
It cannot be used safely or portably and its representation may change in a later release. 
Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data. 
.SS "StringHeader"
.B type StringHeader struct {
.RS
.B Data uintptr
.sp 0
.B Len int
.RE
.B }
.PP
StringHeader is the runtime representation of a string. 
It cannot be used safely or portably and its representation may change in a later release. 
Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data. 
.SS "StructField"
.B type StructField struct {
.RS
.B Name string
.sp 0
.B PkgPath string
.sp 0
.B Type Type
.sp 0
.B Tag StructTag
.sp 0
.B Offset uintptr
.sp 0
.B Index []int
.sp 0
.B Anonymous bool
.RE
.B }
.PP
A StructField describes a single field in a struct. 
.SS "StructTag"
.B type StructTag string
.PP
A StructTag is the tag string in a struct field. 
.PP
By convention, tag strings are a concatenation of optionally space\-separated key:"value" pairs. 
Each key is a non\-empty string consisting of non\-control characters other than space (U+0020 \(fm \(fm), quote (U+0022 \(fm"'), and colon (U+003A \(fm:'). 
Each value is quoted using U+0022 \(fm"' characters and Go string literal syntax. 
.PP
.BR "func (StructTag) Get(" "key" " string) string"
.PP
Get returns the value associated with key in the tag string. 
If there is no such key in the tag, Get returns the empty string. 
If the tag does not have the conventional format, the value returned by Get is unspecified. 
.SS "Type"
.B type Type interface {
.RS
.B Align() int
.sp 0
.B FieldAlign() int
.sp 0
.B Method(int) Method
.sp 0
.B MethodByName(string) (Method, bool)
.sp 0
.B NumMethod() int
.sp 0
.B Name() string
.sp 0
.B PkgPath() string
.sp 0
.B Size() uintptr
.sp 0
.B String() string
.sp 0
.B Kind() Kind
.sp 0
.B Implements(u Type) bool
.sp 0
.B AssignableTo(u Type) bool
.sp 0
.B ConvertibleTo(u Type) bool
.sp 0
.B Bits() int
.sp 0
.B ChanDir() ChanDir
.sp 0
.B IsVariadic() bool
.sp 0
.B Elem() Type
.sp 0
.B Field(i int) StructField
.sp 0
.B FieldByIndex(index []int) StructField
.sp 0
.B FieldByName(name string) (StructField, bool)
.sp 0
.B FieldByNameFunc(match func(string) bool) (StructField, bool)
.sp 0
.B In(i int) Type
.sp 0
.B Key() Type
.sp 0
.B Len() int
.sp 0
.B NumField() int
.sp 0
.B NumIn() int
.sp 0
.B NumOut() int
.sp 0
.B Out(i int) Type
.sp 0
.B 
.sp 0
.B 
.sp 0
.sp 0
.B //contains unexported methods.
.RE
.B }
.PP
Type is the representation of a Go type. 
.PP
Not all methods apply to all kinds of types. 
Restrictions, if any, are noted in the documentation for each method. 
Use the Kind method to find out the kind of type before calling kind\-specific methods. 
Calling a method inappropriate to the kind of type causes a run\-time panic. 
.PP
.BR "func ChanOf(" "dir" " ChanDir, " "t" " Type) Type"
.PP
ChanOf returns the channel type with the given direction and element type. 
For example, if t represents int, ChanOf(RecvDir, t) represents <\-chan int. 
.PP
The gc runtime imposes a limit of 64 kB on channel element types. 
If t's size is equal to or exceeds this limit, ChanOf panics. 
.PP
.BR "func MapOf(" "key" ", " "elem" " Type) Type"
.PP
MapOf returns the map type with the given key and element types. 
For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string. 
.PP
If the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics. 
.PP
.BR "func PtrTo(" "t" " Type) Type"
.PP
PtrTo returns the pointer type with element t. 
For example, if t represents type Foo, 
.BR PtrTo (t)
represents *Foo. 
.PP
.BR "func SliceOf(" "t" " Type) Type"
.PP
SliceOf returns the slice type with element type t. 
For example, if t represents int, 
.BR SliceOf (t)
represents []int. 
.PP
.BR "func TypeOf(" "i" " interface{}) Type"
.PP
TypeOf returns the reflection Type of the value in the interface{}. 
TypeOf(nil) returns nil. 
.SS "Value"
.B type Value struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Value is the reflection interface to a Go value. 
.PP
Not all methods apply to all kinds of values. 
Restrictions, if any, are noted in the documentation for each method. 
Use the Kind method to find out the kind of value before calling kind\-specific methods. 
Calling a method inappropriate to the kind of type causes a run time panic. 
.PP
The zero Value represents no value. 
Its IsValid method returns false, its Kind method returns Invalid, its String method returns "<invalid Value>", and all other methods panic. 
Most functions and methods never return an invalid value. 
If one does, its documentation states the conditions explicitly. 
.PP
A Value can be used concurrently by multiple goroutines provided that the underlying Go value can be used concurrently for the equivalent direct operations. 
.PP
.BR "func Append(" "s" " Value, " "x" " ...Value) Value"
.PP
Append appends the values x to a slice s and returns the resulting slice. 
As in Go, each x's value must be assignable to the slice's element type. 
.PP
.BR "func AppendSlice(" "s" ", " "t" " Value) Value"
.PP
AppendSlice appends a slice t to a slice s and returns the resulting slice. 
The slices s and t must have the same element type. 
.PP
.BR "func Indirect(" "v" " Value) Value"
.PP
Indirect returns the value that v points to. 
If v is a nil pointer, Indirect returns a zero Value. 
If v is not a pointer, Indirect returns v. 
.PP
.BR "func MakeChan(" "typ" " Type, " "buffer" " int) Value"
.PP
MakeChan creates a new channel with the specified type and buffer size. 
.PP
.BR "func MakeFunc(" "typ" " Type, " "fn" " func(args []Value) (results []Value)) Value"
.PP
MakeFunc returns a new function of the given Type that wraps the function fn. 
When called, that new function does the following: 
.PP
.RS
\- converts its arguments to a slice of Values.
.sp 0
\- runs results := fn(args).
.sp 0
\- returns the results as a slice of Values, one per formal result.
.sp 0
.sp
.RE
.PP
The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. 
If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. 
The result Value slice returned by fn must have the number and type of results given by typ. 
.PP
The Value.Call method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values. 
.PP
The Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types. 
.PP
.BR "func MakeMap(" "typ" " Type) Value"
.PP
MakeMap creates a new map of the specified type. 
.PP
.BR "func MakeSlice(" "typ" " Type, " "len" ", " "cap" " int) Value"
.PP
MakeSlice creates a new zero\-initialized slice value for the specified slice type, length, and capacity. 
.PP
.BR "func New(" "typ" " Type) Value"
.PP
New returns a Value representing a pointer to a new zero value for the specified type. 
That is, the returned Value's Type is PtrTo(typ). 
.PP
.BR "func NewAt(" "typ" " Type, " "p" " unsafe.Pointer) Value"
.PP
NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer. 
.PP
.BR "func ValueOf(" "i" " interface{}) Value"
.PP
ValueOf returns a new Value initialized to the concrete value stored in the interface i. 
ValueOf(nil) returns the zero Value. 
.PP
.BR "func Zero(" "typ" " Type) Value"
.PP
Zero returns a Value representing the zero value for the specified type. 
The result is different from the zero value of the Value struct, which represents no value at all. 
For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0. 
The returned value is neither addressable nor settable. 
.PP
.BR "func (Value) Addr() Value"
.PP
Addr returns a pointer value representing the address of v. 
It panics if CanAddr() returns false. 
Addr is typically used to obtain a pointer to a struct field or slice element in order to call a method that requires a pointer receiver. 
.PP
.BR "func (Value) Bool() bool"
.PP
Bool returns v's underlying value. 
It panics if v's kind is not Bool. 
.PP
.BR "func (Value) Bytes() []byte"
.PP
Bytes returns v's underlying value. 
It panics if v's underlying value is not a slice of bytes. 
.PP
.BR "func (Value) Call(" "in" " []Value) []Value"
.PP
Call calls the function v with the input arguments in. 
For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). 
Call panics if v's Kind is not Func. 
It returns the output results as Values. 
As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. 
If v is a variadic function, Call creates the variadic slice parameter itself, copying in the corresponding values. 
.PP
.BR "func (Value) CallSlice(" "in" " []Value) []Value"
.PP
CallSlice calls the variadic function v with the input arguments in, assigning the slice in[len(in)\-1] to v's final variadic argument. 
For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]...). 
Call panics if v's Kind is not Func or if v is not variadic. 
It returns the output results as Values. 
As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. 
.PP
.BR "func (Value) CanAddr() bool"
.PP
CanAddr returns true if the value's address can be obtained with Addr. 
Such values are called addressable. 
A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. 
If CanAddr returns false, calling Addr will panic. 
.PP
.BR "func (Value) CanInterface() bool"
.PP
CanInterface returns true if Interface can be used without panicking. 
.PP
.BR "func (Value) CanSet() bool"
.PP
CanSet returns true if the value of v can be changed. 
A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. 
If CanSet returns false, calling Set or any type\-specific setter (e.g., SetBool, SetInt64) will panic. 
.PP
.BR "func (Value) Cap() int"
.PP
Cap returns v's capacity. 
It panics if v's Kind is not Array, Chan, or Slice. 
.PP
.BR "func (Value) Close()"
.PP
Close closes the channel v. 
It panics if v's Kind is not Chan. 
.PP
.BR "func (Value) Complex() complex128"
.PP
Complex returns v's underlying value, as a complex128. 
It panics if v's Kind is not Complex64 or Complex128 
.PP
.BR "func (Value) Convert(" "t" " Type) Value"
.PP
Convert returns the value v converted to type t. 
If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics. 
.PP
.BR "func (Value) Elem() Value"
.PP
Elem returns the value that the interface v contains or that the pointer v points to. 
It panics if v's Kind is not Interface or Ptr. 
It returns the zero Value if v is nil. 
.PP
.BR "func (Value) Field(" "i" " int) Value"
.PP
Field returns the i'th field of the struct v. 
It panics if v's Kind is not Struct or i is out of range. 
.PP
.BR "func (Value) FieldByIndex(" "index" " []int) Value"
.PP
FieldByIndex returns the nested field corresponding to index. 
It panics if v's Kind is not struct. 
.PP
.BR "func (Value) FieldByName(" "name" " string) Value"
.PP
FieldByName returns the struct field with the given name. 
It returns the zero Value if no field was found. 
It panics if v's Kind is not struct. 
.PP
.BR "func (Value) FieldByNameFunc(" "match" " func(string) bool) Value"
.PP
FieldByNameFunc returns the struct field with a name that satisfies the match function. 
It panics if v's Kind is not struct. 
It returns the zero Value if no field was found. 
.PP
.BR "func (Value) Float() float64"
.PP
Float returns v's underlying value, as a float64. 
It panics if v's Kind is not Float32 or Float64 
.PP
.BR "func (Value) Index(" "i" " int) Value"
.PP
Index returns v's i'th element. 
It panics if v's Kind is not Array, Slice, or String or i is out of range. 
.PP
.BR "func (Value) Int() int64"
.PP
Int returns v's underlying value, as an int64. 
It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64. 
.PP
.BR "func (Value) Interface() (" "i" " interface{})"
.PP
Interface returns v's current value as an interface{}. 
It is equivalent to: 
.PP
.RS
var i interface{} = (v's underlying value)
.RE
.PP
It panics if the Value was obtained by accessing unexported struct fields. 
.PP
.BR "func (Value) InterfaceData() []uintptr"
.PP
InterfaceData returns the interface v's value as a uintptr pair. 
It panics if v's Kind is not Interface. 
.PP
.BR "func (Value) IsNil() bool"
.PP
IsNil reports whether its argument v is nil. 
The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. 
Note that IsNil is not always equivalent to a regular comparison with nil in Go. 
For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value. 
.PP
.BR "func (Value) IsValid() bool"
.PP
IsValid returns true if v represents a value. 
It returns false if v is the zero Value. 
If IsValid returns false, all other methods except String panic. 
Most functions and methods never return an invalid value. 
If one does, its documentation states the conditions explicitly. 
.PP
.BR "func (Value) Kind() Kind"
.PP
Kind returns v's Kind. 
If v is the zero Value (IsValid returns false), Kind returns Invalid. 
.PP
.BR "func (Value) Len() int"
.PP
Len returns v's length. 
It panics if v's Kind is not Array, Chan, Map, Slice, or String. 
.PP
.BR "func (Value) MapIndex(" "key" " Value) Value"
.PP
MapIndex returns the value associated with key in the map v. 
It panics if v's Kind is not Map. 
It returns the zero Value if key is not found in the map or if v represents a nil map. 
As in Go, the key's value must be assignable to the map's key type. 
.PP
.BR "func (Value) MapKeys() []Value"
.PP
MapKeys returns a slice containing all the keys present in the map, in unspecified order. 
It panics if v's Kind is not Map. 
It returns an empty slice if v represents a nil map. 
.PP
.BR "func (Value) Method(" "i" " int) Value"
.PP
Method returns a function value corresponding to v's i'th method. 
The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. 
Method panics if i is out of range or if v is a nil interface value. 
.PP
.BR "func (Value) MethodByName(" "name" " string) Value"
.PP
MethodByName returns a function value corresponding to the method of v with the given name. 
The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. 
It returns the zero Value if no method was found. 
.PP
.BR "func (Value) NumField() int"
.PP
NumField returns the number of fields in the struct v. 
It panics if v's Kind is not Struct. 
.PP
.BR "func (Value) NumMethod() int"
.PP
NumMethod returns the number of methods in the value's method set. 
.PP
.BR "func (Value) OverflowComplex(" "x" " complex128) bool"
.PP
OverflowComplex returns true if the complex128 x cannot be represented by v's type. 
It panics if v's Kind is not Complex64 or Complex128. 
.PP
.BR "func (Value) OverflowFloat(" "x" " float64) bool"
.PP
OverflowFloat returns true if the float64 x cannot be represented by v's type. 
It panics if v's Kind is not Float32 or Float64. 
.PP
.BR "func (Value) OverflowInt(" "x" " int64) bool"
.PP
OverflowInt returns true if the int64 x cannot be represented by v's type. 
It panics if v's Kind is not Int, Int8, int16, Int32, or Int64. 
.PP
.BR "func (Value) OverflowUint(" "x" " uint64) bool"
.PP
OverflowUint returns true if the uint64 x cannot be represented by v's type. 
It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. 
.PP
.BR "func (Value) Pointer() uintptr"
.PP
Pointer returns v's value as a uintptr. 
It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. 
It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer. 
.PP
If v's Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. 
The only guarantee is that the result is zero if and only if v is a nil func Value. 
.PP
If v's Kind is Slice, the returned pointer is to the first element of the slice. 
If the slice is nil the returned value is 0. 
If the slice is empty but non\-nil the return value is non\-zero. 
.PP
.BR "func (Value) Recv() (" "x" " Value, " "ok" " bool)"
.PP
Recv receives and returns a value from the channel v. 
It panics if v's Kind is not Chan. 
The receive blocks until a value is ready. 
The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed. 
.PP
.BR "func (Value) Send(" "x" " Value)"
.PP
Send sends x on the channel v. 
It panics if v's kind is not Chan or if x's type is not the same type as v's element type. 
As in Go, x's value must be assignable to the channel's element type. 
.PP
.BR "func (Value) Set(" "x" " Value)"
.PP
Set assigns x to the value v. 
It panics if CanSet returns false. 
As in Go, x's value must be assignable to v's type. 
.PP
.BR "func (Value) SetBool(" "x" " bool)"
.PP
SetBool sets v's underlying value. 
It panics if v's Kind is not Bool or if CanSet() is false. 
.PP
.BR "func (Value) SetBytes(" "x" " []byte)"
.PP
SetBytes sets v's underlying value. 
It panics if v's underlying value is not a slice of bytes. 
.PP
.BR "func (Value) SetCap(" "n" " int)"
.PP
SetCap sets v's capacity to n. 
It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice. 
.PP
.BR "func (Value) SetComplex(" "x" " complex128)"
.PP
SetComplex sets v's underlying value to x. 
It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false. 
.PP
.BR "func (Value) SetFloat(" "x" " float64)"
.PP
SetFloat sets v's underlying value to x. 
It panics if v's Kind is not Float32 or Float64, or if CanSet() is false. 
.PP
.BR "func (Value) SetInt(" "x" " int64)"
.PP
SetInt sets v's underlying value to x. 
It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false. 
.PP
.BR "func (Value) SetLen(" "n" " int)"
.PP
SetLen sets v's length to n. 
It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice. 
.PP
.BR "func (Value) SetMapIndex(" "key" ", " "val" " Value)"
.PP
SetMapIndex sets the value associated with key in the map v to val. 
It panics if v's Kind is not Map. 
If val is the zero Value, SetMapIndex deletes the key from the map. 
Otherwise if v holds a nil map, SetMapIndex will panic. 
As in Go, key's value must be assignable to the map's key type, and val's value must be assignable to the map's value type. 
.PP
.BR "func (Value) SetPointer(" "x" " unsafe.Pointer)"
.PP
SetPointer sets the unsafe.Pointer value v to x. 
It panics if v's Kind is not UnsafePointer. 
.PP
.BR "func (Value) SetString(" "x" " string)"
.PP
SetString sets v's underlying value to x. 
It panics if v's Kind is not String or if CanSet() is false. 
.PP
.BR "func (Value) SetUint(" "x" " uint64)"
.PP
SetUint sets v's underlying value to x. 
It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false. 
.PP
.BR "func (Value) Slice(" "i" ", " "j" " int) Value"
.PP
Slice returns v[i:j]. 
It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds. 
.PP
.BR "func (Value) Slice3(" "i" ", " "j" ", " "k" " int) Value"
.PP
Slice3 is the 3\-index form of the slice operation: it returns v[i:j:k]. 
It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds. 
.PP
.BR "func (Value) String() string"
.PP
String returns the string v's underlying value, as a string. 
String is a special case because of Go's String method convention. 
Unlike the other getters, it does not panic if v's Kind is not String. 
Instead, it returns a string of the form "<T value>" where T is v's type. 
.PP
.BR "func (Value) TryRecv() (" "x" " Value, " "ok" " bool)"
.PP
TryRecv attempts to receive a value from the channel v but will not block. 
It panics if v's Kind is not Chan. 
If the receive delivers a value, x is the transferred value and ok is true. 
If the receive cannot finish without blocking, x is the zero Value and ok is false. 
If the channel is closed, x is the zero value for the channel's element type and ok is false. 
.PP
.BR "func (Value) TrySend(" "x" " Value) bool"
.PP
TrySend attempts to send x on the channel v but will not block. 
It panics if v's Kind is not Chan. 
It returns true if the value was sent, false otherwise. 
As in Go, x's value must be assignable to the channel's element type. 
.PP
.BR "func (Value) Type() Type"
.PP
Type returns v's type. 
.PP
.BR "func (Value) Uint() uint64"
.PP
Uint returns v's underlying value, as a uint64. 
It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. 
.PP
.BR "func (Value) UnsafeAddr() uintptr"
.PP
UnsafeAddr returns a pointer to v's data. 
It is for advanced clients that also import the "unsafe" package. 
It panics if v is not addressable. 
.SS "ValueError"
.B type ValueError struct {
.RS
.B Method string
.sp 0
.B Kind Kind
.RE
.B }
.PP
A ValueError occurs when a Value method is invoked on a Value that does not support it. 
Such cases are documented in the description of each method. 
.PP
.BR "func (*ValueError) Error() string"
.SS "arrayType"
.B type arrayType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
arrayType represents a fixed array type. 
.PP
.BR "func (*arrayType) Align() int"
.PP
.BR "func (*arrayType) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*arrayType) Bits() int"
.PP
.BR "func (*arrayType) ChanDir() ChanDir"
.PP
.BR "func (*arrayType) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*arrayType) Elem() Type"
.PP
.BR "func (*arrayType) Field(" "i" " int) StructField"
.PP
.BR "func (*arrayType) FieldAlign() int"
.PP
.BR "func (*arrayType) FieldByIndex(" "index" " []int) StructField"
.PP
.BR "func (*arrayType) FieldByName(" "name" " string) (StructField, bool)"
.PP
.BR "func (*arrayType) FieldByNameFunc(" "match" " func(string) bool) (StructField, bool)"
.PP
.BR "func (*arrayType) Implements(" "u" " Type) bool"
.PP
.BR "func (*arrayType) In(" "i" " int) Type"
.PP
.BR "func (*arrayType) IsVariadic() bool"
.PP
.BR "func (*arrayType) Key() Type"
.PP
.BR "func (*arrayType) Kind() Kind"
.PP
.BR "func (*arrayType) Len() int"
.PP
.BR "func (*arrayType) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*arrayType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*arrayType) Name() string"
.PP
.BR "func (*arrayType) NumField() int"
.PP
.BR "func (*arrayType) NumIn() int"
.PP
.BR "func (*arrayType) NumMethod() int"
.PP
TODO(rsc): 6g supplies these, but they are not as efficient as they could be: they have commonType as the receiver instead of *rtype. 
.PP
.BR "func (*arrayType) NumOut() int"
.PP
.BR "func (*arrayType) Out(" "i" " int) Type"
.PP
.BR "func (*arrayType) PkgPath() string"
.PP
.BR "func (*arrayType) Size() uintptr"
.PP
.BR "func (*arrayType) String() string"
.SS "chanType"
.B type chanType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
chanType represents a channel type. 
.PP
.BR "func (*chanType) Align() int"
.PP
.BR "func (*chanType) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*chanType) Bits() int"
.PP
.BR "func (*chanType) ChanDir() ChanDir"
.PP
.BR "func (*chanType) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*chanType) Elem() Type"
.PP
.BR "func (*chanType) Field(" "i" " int) StructField"
.PP
.BR "func (*chanType) FieldAlign() int"
.PP
.BR "func (*chanType) FieldByIndex(" "index" " []int) StructField"
.PP
.BR "func (*chanType) FieldByName(" "name" " string) (StructField, bool)"
.PP
.BR "func (*chanType) FieldByNameFunc(" "match" " func(string) bool) (StructField, bool)"
.PP
.BR "func (*chanType) Implements(" "u" " Type) bool"
.PP
.BR "func (*chanType) In(" "i" " int) Type"
.PP
.BR "func (*chanType) IsVariadic() bool"
.PP
.BR "func (*chanType) Key() Type"
.PP
.BR "func (*chanType) Kind() Kind"
.PP
.BR "func (*chanType) Len() int"
.PP
.BR "func (*chanType) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*chanType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*chanType) Name() string"
.PP
.BR "func (*chanType) NumField() int"
.PP
.BR "func (*chanType) NumIn() int"
.PP
.BR "func (*chanType) NumMethod() int"
.PP
TODO(rsc): 6g supplies these, but they are not as efficient as they could be: they have commonType as the receiver instead of *rtype. 
.PP
.BR "func (*chanType) NumOut() int"
.PP
.BR "func (*chanType) Out(" "i" " int) Type"
.PP
.BR "func (*chanType) PkgPath() string"
.PP
.BR "func (*chanType) Size() uintptr"
.PP
.BR "func (*chanType) String() string"
.SS "funcType"
.B type funcType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
funcType represents a function type. 
.PP
.BR "func (*funcType) Align() int"
.PP
.BR "func (*funcType) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*funcType) Bits() int"
.PP
.BR "func (*funcType) ChanDir() ChanDir"
.PP
.BR "func (*funcType) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*funcType) Elem() Type"
.PP
.BR "func (*funcType) Field(" "i" " int) StructField"
.PP
.BR "func (*funcType) FieldAlign() int"
.PP
.BR "func (*funcType) FieldByIndex(" "index" " []int) StructField"
.PP
.BR "func (*funcType) FieldByName(" "name" " string) (StructField, bool)"
.PP
.BR "func (*funcType) FieldByNameFunc(" "match" " func(string) bool) (StructField, bool)"
.PP
.BR "func (*funcType) Implements(" "u" " Type) bool"
.PP
.BR "func (*funcType) In(" "i" " int) Type"
.PP
.BR "func (*funcType) IsVariadic() bool"
.PP
.BR "func (*funcType) Key() Type"
.PP
.BR "func (*funcType) Kind() Kind"
.PP
.BR "func (*funcType) Len() int"
.PP
.BR "func (*funcType) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*funcType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*funcType) Name() string"
.PP
.BR "func (*funcType) NumField() int"
.PP
.BR "func (*funcType) NumIn() int"
.PP
.BR "func (*funcType) NumMethod() int"
.PP
TODO(rsc): 6g supplies these, but they are not as efficient as they could be: they have commonType as the receiver instead of *rtype. 
.PP
.BR "func (*funcType) NumOut() int"
.PP
.BR "func (*funcType) Out(" "i" " int) Type"
.PP
.BR "func (*funcType) PkgPath() string"
.PP
.BR "func (*funcType) Size() uintptr"
.PP
.BR "func (*funcType) String() string"
.SS "interfaceType"
.B type interfaceType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
interfaceType represents an interface type. 
.PP
.BR "func (*interfaceType) Align() int"
.PP
.BR "func (*interfaceType) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*interfaceType) Bits() int"
.PP
.BR "func (*interfaceType) ChanDir() ChanDir"
.PP
.BR "func (*interfaceType) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*interfaceType) Elem() Type"
.PP
.BR "func (*interfaceType) Field(" "i" " int) StructField"
.PP
.BR "func (*interfaceType) FieldAlign() int"
.PP
.BR "func (*interfaceType) FieldByIndex(" "index" " []int) StructField"
.PP
.BR "func (*interfaceType) FieldByName(" "name" " string) (StructField, bool)"
.PP
.BR "func (*interfaceType) FieldByNameFunc(" "match" " func(string) bool) (StructField, bool)"
.PP
.BR "func (*interfaceType) Implements(" "u" " Type) bool"
.PP
.BR "func (*interfaceType) In(" "i" " int) Type"
.PP
.BR "func (*interfaceType) IsVariadic() bool"
.PP
.BR "func (*interfaceType) Key() Type"
.PP
.BR "func (*interfaceType) Kind() Kind"
.PP
.BR "func (*interfaceType) Len() int"
.PP
.BR "func (*interfaceType) Method(" "i" " int) (" "m" " Method)"
.PP
Method returns the i'th method in the type's method set. 
.PP
.BR "func (*interfaceType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
MethodByName method with the given name in the type's method set. 
.PP
.BR "func (*interfaceType) Name() string"
.PP
.BR "func (*interfaceType) NumField() int"
.PP
.BR "func (*interfaceType) NumIn() int"
.PP
.BR "func (*interfaceType) NumMethod() int"
.PP
NumMethod returns the number of interface methods in the type's method set. 
.PP
.BR "func (*interfaceType) NumOut() int"
.PP
.BR "func (*interfaceType) Out(" "i" " int) Type"
.PP
.BR "func (*interfaceType) PkgPath() string"
.PP
.BR "func (*interfaceType) Size() uintptr"
.PP
.BR "func (*interfaceType) String() string"
.SS "mapType"
.B type mapType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
mapType represents a map type. 
.PP
.BR "func (*mapType) Align() int"
.PP
.BR "func (*mapType) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*mapType) Bits() int"
.PP
.BR "func (*mapType) ChanDir() ChanDir"
.PP
.BR "func (*mapType) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*mapType) Elem() Type"
.PP
.BR "func (*mapType) Field(" "i" " int) StructField"
.PP
.BR "func (*mapType) FieldAlign() int"
.PP
.BR "func (*mapType) FieldByIndex(" "index" " []int) StructField"
.PP
.BR "func (*mapType) FieldByName(" "name" " string) (StructField, bool)"
.PP
.BR "func (*mapType) FieldByNameFunc(" "match" " func(string) bool) (StructField, bool)"
.PP
.BR "func (*mapType) Implements(" "u" " Type) bool"
.PP
.BR "func (*mapType) In(" "i" " int) Type"
.PP
.BR "func (*mapType) IsVariadic() bool"
.PP
.BR "func (*mapType) Key() Type"
.PP
.BR "func (*mapType) Kind() Kind"
.PP
.BR "func (*mapType) Len() int"
.PP
.BR "func (*mapType) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*mapType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*mapType) Name() string"
.PP
.BR "func (*mapType) NumField() int"
.PP
.BR "func (*mapType) NumIn() int"
.PP
.BR "func (*mapType) NumMethod() int"
.PP
TODO(rsc): 6g supplies these, but they are not as efficient as they could be: they have commonType as the receiver instead of *rtype. 
.PP
.BR "func (*mapType) NumOut() int"
.PP
.BR "func (*mapType) Out(" "i" " int) Type"
.PP
.BR "func (*mapType) PkgPath() string"
.PP
.BR "func (*mapType) Size() uintptr"
.PP
.BR "func (*mapType) String() string"
.SS "ptrType"
.B type ptrType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
ptrType represents a pointer type. 
.PP
.BR "func (*ptrType) Align() int"
.PP
.BR "func (*ptrType) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*ptrType) Bits() int"
.PP
.BR "func (*ptrType) ChanDir() ChanDir"
.PP
.BR "func (*ptrType) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*ptrType) Elem() Type"
.PP
.BR "func (*ptrType) Field(" "i" " int) StructField"
.PP
.BR "func (*ptrType) FieldAlign() int"
.PP
.BR "func (*ptrType) FieldByIndex(" "index" " []int) StructField"
.PP
.BR "func (*ptrType) FieldByName(" "name" " string) (StructField, bool)"
.PP
.BR "func (*ptrType) FieldByNameFunc(" "match" " func(string) bool) (StructField, bool)"
.PP
.BR "func (*ptrType) Implements(" "u" " Type) bool"
.PP
.BR "func (*ptrType) In(" "i" " int) Type"
.PP
.BR "func (*ptrType) IsVariadic() bool"
.PP
.BR "func (*ptrType) Key() Type"
.PP
.BR "func (*ptrType) Kind() Kind"
.PP
.BR "func (*ptrType) Len() int"
.PP
.BR "func (*ptrType) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*ptrType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*ptrType) Name() string"
.PP
.BR "func (*ptrType) NumField() int"
.PP
.BR "func (*ptrType) NumIn() int"
.PP
.BR "func (*ptrType) NumMethod() int"
.PP
TODO(rsc): 6g supplies these, but they are not as efficient as they could be: they have commonType as the receiver instead of *rtype. 
.PP
.BR "func (*ptrType) NumOut() int"
.PP
.BR "func (*ptrType) Out(" "i" " int) Type"
.PP
.BR "func (*ptrType) PkgPath() string"
.PP
.BR "func (*ptrType) Size() uintptr"
.PP
.BR "func (*ptrType) String() string"
.SS "rtype"
.B type rtype struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
rtype is the common implementation of most values. 
It is embedded in other, public struct types, but always with a unique tag like `reflect:"array"` or `reflect:"ptr"` so that code cannot convert from, say, *arrayType to *ptrType. 
.PP
.BR "func (*rtype) Align() int"
.PP
.BR "func (*rtype) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*rtype) Bits() int"
.PP
.BR "func (*rtype) ChanDir() ChanDir"
.PP
.BR "func (*rtype) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*rtype) Elem() Type"
.PP
.BR "func (*rtype) Field(" "i" " int) StructField"
.PP
.BR "func (*rtype) FieldAlign() int"
.PP
.BR "func (*rtype) FieldByIndex(" "index" " []int) StructField"
.PP
.BR "func (*rtype) FieldByName(" "name" " string) (StructField, bool)"
.PP
.BR "func (*rtype) FieldByNameFunc(" "match" " func(string) bool) (StructField, bool)"
.PP
.BR "func (*rtype) Implements(" "u" " Type) bool"
.PP
.BR "func (*rtype) In(" "i" " int) Type"
.PP
.BR "func (*rtype) IsVariadic() bool"
.PP
.BR "func (*rtype) Key() Type"
.PP
.BR "func (*rtype) Kind() Kind"
.PP
.BR "func (*rtype) Len() int"
.PP
.BR "func (*rtype) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*rtype) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*rtype) Name() string"
.PP
.BR "func (*rtype) NumField() int"
.PP
.BR "func (*rtype) NumIn() int"
.PP
.BR "func (*rtype) NumMethod() int"
.PP
TODO(rsc): 6g supplies these, but they are not as efficient as they could be: they have commonType as the receiver instead of *rtype. 
.PP
.BR "func (*rtype) NumOut() int"
.PP
.BR "func (*rtype) Out(" "i" " int) Type"
.PP
.BR "func (*rtype) PkgPath() string"
.PP
.BR "func (*rtype) Size() uintptr"
.PP
.BR "func (*rtype) String() string"
.SS "sliceHeader"
.B type sliceHeader struct {
.RS
.B Data unsafe.Pointer
.sp 0
.B Len int
.sp 0
.B Cap int
.RE
.B }
.PP
sliceHeader is a safe version of SliceHeader used within this package. 
.SS "sliceType"
.B type sliceType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
sliceType represents a slice type. 
.PP
.BR "func (*sliceType) Align() int"
.PP
.BR "func (*sliceType) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*sliceType) Bits() int"
.PP
.BR "func (*sliceType) ChanDir() ChanDir"
.PP
.BR "func (*sliceType) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*sliceType) Elem() Type"
.PP
.BR "func (*sliceType) Field(" "i" " int) StructField"
.PP
.BR "func (*sliceType) FieldAlign() int"
.PP
.BR "func (*sliceType) FieldByIndex(" "index" " []int) StructField"
.PP
.BR "func (*sliceType) FieldByName(" "name" " string) (StructField, bool)"
.PP
.BR "func (*sliceType) FieldByNameFunc(" "match" " func(string) bool) (StructField, bool)"
.PP
.BR "func (*sliceType) Implements(" "u" " Type) bool"
.PP
.BR "func (*sliceType) In(" "i" " int) Type"
.PP
.BR "func (*sliceType) IsVariadic() bool"
.PP
.BR "func (*sliceType) Key() Type"
.PP
.BR "func (*sliceType) Kind() Kind"
.PP
.BR "func (*sliceType) Len() int"
.PP
.BR "func (*sliceType) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*sliceType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*sliceType) Name() string"
.PP
.BR "func (*sliceType) NumField() int"
.PP
.BR "func (*sliceType) NumIn() int"
.PP
.BR "func (*sliceType) NumMethod() int"
.PP
TODO(rsc): 6g supplies these, but they are not as efficient as they could be: they have commonType as the receiver instead of *rtype. 
.PP
.BR "func (*sliceType) NumOut() int"
.PP
.BR "func (*sliceType) Out(" "i" " int) Type"
.PP
.BR "func (*sliceType) PkgPath() string"
.PP
.BR "func (*sliceType) Size() uintptr"
.PP
.BR "func (*sliceType) String() string"
.SS "stringHeader"
.B type stringHeader struct {
.RS
.B Data unsafe.Pointer
.sp 0
.B Len int
.RE
.B }
.PP
stringHeader is a safe version of StringHeader used within this package. 
.SS "structType"
.B type structType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
structType represents a struct type. 
.PP
.BR "func (*structType) Align() int"
.PP
.BR "func (*structType) AssignableTo(" "u" " Type) bool"
.PP
.BR "func (*structType) Bits() int"
.PP
.BR "func (*structType) ChanDir() ChanDir"
.PP
.BR "func (*structType) ConvertibleTo(" "u" " Type) bool"
.PP
.BR "func (*structType) Elem() Type"
.PP
.BR "func (*structType) Field(" "i" " int) (" "f" " StructField)"
.PP
Field returns the i'th struct field. 
.PP
.BR "func (*structType) FieldAlign() int"
.PP
.BR "func (*structType) FieldByIndex(" "index" " []int) (" "f" " StructField)"
.PP
FieldByIndex returns the nested field corresponding to index. 
.PP
.BR "func (*structType) FieldByName(" "name" " string) (" "f" " StructField, " "present" " bool)"
.PP
FieldByName returns the struct field with the given name and a boolean to indicate if the field was found. 
.PP
.BR "func (*structType) FieldByNameFunc(" "match" " func(string) bool) (" "result" " StructField, " "ok" " bool)"
.PP
FieldByNameFunc returns the struct field with a name that satisfies the match function and a boolean to indicate if the field was found. 
.PP
.BR "func (*structType) Implements(" "u" " Type) bool"
.PP
.BR "func (*structType) In(" "i" " int) Type"
.PP
.BR "func (*structType) IsVariadic() bool"
.PP
.BR "func (*structType) Key() Type"
.PP
.BR "func (*structType) Kind() Kind"
.PP
.BR "func (*structType) Len() int"
.PP
.BR "func (*structType) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*structType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*structType) Name() string"
.PP
.BR "func (*structType) NumField() int"
.PP
.BR "func (*structType) NumIn() int"
.PP
.BR "func (*structType) NumMethod() int"
.PP
TODO(rsc): 6g supplies these, but they are not as efficient as they could be: they have commonType as the receiver instead of *rtype. 
.PP
.BR "func (*structType) NumOut() int"
.PP
.BR "func (*structType) Out(" "i" " int) Type"
.PP
.BR "func (*structType) PkgPath() string"
.PP
.BR "func (*structType) Size() uintptr"
.PP
.BR "func (*structType) String() string"
.SS "uncommonType"
.B type uncommonType struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
uncommonType is present only for types with names or methods (if T is a named type, the uncommonTypes for T and *T have methods). 
Using a pointer to this struct reduces the overall size required to describe an unnamed type with no methods. 
.PP
.BR "func (*uncommonType) Method(" "i" " int) (" "m" " Method)"
.PP
.BR "func (*uncommonType) MethodByName(" "name" " string) (" "m" " Method, " "ok" " bool)"
.PP
.BR "func (*uncommonType) Name() string"
.PP
.BR "func (*uncommonType) NumMethod() int"
.PP
.BR "func (*uncommonType) PkgPath() string"
.SH "BUGS"
FieldByName and related functions consider struct field names to be equal if the names are equal, even if they are unexported names originating in different packages. 
The practical effect of this is that the result of t.FieldByName("x") is not well defined if the struct type t contains multiple fields named x (embedded from different packages). 
FieldByName may return one of the fields named x or may report that there are none. 
See golang.org/issue/4876 for more details.   
