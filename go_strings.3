.\"    Automatically generated by mango(1)
.TH "strings" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
strings \- Package strings implements simple functions to manipulate strings.
.SH "SYNOPSIS"
.B import \*(lqstrings\(rq
.sp
.RB "func " Contains
.sp 0
.RB "func " ContainsAny
.sp 0
.RB "func " ContainsRune
.sp 0
.RB "func " Count
.sp 0
.RB "func " EqualFold
.sp 0
.RB "func " Fields
.sp 0
.RB "func " FieldsFunc
.sp 0
.RB "func " HasPrefix
.sp 0
.RB "func " HasSuffix
.sp 0
.RB "func " Index
.sp 0
.RB "func " IndexAny
.sp 0
.RB "func " IndexByte
.sp 0
.RB "func " IndexFunc
.sp 0
.RB "func " IndexRune
.sp 0
.RB "func " Join
.sp 0
.RB "func " LastIndex
.sp 0
.RB "func " LastIndexAny
.sp 0
.RB "func " LastIndexFunc
.sp 0
.RB "func " Map
.sp 0
.RB "func " Repeat
.sp 0
.RB "func " Replace
.sp 0
.RB "func " Split
.sp 0
.RB "func " SplitAfter
.sp 0
.RB "func " SplitAfterN
.sp 0
.RB "func " SplitN
.sp 0
.RB "func " Title
.sp 0
.RB "func " ToLower
.sp 0
.RB "func " ToLowerSpecial
.sp 0
.RB "func " ToTitle
.sp 0
.RB "func " ToTitleSpecial
.sp 0
.RB "func " ToUpper
.sp 0
.RB "func " ToUpperSpecial
.sp 0
.RB "func " Trim
.sp 0
.RB "func " TrimFunc
.sp 0
.RB "func " TrimLeft
.sp 0
.RB "func " TrimLeftFunc
.sp 0
.RB "func " TrimPrefix
.sp 0
.RB "func " TrimRight
.sp 0
.RB "func " TrimRightFunc
.sp 0
.RB "func " TrimSpace
.sp 0
.RB "func " TrimSuffix
.sp 0
.RB "type " Reader
.sp 0
.RS
.RB "func " NewReader
.sp 0
.RB "func (*Reader) " Len
.sp 0
.RB "func (*Reader) " Read
.sp 0
.RB "func (*Reader) " ReadAt
.sp 0
.RB "func (*Reader) " ReadByte
.sp 0
.RB "func (*Reader) " ReadRune
.sp 0
.RB "func (*Reader) " Seek
.sp 0
.RB "func (*Reader) " UnreadByte
.sp 0
.RB "func (*Reader) " UnreadRune
.sp 0
.RB "func (*Reader) " WriteTo
.sp 0
.RE
.RB "type " Replacer
.sp 0
.RS
.RB "func " NewReplacer
.sp 0
.RB "func (*Replacer) " Replace
.sp 0
.RB "func (*Replacer) " WriteString
.sp 0
.RE
.RB "type " appendSliceWriter
.sp 0
.RS
.RB "func (*appendSliceWriter) " Write
.sp 0
.RB "func (*appendSliceWriter) " WriteString
.sp 0
.RE
.RB "type " byteReplacer
.sp 0
.RS
.RB "func (*byteReplacer) " Replace
.sp 0
.RB "func (*byteReplacer) " WriteString
.sp 0
.RE
.RB "type " byteStringReplacer
.sp 0
.RS
.RB "func (*byteStringReplacer) " Replace
.sp 0
.RB "func (*byteStringReplacer) " WriteString
.sp 0
.RE
.RB "type " genericReplacer
.sp 0
.RS
.RB "func (*genericReplacer) " Replace
.sp 0
.RB "func (*genericReplacer) " WriteString
.sp 0
.RE
.RB "type " replacer
.sp 0
.RB "type " singleStringReplacer
.sp 0
.RS
.RB "func (*singleStringReplacer) " Replace
.sp 0
.RB "func (*singleStringReplacer) " WriteString
.sp 0
.RE
.RB "type " stringWriter
.sp 0
.RS
.RB "func (stringWriter) " WriteString
.sp 0
.RE
.RB "type " stringWriterIface
.sp 0
.RS
.RE
.SH "FUNCTIONS"
.PP
.BR "func Contains(" "s" ", " "substr" " string) bool"
.PP
Contains returns true if substr is within s. 
.PP
.BR "func ContainsAny(" "s" ", " "chars" " string) bool"
.PP
ContainsAny returns true if any Unicode code points in chars are within s. 
.PP
.BR "func ContainsRune(" "s" " string, " "r" " rune) bool"
.PP
ContainsRune returns true if the Unicode code point r is within s. 
.PP
.BR "func Count(" "s" ", " "sep" " string) int"
.PP
Count counts the number of non\-overlapping instances of sep in s. 
.PP
.BR "func EqualFold(" "s" ", " "t" " string) bool"
.PP
EqualFold reports whether s and t, interpreted as UTF\-8 strings, are equal under Unicode case\-folding. 
.PP
.BR "func Fields(" "s" " string) []string"
.PP
Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning an array of substrings of s or an empty list if s contains only white space. 
.PP
.BR "func FieldsFunc(" "s" " string, " "f" " func(rune) bool) []string"
.PP
FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. 
If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. 
.PP
.BR "func HasPrefix(" "s" ", " "prefix" " string) bool"
.PP
HasPrefix tests whether the string s begins with prefix. 
.PP
.BR "func HasSuffix(" "s" ", " "suffix" " string) bool"
.PP
HasSuffix tests whether the string s ends with suffix. 
.PP
.BR "func Index(" "s" ", " "sep" " string) int"
.PP
Index returns the index of the first instance of sep in s, or 
.B \-1
if sep is not present in s. 
.PP
.BR "func IndexAny(" "s" ", " "chars" " string) int"
.PP
IndexAny returns the index of the first instance of any Unicode code point from chars in s, or 
.B \-1
if no Unicode code point from chars is present in s. 
.PP
.BR "func IndexByte(" "s" " string, " "c" " byte) int"
.PP
IndexByte returns the index of the first instance of c in s, or 
.B \-1
if c is not present in s. 
.PP
.BR "func IndexFunc(" "s" " string, " "f" " func(rune) bool) int"
.PP
IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or 
.B \-1
if none do. 
.PP
.BR "func IndexRune(" "s" " string, " "r" " rune) int"
.PP
IndexRune returns the index of the first instance of the Unicode code point r, or 
.B \-1
if rune is not present in s. 
.PP
.BR "func Join(" "a" " []string, " "sep" " string) string"
.PP
Join concatenates the elements of a to create a single string. 
The separator string sep is placed between elements in the resulting string. 
.PP
.BR "func LastIndex(" "s" ", " "sep" " string) int"
.PP
LastIndex returns the index of the last instance of sep in s, or 
.B \-1
if sep is not present in s. 
.PP
.BR "func LastIndexAny(" "s" ", " "chars" " string) int"
.PP
LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or 
.B \-1
if no Unicode code point from chars is present in s. 
.PP
.BR "func LastIndexFunc(" "s" " string, " "f" " func(rune) bool) int"
.PP
LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or 
.B \-1
if none do. 
.PP
.BR "func Map(" "mapping" " func(rune) rune, " "s" " string) string"
.PP
Map returns a copy of the string s with all its characters modified according to the mapping function. 
If mapping returns a negative value, the character is dropped from the string with no replacement. 
.PP
.BR "func Repeat(" "s" " string, " "count" " int) string"
.PP
Repeat returns a new string consisting of count copies of the string s. 
.PP
.BR "func Replace(" "s" ", " "old" ", " "new" " string, " "n" " int) string"
.PP
Replace returns a copy of the string s with the first n non\-overlapping instances of old replaced by new. 
If n < 0, there is no limit on the number of replacements. 
.PP
.BR "func Split(" "s" ", " "sep" " string) []string"
.PP
Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators. 
If sep is empty, Split splits after each UTF\-8 sequence. 
It is equivalent to SplitN with a count of 
.B \-1.
.PP
.BR "func SplitAfter(" "s" ", " "sep" " string) []string"
.PP
SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings. 
If sep is empty, SplitAfter splits after each UTF\-8 sequence. 
It is equivalent to SplitAfterN with a count of 
.B \-1.
.PP
.BR "func SplitAfterN(" "s" ", " "sep" " string, " "n" " int) []string"
.PP
SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings. 
If sep is empty, SplitAfterN splits after each UTF\-8 sequence. 
The count determines the number of substrings to return: n > 0: at most n substrings; the last substring will be the unsplit remainder. 
n == 0: the result is nil (zero substrings) n < 0: all substrings 
.PP
.BR "func SplitN(" "s" ", " "sep" " string, " "n" " int) []string"
.PP
SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators. 
If sep is empty, SplitN splits after each UTF\-8 sequence. 
The count determines the number of substrings to return: n > 0: at most n substrings; the last substring will be the unsplit remainder. 
n == 0: the result is nil (zero substrings) n < 0: all substrings 
.PP
.BR "func Title(" "s" " string) string"
.PP
Title returns a copy of the string s with all Unicode letters that begin words mapped to their title case. 
.PP
BUG: The rule Title uses for word boundaries does not handle Unicode punctuation properly. 
.PP
.BR "func ToLower(" "s" " string) string"
.PP
ToLower returns a copy of the string s with all Unicode letters mapped to their lower case. 
.PP
.BR "func ToLowerSpecial(" "_case" " unicode.SpecialCase, " "s" " string) string"
.PP
ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case, giving priority to the special casing rules. 
.PP
.BR "func ToTitle(" "s" " string) string"
.PP
ToTitle returns a copy of the string s with all Unicode letters mapped to their title case. 
.PP
.BR "func ToTitleSpecial(" "_case" " unicode.SpecialCase, " "s" " string) string"
.PP
ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their title case, giving priority to the special casing rules. 
.PP
.BR "func ToUpper(" "s" " string) string"
.PP
ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case. 
.PP
.BR "func ToUpperSpecial(" "_case" " unicode.SpecialCase, " "s" " string) string"
.PP
ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case, giving priority to the special casing rules. 
.PP
.BR "func Trim(" "s" " string, " "cutset" " string) string"
.PP
Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed. 
.PP
.BR "func TrimFunc(" "s" " string, " "f" " func(rune) bool) string"
.PP
TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed. 
.PP
.BR "func TrimLeft(" "s" " string, " "cutset" " string) string"
.PP
TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed. 
.PP
.BR "func TrimLeftFunc(" "s" " string, " "f" " func(rune) bool) string"
.PP
TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed. 
.PP
.BR "func TrimPrefix(" "s" ", " "prefix" " string) string"
.PP
TrimPrefix returns s without the provided leading prefix string. 
If s doesn't start with prefix, s is returned unchanged. 
.PP
.BR "func TrimRight(" "s" " string, " "cutset" " string) string"
.PP
TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed. 
.PP
.BR "func TrimRightFunc(" "s" " string, " "f" " func(rune) bool) string"
.PP
TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed. 
.PP
.BR "func TrimSpace(" "s" " string) string"
.PP
TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode. 
.PP
.BR "func TrimSuffix(" "s" ", " "suffix" " string) string"
.PP
TrimSuffix returns s without the provided trailing suffix string. 
If s doesn't end with suffix, s is returned unchanged. 
.SH "TYPES"
.SS "Reader"
.B type Reader struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo, io.ByteScanner, and io.RuneScanner interfaces by reading from a string. 
.PP
.BR "func NewReader(" "s" " string) *Reader"
.PP
NewReader returns a new Reader reading from s. 
It is similar to bytes.NewBufferString but more efficient and read\-only. 
.PP
.BR "func (*Reader) Len() int"
.PP
Len returns the number of bytes of the unread portion of the string. 
.PP
.BR "func (*Reader) Read(" "b" " []byte) (" "n" " int, " "err" " error)"
.PP
.BR "func (*Reader) ReadAt(" "b" " []byte, " "off" " int64) (" "n" " int, " "err" " error)"
.PP
.BR "func (*Reader) ReadByte() (" "b" " byte, " "err" " error)"
.PP
.BR "func (*Reader) ReadRune() (" "ch" " rune, " "size" " int, " "err" " error)"
.PP
.BR "func (*Reader) Seek(" "offset" " int64, " "whence" " int) (int64, error)"
.PP
Seek implements the io.Seeker interface. 
.PP
.BR "func (*Reader) UnreadByte() error"
.PP
.BR "func (*Reader) UnreadRune() error"
.PP
.BR "func (*Reader) WriteTo(" "w" " io.Writer) (" "n" " int64, " "err" " error)"
.PP
WriteTo implements the io.WriterTo interface. 
.SS "Replacer"
.B type Replacer struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
A Replacer replaces a list of strings with replacements. 
.PP
.BR "func NewReplacer(" "oldnew" " ...string) *Replacer"
.PP
NewReplacer returns a new Replacer from a list of old, new string pairs. 
Replacements are performed in order, without overlapping matches. 
.PP
.BR "func (*Replacer) Replace(" "s" " string) string"
.PP
Replace returns a copy of s with all replacements performed. 
.PP
.BR "func (*Replacer) WriteString(" "w" " io.Writer, " "s" " string) (" "n" " int, " "err" " error)"
.PP
WriteString writes s to w with all replacements performed. 
.SS "appendSliceWriter"
.B type appendSliceWriter []byte
.PP
.PP
.BR "func (*appendSliceWriter) Write(" "p" " []byte) (int, error)"
.PP
Write writes to the buffer to satisfy io.Writer. 
.PP
.BR "func (*appendSliceWriter) WriteString(" "s" " string) (int, error)"
.PP
WriteString writes to the buffer without string\->[]byte\->string allocations. 
.SS "byteReplacer"
.B type byteReplacer struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
byteReplacer is the implementation that's used when all the "old" and "new" values are single ASCII bytes. 
.PP
.BR "func (*byteReplacer) Replace(" "s" " string) string"
.PP
.BR "func (*byteReplacer) WriteString(" "w" " io.Writer, " "s" " string) (" "n" " int, " "err" " error)"
.SS "byteStringReplacer"
.B type byteStringReplacer struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
byteStringReplacer is the implementation that's used when all the "old" values are single ASCII bytes but the "new" values vary in size. 
.PP
.BR "func (*byteStringReplacer) Replace(" "s" " string) string"
.PP
.BR "func (*byteStringReplacer) WriteString(" "w" " io.Writer, " "s" " string) (" "n" " int, " "err" " error)"
.PP
WriteString maintains one buffer that's at most 32KB. 
The bytes in s are enumerated and the buffer is filled. 
If it reaches its capacity or a byte has a replacement, the buffer is flushed to w. 
.SS "genericReplacer"
.B type genericReplacer struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
genericReplacer is the fully generic algorithm. 
It's used as a fallback when nothing faster can be used. 
.PP
.BR "func (*genericReplacer) Replace(" "s" " string) string"
.PP
.BR "func (*genericReplacer) WriteString(" "w" " io.Writer, " "s" " string) (" "n" " int, " "err" " error)"
.SS "replacer"
.B type replacer interface {
.RS
.B Replace(s string) string
.sp 0
.B WriteString(w io.Writer, s string) (n int, err error)
.sp 0
.RE
.B }
.PP
replacer is the interface that a replacement algorithm needs to implement. 
.SS "singleStringReplacer"
.B type singleStringReplacer struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
singleStringReplacer is the implementation that's used when there is only one string to replace (and that string has more than one byte). 
.PP
.BR "func (*singleStringReplacer) Replace(" "s" " string) string"
.PP
.BR "func (*singleStringReplacer) WriteString(" "w" " io.Writer, " "s" " string) (" "n" " int, " "err" " error)"
.SS "stringWriter"
.B type stringWriter struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (stringWriter) WriteString(" "s" " string) (int, error)"
.SS "stringWriterIface"
.B type stringWriterIface interface {
.RS
.B WriteString(string) (int, error)
.sp 0
.RE
.B }
.PP
