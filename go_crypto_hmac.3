.\"    Automatically generated by mango(1)
.TH "hmac" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
hmac \- Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as
defined in U.S.
.SH "SYNOPSIS"
.B import \*(lqhmac\(rq
.sp
.RB "func " Equal
.sp 0
.RB "func " New
.sp 0
.RB "type " hmac
.sp 0
.RS
.RB "func (*hmac) " BlockSize
.sp 0
.RB "func (*hmac) " Reset
.sp 0
.RB "func (*hmac) " Size
.sp 0
.RB "func (*hmac) " Sum
.sp 0
.RB "func (*hmac) " Write
.sp 0
.RE
.SH "DESCRIPTION"
Package hmac implements the Keyed\-Hash Message Authentication Code (HMAC) as defined in U.S. 
Federal Information Processing Standards Publication 198. 
An HMAC is a cryptographic hash that uses a key to sign a message. 
The receiver verifies the hash by recomputing it using the same key. 
.PP
Receivers should be careful to use Equal to compare MACs in order to avoid timing side\-channels: 
.PP
.RS
// CheckMAC returns true if messageMAC is a valid HMAC tag for message.
.sp 0
func CheckMAC(message, messageMAC, key []byte) bool {
.sp 0
.RS
mac := hmac.New(sha256.New, key)
.sp 0
mac.Write(message)
.sp 0
expectedMAC := mac.Sum(nil)
.sp 0
return hmac.Equal(messageMAC, expectedMAC)
.sp 0
.RE
}
.RE
.SH "FUNCTIONS"
.PP
.BR "func Equal(" "mac1" ", " "mac2" " []byte) bool"
.PP
Equal compares two MACs for equality without leaking timing information. 
.PP
.BR "func New(" "h" " func() hash.Hash, " "key" " []byte) hash.Hash"
.PP
New returns a new HMAC hash using the given hash.Hash type and key. 
.SH "TYPES"
.SS "hmac"
.B type hmac struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*hmac) BlockSize() int"
.PP
.BR "func (*hmac) Reset()"
.PP
.BR "func (*hmac) Size() int"
.PP
.BR "func (*hmac) Sum(" "in" " []byte) []byte"
.PP
.BR "func (*hmac) Write(" "p" " []byte) (" "n" " int, " "err" " error)"
