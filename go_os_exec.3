.\"    Automatically generated by mango(1)
.TH "exec" 3 "2014-11-26" "version 2014-11-26" "Go Packages"
.SH "NAME"
exec \- Package exec runs external commands.
.SH "SYNOPSIS"
.B import \*(lqexec\(rq
.sp
.B Variables
.sp 0
.RB "func " LookPath
.sp 0
.RB "type " Cmd
.sp 0
.RS
.RB "func " Command
.sp 0
.RB "func (*Cmd) " CombinedOutput
.sp 0
.RB "func (*Cmd) " Output
.sp 0
.RB "func (*Cmd) " Run
.sp 0
.RB "func (*Cmd) " Start
.sp 0
.RB "func (*Cmd) " StderrPipe
.sp 0
.RB "func (*Cmd) " StdinPipe
.sp 0
.RB "func (*Cmd) " StdoutPipe
.sp 0
.RB "func (*Cmd) " Wait
.sp 0
.RE
.RB "type " Error
.sp 0
.RS
.RB "func (*Error) " Error
.sp 0
.RE
.RB "type " ExitError
.sp 0
.RS
.RB "func (*ExitError) " Error
.sp 0
.RE
.RB "type " closeOnce
.sp 0
.RS
.RB "func (*closeOnce) " Close
.sp 0
.RE
.SH "DESCRIPTION"
Package exec runs external commands. 
It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I/O with pipes, and do other adjustments. 
.SH "VARIABLES"
ErrNotFound is the error resulting if a path search failed to find an executable file. 
.PP
.B var 
.B ErrNotFound 
.sp 0

.sp 0
ErrNotFound is the error resulting if a path search failed to find an executable file. 
.PP
.B var 
.B ErrNotFound 
.sp 0

.sp 0
ErrNotFound is the error resulting if a path search failed to find an executable file. 
.PP
.B var 
.B ErrNotFound 
.sp 0
.SH "FUNCTIONS"
.PP
.BR "func LookPath(" "file" " string) (string, error)"
.PP
LookPath searches for an executable binary named file in the directories named by the path environment variable. 
If file begins with "/", "#", "./", or "../", it is tried directly and the path is not consulted. 
The result may be an absolute path or a path relative to the current directory. 
.SH "TYPES"
.SS "Cmd"
.B type Cmd struct {
.RS
.B Path string
.sp 0
.B Args []string
.sp 0
.B Env []string
.sp 0
.B Dir string
.sp 0
.B Stdin io.Reader
.sp 0
.B Stdout io.Writer
.sp 0
.B Stderr io.Writer
.sp 0
.B ExtraFiles []*os.File
.sp 0
.B SysProcAttr *syscall.SysProcAttr
.sp 0
.B Process *os.Process
.sp 0
.B ProcessState *os.ProcessState
.sp 0
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
Cmd represents an external command being prepared or run. 
.PP
.BR "func Command(" "name" " string, " "arg" " ...string) *Cmd"
.PP
Command returns the Cmd struct to execute the named program with the given arguments. 
.PP
It sets only the Path and Args in the returned structure. 
.PP
If name contains no path separators, Command uses LookPath to resolve the path to a complete name if possible. 
Otherwise it uses name directly. 
.PP
The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. 
For example, Command("echo", "hello") 
.PP
.BR "func (*Cmd) CombinedOutput() ([]byte, error)"
.PP
CombinedOutput runs the command and returns its combined standard output and standard error. 
.PP
.BR "func (*Cmd) Output() ([]byte, error)"
.PP
Output runs the command and returns its standard output. 
.PP
.BR "func (*Cmd) Run() error"
.PP
Run starts the specified command and waits for it to complete. 
.PP
The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status. 
.PP
If the command fails to run or doesn't complete successfully, the error is of type *ExitError. 
Other error types may be returned for I/O problems. 
.PP
.BR "func (*Cmd) Start() error"
.PP
Start starts the specified command but does not wait for it to complete. 
.PP
The Wait method will return the exit code and release associated resources once the command exits. 
.PP
.BR "func (*Cmd) StderrPipe() (io.ReadCloser, error)"
.PP
StderrPipe returns a pipe that will be connected to the command's standard error when the command starts. 
.PP
Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. 
For the same reason, it is incorrect to use Run when using StderrPipe. 
See the StdoutPipe example for idiomatic usage. 
.PP
.BR "func (*Cmd) StdinPipe() (io.WriteCloser, error)"
.PP
StdinPipe returns a pipe that will be connected to the command's standard input when the command starts. 
The pipe will be closed automatically after Wait sees the command exit. 
A caller need only call Close to force the pipe to close sooner. 
For example, if the command being run will not exit until standard input is closed, the caller must close the pipe. 
.PP
.BR "func (*Cmd) StdoutPipe() (io.ReadCloser, error)"
.PP
StdoutPipe returns a pipe that will be connected to the command's standard output when the command starts. 
.PP
Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. 
For the same reason, it is incorrect to call Run when using StdoutPipe. 
See the example for idiomatic usage. 
.PP
.BR "func (*Cmd) Wait() error"
.PP
Wait waits for the command to exit. 
It must have been started by Start. 
.PP
The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status. 
.PP
If the command fails to run or doesn't complete successfully, the error is of type *ExitError. 
Other error types may be returned for I/O problems. 
.PP
Wait releases any resources associated with the Cmd. 
.SS "Error"
.B type Error struct {
.RS
.B Name string
.sp 0
.B Err error
.RE
.B }
.PP
Error records the name of a binary that failed to be executed and the reason it failed. 
.PP
.BR "func (*Error) Error() string"
.SS "ExitError"
.B type ExitError struct {
.RS
.RE
.B }
.PP
An ExitError reports an unsuccessful exit by a command. 
.PP
.BR "func (*ExitError) Error() string"
.SS "closeOnce"
.B type closeOnce struct {
.RS
.sp 0
.B //contains unexported fields.
.RE
.B }
.PP
.PP
.BR "func (*closeOnce) Close() error"
